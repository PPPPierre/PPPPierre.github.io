<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="LeetCode 刷题记录 - 每日一题" /><meta name="author" content="Stone SHI" /><meta property="og:locale" content="en" /><meta name="description" content="A sportive, outcoming, positive boy who always likes to challenge himself and never stops moving forward." /><meta property="og:description" content="A sportive, outcoming, positive boy who always likes to challenge himself and never stops moving forward." /><link rel="canonical" href="/posts/LeetCode_daily_challenge/" /><meta property="og:url" content="/posts/LeetCode_daily_challenge/" /><meta property="og:site_name" content="Stone SHI" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-11T21:01:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="LeetCode 刷题记录 - 每日一题" /><meta name="twitter:site" content="@Shuxin_Shi" /><meta name="twitter:creator" content="@Stone SHI" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Stone SHI"},"dateModified":"2022-08-18T09:19:47+08:00","datePublished":"2022-01-11T21:01:00+08:00","description":"A sportive, outcoming, positive boy who always likes to challenge himself and never stops moving forward.","headline":"LeetCode 刷题记录 - 每日一题","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/LeetCode_daily_challenge/"},"url":"/posts/LeetCode_daily_challenge/"}</script><title>LeetCode 刷题记录 - 每日一题 | Stone SHI</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Stone SHI"><meta name="application-name" content="Stone SHI"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://i.loli.net/2021/10/18/ZQlvsDd2akF9c1C.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Stone SHI</a></div><div class="site-subtitle font-italic">Personal blog used to record my learning, progress, and life.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/PPPPierre" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/Shuxin_Shi" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['ssxhcxr4691059','163.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>LeetCode 刷题记录 - 每日一题</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>LeetCode 刷题记录 - 每日一题</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Stone SHI </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Jan 11, 2022, 9:01 PM +0800" >Jan 11<i class="unloaded">2022-01-11T21:01:00+08:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Aug 18, 2022, 9:19 AM +0800" >Aug 18<i class="unloaded">2022-08-18T09:19:47+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="10220 words">56 min read</span></div></div><div class="post-content"><head> <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); </script><h1 id="20220111---1036-逃离大迷宫">2022.01.11 - 1036. 逃离大迷宫</h1><h2 id="题干">题干</h2><p>在一个 $10^6 × 10^6$ 的网格中，每个网格上方格的坐标为<code class="language-plaintext highlighter-rouge">(x, y)</code>。</p><p>现在从源方格<code class="language-plaintext highlighter-rouge">source = [sx, sy]</code>开始出发，意图赶往目标方格<code class="language-plaintext highlighter-rouge">target = [tx, ty]</code>。数组<code class="language-plaintext highlighter-rouge">blocked</code>是封锁的方格列表，其中每个<code class="language-plaintext highlighter-rouge">blocked[i] = [xi, yi]</code>表示坐标为<code class="language-plaintext highlighter-rouge">(xi, yi)</code>的方格是禁止通行的。</p><p>每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格<strong>不</strong>在给出的封锁列表<code class="language-plaintext highlighter-rouge">blocked</code>上。同时，不允许走出网格。</p><p>只有在可以通过一系列的移动从源方格<code class="language-plaintext highlighter-rouge">source</code>到达目标方格<code class="language-plaintext highlighter-rouge">target</code>时才返回<code class="language-plaintext highlighter-rouge">true</code>。否则，返回<code class="language-plaintext highlighter-rouge">false</code>。</p><h2 id="思路">思路</h2><p>这道题目的矩阵很大，直接搜索时间肯定会超时，但是有一个突破口，就是<code class="language-plaintext highlighter-rouge">0 &lt;= len(blocked) &lt;= 200</code>，<code class="language-plaintext highlighter-rouge">block</code>的数量是在两百个以内的。</p><p>有两个思路可供选择，第一个是<strong>压缩矩阵</strong>，就是除去<code class="language-plaintext highlighter-rouge">source</code>，<code class="language-plaintext highlighter-rouge">target</code>和所有<code class="language-plaintext highlighter-rouge">block</code>所在的行列，压缩所有的剩下的行列，这样就可以把问题化解为一个$200 × 200$矩阵内的广度优先搜索。</p><p>第二个思路是<strong>广度优先搜索加提前退出</strong>，而提前退出的条件就是利用了<code class="language-plaintext highlighter-rouge">block</code>的数量：判断<code class="language-plaintext highlighter-rouge">source</code>和<code class="language-plaintext highlighter-rouge">target</code>是否被<code class="language-plaintext highlighter-rouge">block</code>包围。</p><p>因为<code class="language-plaintext highlighter-rouge">block</code>数量有限，所以被<code class="language-plaintext highlighter-rouge">block</code>包围的格子数量也是有一个上限的，当 BFS 搜索的格子数量超过这个上限时，我们就可以认为<code class="language-plaintext highlighter-rouge">block</code>没有包围住 BFS 的起点。</p><p>而这个最大值是$(N_{block}-1)×N_{block}/2$，对应的这个情况就是所有的<code class="language-plaintext highlighter-rouge">block</code>作为斜边与两个边界在角落围成一个等腰直角三角形，此时面积最大。</p><p>所以一共有三种情况：</p><ol><li><p>起点被包围；</p><li><p>终点被包围；</p><li><p>都没有被包围。</p></ol><p>所以根据如上思想写一个函数去判断起点和终点是否都被包围即可。</p><h2 id="代码">代码</h2><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isEscapePossible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocked</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">source</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># 判断 src 是否被包围
</span>        <span class="k">def</span> <span class="nf">is_surrounded</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">max_area</span><span class="p">):</span>
            <span class="c1"># BFS 的队列
</span>            <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">src</span><span class="p">)]</span>
            <span class="c1"># 计算走过的格子数
</span>            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># visited 数组，这里用字典实现
</span>            <span class="n">visited</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">visited</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">src</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">max_area</span><span class="p">:</span>
                    <span class="c1"># 当搜索的格子数超过最大可围面积时，我们判断 src 没有被围上
</span>                    <span class="k">return</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]:</span>
                    <span class="n">x_next</span><span class="p">,</span> <span class="n">y_next</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span>
                    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x_next</span> <span class="o">&lt;=</span> <span class="mi">999999</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y_next</span> <span class="o">&lt;=</span> <span class="mi">999999</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">[</span><span class="n">x_next</span><span class="p">,</span> <span class="n">y_next</span><span class="p">]</span> <span class="o">==</span> <span class="n">dst</span><span class="p">:</span>
                            <span class="c1"># 如果找到 dst，直接返回
</span>                            <span class="k">return</span> <span class="mi">2</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">x_next</span><span class="p">,</span> <span class="n">y_next</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">block_dict</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x_next</span><span class="p">,</span> <span class="n">y_next</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                            <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">x_next</span><span class="p">,</span> <span class="n">y_next</span><span class="p">))</span>
                            <span class="n">visited</span><span class="p">[(</span><span class="n">x_next</span><span class="p">,</span> <span class="n">y_next</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c1"># 队列提前终止，说明无路可走，被包围
</span>            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="c1"># 广搜加提前退出
</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocked</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span> 
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">n_block</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocked</span><span class="p">)</span>
        <span class="c1"># 计算最大可包围面积
</span>        <span class="n">max_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_block</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n_block</span><span class="o">/</span><span class="mi">2</span>
        <span class="c1"># 用字典记录 block，防止重复遍历带来的高计算量
</span>        <span class="n">block_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocked</span><span class="p">:</span>
            <span class="n">block_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">block</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c1"># 首先判断起点是否被包围
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="n">is_surrounded</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">max_area</span><span class="p">)</span>
        <span class="c1"># 起点被包围
</span>        <span class="k">if</span> <span class="n">ans</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="c1"># 直接找到终点
</span>        <span class="k">elif</span> <span class="n">ans</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
        <span class="c1"># 判断终点情况
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="n">is_surrounded</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">max_area</span><span class="p">)</span>
        <span class="c1"># 终点被包围
</span>        <span class="k">if</span> <span class="n">ans</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="c1"># 两个点都没被包围
</span>        <span class="k">return</span> <span class="bp">True</span>
</pre></table></code></div></div><h1 id="20220113---747-至少是其他数字两倍的最大数简单">2022.01.13 - 747. 至少是其他数字两倍的最大数（简单）</h1><p>简单题，找到数组中的最大值并确保比其他数字都大两倍以上。</p><p>同时找<strong>最大数</strong>的和<strong>次大数</strong>，然后比较最大数和次大数的两倍即可。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">dominantIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">max_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">second_num</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># 遍历数组，更新最大和第二大数字的值
</span>        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">max_num</span><span class="p">:</span>
                <span class="n">second_num</span> <span class="o">=</span> <span class="n">max_num</span>
                <span class="n">max_num</span> <span class="o">=</span> <span class="n">num</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">elif</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">second_num</span><span class="p">:</span>
                <span class="n">second_num</span> <span class="o">=</span> <span class="n">num</span>

        <span class="c1"># 如果最大值大于等于第二大的数字的两倍则返回下标
</span>        <span class="k">if</span> <span class="n">max_num</span> <span class="o">&gt;=</span> <span class="n">second_num</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">max_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></table></code></div></div><h1 id="20220115---1716-计算力扣银行的钱">2022.01.15 - 1716. 计算力扣银行的钱</h1><p>简简单单的等差数列计算。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">totalMoney</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">weeks</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">7</span>
        <span class="n">days</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">7</span>
        <span class="n">money</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">weeks</span><span class="p">):</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">7</span>
        <span class="k">if</span> <span class="n">days</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">weeks</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">days</span><span class="p">)</span> <span class="o">*</span> <span class="n">days</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">money</span><span class="p">)</span>
</pre></table></code></div></div><h1 id="20220116---382-链表随机节点">2022.01.16 - 382. 链表随机节点</h1><p>这道题的目的主要在于考察蓄水池抽样算法。</p><p>如果我们可以通过遍历得知数据大小，那么可以通过均匀分布生成一个随机索引返回答案就行了。</p><p>但是实际场景是：</p><p>给定一个数据流，数据流长度 <code class="language-plaintext highlighter-rouge">N</code> 很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（$O(N)$）的情况下，能够随机选取出 <code class="language-plaintext highlighter-rouge">m</code> 个不重复的数据。</p><p>有三个事情值得注意：</p><ol><li>数据流长度 <code class="language-plaintext highlighter-rouge">N</code> 很大且不可知，所以不能一次性存入内存，也不能一次性得知数据的长度，数据大小也总是在变动的；<li>时间复杂度为$O(N)$，所以不能预先存储再用索引取出；<li>随机选取 <code class="language-plaintext highlighter-rouge">m</code> 个数，每个数被选中的概率为 <code class="language-plaintext highlighter-rouge">m/N</code> ，随机性的保证。</ol><p>算法思路如下：</p><ol><li>如果接收的数据量小于 <code class="language-plaintext highlighter-rouge">m</code> ，则依次放入蓄水池。<li>当接收到第 <code class="language-plaintext highlighter-rouge">i</code> 个数据时， <code class="language-plaintext highlighter-rouge">i &gt;= m</code> ，在 <code class="language-plaintext highlighter-rouge">[0, i]</code> 范围内取以随机数 <code class="language-plaintext highlighter-rouge">d</code> ，若 <code class="language-plaintext highlighter-rouge">d</code> 的落在 <code class="language-plaintext highlighter-rouge">[0, m-1]</code> 范围内，则用接收到的第 <code class="language-plaintext highlighter-rouge">i</code> 个数据替换蓄水池中的第 <code class="language-plaintext highlighter-rouge">d</code> 个数据。<li>重复步骤2。</ol><p>算法的精妙之处在于：当处理完所有的数据时，蓄水池中的每个数据都是以 <code class="language-plaintext highlighter-rouge">m/N</code> 的概率获得的。可以通过简单的手算来证明。</p><p>这道题目相当于 <code class="language-plaintext highlighter-rouge">m</code> 等于 1。</p><p>核心代码如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]):</span>
        <span class="c1"># 蓄水池算法
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span>

    <span class="k">def</span> <span class="nf">getRandom</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="n">res_node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># 从第二个数据开始替换
</span>        <span class="k">while</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># 生成基于目前遍历数据数目的随机数
</span>            <span class="n">rand</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rand</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># 如果随机到的数为 0，则替换
</span>                <span class="n">res_node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">return</span> <span class="n">res_node</span><span class="p">.</span><span class="n">val</span>
</pre></table></code></div></div><p>CPU 的性能总是有限的，当数据大小继续增加的时候，为了提高效率，我们可以应用分布式技术。</p><p>参考资料：</p><p><a href="https://www.jianshu.com/p/7a9ea6ece2af">蓄水池抽样算法（Reservoir Sampling）</a></p><h1 id="20220117---1220-统计元音字母序列的数目">2022.01.17 - 1220. 统计元音字母序列的数目</h1><p>今天的每日一题很有意思，首先看完想到的就是<strong>动态规划</strong>，建立 5 行 <code class="language-plaintext highlighter-rouge">n</code> 列的 dp 表，其中 <code class="language-plaintext highlighter-rouge">dp[i][j]</code> 表示<strong>最后一个字符是第 j 个字符的长度为 i 的字母序列的数量</strong>。</p><p>由于定义，同一列之间的字母序列是没有重复的，所以长度为 <code class="language-plaintext highlighter-rouge">k</code> 的所有序列的数量为 dp 表该列的数字之和。</p><p>定义好了 dp 表之后，状态转移表就很简单，因为题目已经给出了每一列存储数值和上一列的关系。</p><p>算完之后发现才 beat 5%，不能忍，马上又想到一个新的想法。来源于今天面试字节的斐波那契数列计算的 $O(log{n})$ 的算法。</p><p>就是使用<strong>矩阵</strong>来表示状态之间的转移，这个方法叫做<strong>矩阵快速幂</strong>。</p><p>比如斐波那契数列问题中，直接用如下 <code class="language-plaintext highlighter-rouge">N1</code> 作为初始状态，<code class="language-plaintext highlighter-rouge">M</code> 作为状态转移矩阵，然后就能发现，不断地用矩阵 <code class="language-plaintext highlighter-rouge">M</code> 点乘向量 <code class="language-plaintext highlighter-rouge">N</code>，就可以得到后续的结果。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">N1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">M</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
     <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
</pre></table></code></div></div><p>而时间复杂度降低的诀窍就在于，矩阵之间点乘可以直接构造出对应更高步数的状态转移矩阵。</p><p>比如 $M_2 = M \dot M$ 得到的是表示横跨两位的状态转移方程，比如 $N_5 = M_2 \dot N_3$。</p><p>利用这一性质，结合递归运算，就可以直接将复杂度减少到 $O(log(n))$ 了， 具体看代码：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countVowelPermutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 特殊情况
</span>        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">5</span>

        <span class="c1"># 初始状态
</span>        <span class="n">n1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span>

        <span class="c1"># 定义状态转移矩阵
</span>        <span class="bp">self</span><span class="p">.</span> <span class="n">M</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
        
        <span class="c1"># 获得 n 次方状态转移矩阵
</span>        <span class="n">M_n</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_M_n</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># 矩阵运算获得最终结果
</span>        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">M_n</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">n1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># 返回结果
</span>        <span class="k">return</span> <span class="n">res</span> <span class="o">%</span> <span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">9</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_M_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># 获得状态转移矩阵的 M 次方
</span>        <span class="c1"># 时间复杂度 O(logn)
</span>        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">M</span>
        <span class="n">half_M</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_M_n</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">res_M</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">product</span><span class="p">(</span><span class="n">half_M</span><span class="p">,</span> <span class="n">half_M</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">res_M</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">product</span><span class="p">(</span><span class="n">res_M</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res_M</span>

    <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">):</span>
        <span class="c1"># 5 * 5 的矩阵乘法
</span>        <span class="n">M</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                    <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">M1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">M2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">M</span>
</pre></table></code></div></div><h1 id="20220118---539-最小时间差">2022.01.18 - 539. 最小时间差</h1><p>求时间之间的最小差值，主要思路就是去重，数据转换，排序，首尾相接，然后差分求最小值。</p><p>如果有重复的，那么就可以直接返回 0.</p><p>否则就要在排序完之后，将最小的加上 24*60 然后添加到队尾，实现一个首位相接的效果。</p><p>参考代码如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findMinDifference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timePoints</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 去重
</span>        <span class="n">time_unique</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">timePoints</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_unique</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">timePoints</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="c1"># 数据转换
</span>        <span class="n">min_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">time_unique</span><span class="p">:</span>
            <span class="n">hour</span><span class="p">,</span> <span class="n">minute</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">':'</span><span class="p">)</span>
            <span class="n">min_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">hour</span><span class="p">)</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">minute</span><span class="p">))</span>
        <span class="c1"># 排序
</span>        <span class="n">min_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">min_list</span><span class="p">)</span>
        <span class="c1"># 首尾相接
</span>        <span class="n">min_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">24</span><span class="o">*</span><span class="mi">60</span> <span class="o">+</span> <span class="n">min_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># 差分求最小
</span>        <span class="n">diff</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_list</span><span class="p">))]</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
</pre></table></code></div></div><h1 id="20220122---1332-删除回文子序列">2022.01.22 - 1332. 删除回文子序列</h1><p>脑经急转弯，拿来练 C++ 了。</p><p>因为题目只有 <code class="language-plaintext highlighter-rouge">'a'</code> <code class="language-plaintext highlighter-rouge">'b'</code> 两种字符，所以最多只需要两次操作就能删除干净了，第一次删 <code class="language-plaintext highlighter-rouge">'a'</code>，第二次删 <code class="language-plaintext highlighter-rouge">'b'</code>。</p><p>所以只需要判断整个字符串是不是回文字符串即可，如果是，返回 <code class="language-plaintext highlighter-rouge">1</code>，如果不是就返回 <code class="language-plaintext highlighter-rouge">2</code>。</p><pre><code class="language-C++">class Solution {
public:
    int removePalindromeSub(string s) {
        
        int i = 0;
        int j = s.length() - 1;
        while (i &lt; j){
            if (s[i] == s[j]){
                i += 1;
                j -= 1;
            }
            else{
                return 2;
            }

        }
        return 1;
    }
};
</code></pre><h1 id="20220124---2045-到达目的地的第二短时间">2022.01.24 - 2045. 到达目的地的第二短时间</h1><p>这道题红绿灯的设置就是障眼法，因为所有的红绿灯的变化周期是相等的，所以的路径时间消耗又是一样的，所以如果用 BFS，一个路线在等红灯，其他路线也都在等红灯。</p><p>所以实际上这道题目的目标是如何求出<strong>到达目的地的严格次小步数</strong>。</p><p>求最小步数很简单， DFS 就可以了。但是如果求严格次小步数，就需要一些特殊的设计。</p><p>这里把以前用的 <code class="language-plaintext highlighter-rouge">visited</code> 数组用一个 <code class="language-plaintext highlighter-rouge">dist</code> 数组代替了，其中：</p><ul><li><p><code class="language-plaintext highlighter-rouge">dist[i][0]</code> 表示从点 <code class="language-plaintext highlighter-rouge">i</code> 到起点的<strong>最短距离</strong>；</p><li><p><code class="language-plaintext highlighter-rouge">dist[i][1]</code> 表示从点 <code class="language-plaintext highlighter-rouge">i</code> 到起点的<strong>严格次小距离</strong>。</p></ul><p>只有更新<strong>最短距离</strong>，才能知道<strong>严格次小距离的下限</strong>，而我们可以通过这两个值来对入队的节点进行条件限制。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>                <span class="k">if</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">next_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># 当某节点第一次符合上述条件入队时
</span>                    <span class="c1"># 对应的 step 一定是最小值
</span>                    <span class="n">dist</span><span class="p">[</span><span class="n">next_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">next_index</span><span class="p">,</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">dist</span><span class="p">[</span><span class="n">next_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">next_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># 当某节点第一次符合上述条件入队时
</span>                    <span class="c1"># 对应的 step 一定是严格次小小值
</span>                    <span class="n">dist</span><span class="p">[</span><span class="n">next_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">next_index</span><span class="p">,</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
</pre></table></code></div></div><p>上面第一个条件相当于原来的 <code class="language-plaintext highlighter-rouge">visited</code> 数组，在 BFS 的情况下每个节点只有第一次访问时会入队。</p><p>而第二个条件则保证了每一个节点第二次入队时的步数一定为<strong>严格次小步数</strong>，因为步数等于 <code class="language-plaintext highlighter-rouge">dist[next_index][0]</code> 的情况被排除在外了。</p><p>这样并不会导致漏掉部分情况，因为对同一节点相同步数的访问只是无用的重复访问而已。</p><p>最后讨论时间转换的情况，一共两种方法：</p><ol><li><p>通过分类讨论直接计算结果；</p><li><p>通过模拟每一步更新总时间。</p></ol><p>两者各有优劣，第一种时间快但是思考起来比较复杂；第二种直观好理解，坏处就是要遍历。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">secondMinimum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">change</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 使用邻接表来表示图
</span>        <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">vertex_1</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">vertex_2</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">vertex_1</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">vertex_2</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">vertex_2</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">vertex_1</span><span class="p">)</span>
        <span class="c1"># 使用队列结构实现 BFS
</span>        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="c1"># dist[i][0] 表示从点 i 到起点的最短距离
</span>        <span class="c1"># dist[i][1] 表示从点 i 到起点的严格次小距离
</span>        <span class="n">dist</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">float</span><span class="p">(</span><span class="n">inf</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># BFS 
</span>        <span class="k">while</span> <span class="n">dist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="n">inf</span><span class="p">):</span>

            <span class="n">index</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>

            <span class="c1"># BFS 可以保证每次节点入队时对应的 step 是非递减的
</span>            <span class="k">for</span> <span class="n">next_index</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">next_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># 当某节点第一次符合上述条件入队时
</span>                    <span class="c1"># 对应的 step 一定是最小值
</span>                    <span class="n">dist</span><span class="p">[</span><span class="n">next_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">next_index</span><span class="p">,</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">dist</span><span class="p">[</span><span class="n">next_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">next_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># 当某节点第一次符合上述条件入队时
</span>                    <span class="c1"># 对应的 step 一定是严格次小小值
</span>                    <span class="n">dist</span><span class="p">[</span><span class="n">next_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">next_index</span><span class="p">,</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># 使用函数来将步数转换为时间
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">time_calculate_1</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">time</span><span class="p">,</span> <span class="n">change</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">time_calculate_1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">change</span><span class="p">):</span>
        <span class="c1"># 分类讨论公式法
</span>        <span class="k">if</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="n">change</span><span class="p">:</span>
            <span class="n">move_per_change</span> <span class="o">=</span> <span class="n">change</span> <span class="o">//</span> <span class="n">time</span>
            <span class="k">if</span> <span class="n">change</span> <span class="o">%</span> <span class="n">time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">move_per_period</span> <span class="o">=</span> <span class="n">move_per_change</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">move_per_period</span> <span class="o">=</span> <span class="n">move_per_change</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">num_period</span> <span class="o">=</span> <span class="n">step</span> <span class="o">//</span> <span class="n">move_per_period</span>
            <span class="k">if</span> <span class="n">step</span> <span class="o">%</span> <span class="n">move_per_period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">num_period</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">change</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">time</span> <span class="o">*</span> <span class="n">move_per_period</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num_period</span> <span class="o">*</span> <span class="n">change</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">time</span> <span class="o">*</span> <span class="p">(</span><span class="n">step</span> <span class="o">%</span> <span class="n">move_per_period</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">//</span> <span class="n">change</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">time_pre_step</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="p">(</span><span class="n">change</span> <span class="o">-</span> <span class="n">time</span> <span class="o">%</span> <span class="n">change</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">time_pre_step</span> <span class="o">*</span> <span class="n">step</span> <span class="o">-</span> <span class="p">(</span><span class="n">change</span> <span class="o">-</span> <span class="n">time</span> <span class="o">%</span> <span class="n">change</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rest_time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">%</span> <span class="n">change</span>
                <span class="k">if</span> <span class="n">rest_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">rest_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">rest_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">time_calculate</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">rest_time</span><span class="p">,</span> <span class="n">change</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">time_calculate_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">change</span><span class="p">):</span>
        <span class="c1"># 模拟法
</span>        <span class="n">total_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">step</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">total_time</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">change</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">change</span><span class="p">:</span>
                <span class="n">total_time</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">change</span> <span class="o">-</span> <span class="n">total_time</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">change</span><span class="p">)</span>
            <span class="n">total_time</span> <span class="o">+=</span> <span class="n">time</span>
        <span class="k">return</span> <span class="n">total_time</span>
</pre></table></code></div></div><h1 id="20220125---1688-比赛中的配对次数">2022.01.25 - 1688. 比赛中的配对次数</h1><p>可以用递归，但是有更简单的方法：</p><p>每次匹配会淘汰一个队伍，最终只剩一个队伍，所以淘汰了 <code class="language-plaintext highlighter-rouge">n-1</code> 个队伍，所以匹配了 <code class="language-plaintext highlighter-rouge">n-1</code>，答案就是 <code class="language-plaintext highlighter-rouge">n-1</code>。</p><p>代码放递归的：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numberOfMatches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">rec</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            
            <span class="n">match_num</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rec</span><span class="p">(</span><span class="n">match_num</span><span class="p">)</span> <span class="o">+</span> <span class="n">match_num</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rec</span><span class="p">(</span><span class="n">match_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">match_num</span>

        <span class="k">return</span> <span class="n">rec</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></table></code></div></div><h1 id="20220127---2047-句子中的有效单词数">2022.01.27 - 2047. 句子中的有效单词数</h1><p>这道题用<strong>正则匹配</strong>更加锻炼自己，两点需要注意：</p><ol><li>模式字符串想清楚：<code class="language-plaintext highlighter-rouge">([a-z]*[!|.|,]?)?</code> 表示的是不包括 <code class="language-plaintext highlighter-rouge">'-'</code> 的合法单词，而 <code class="language-plaintext highlighter-rouge">'([a-z]+[-][a-z]+)'</code> 则表示带有 <code class="language-plaintext highlighter-rouge">'-'</code> 的部分，所以将两者结合就是能够匹配所有合法单词的模式字符串了。<li><code class="language-plaintext highlighter-rouge">pattern.match(word)</code> 的返回是从整个字符串的第一个字符开始匹配的结果，如果有连续的符合条件的匹配项，会返回多个匹配结果。所以要判断整个 <code class="language-plaintext highlighter-rouge">word</code> 是不是满足匹配条件，需要将匹配结果的第一个 <code class="language-plaintext highlighter-rouge">result[0]</code> 和整个 <code class="language-plaintext highlighter-rouge">word</code> 进行比较。</ol><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countValidWords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentence</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">sentence</span><span class="p">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nb">compile</span><span class="p">(</span><span class="sa">r</span><span class="s">'([a-z]+[-][a-z]+)?([a-z]*[!|.|,]?)?'</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">word</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span>
</pre></table></code></div></div><h1 id="20220128---1996-游戏中弱角色的数量">2022.01.28 - 1996. 游戏中弱角色的数量</h1><p>你正在参加一个多角色游戏，每个角色都有两个主要属性：<strong>攻击</strong> 和 <strong>防御</strong>。给你一个二维整数数组 <code class="language-plaintext highlighter-rouge">properties</code> ，其中 <code class="language-plaintext highlighter-rouge">properties[i] = [attack_i, defense_i]</code> 表示游戏中第 <code class="language-plaintext highlighter-rouge">i</code> 个角色的属性。</p><p>如果存在一个其他角色的攻击和防御等级<strong>都严格高于</strong>该角色的攻击和防御等级，则认为该角色为<strong>弱角色</strong>。更正式地，如果认为角色 <code class="language-plaintext highlighter-rouge">i</code> <strong>弱于</strong>存在的另一个角色 <code class="language-plaintext highlighter-rouge">j</code> ，那么 <code class="language-plaintext highlighter-rouge">attack_j &gt; attack_i</code> 且 <code class="language-plaintext highlighter-rouge">defense_j &gt; defense_i</code> 。</p><p>返回<strong>弱角色</strong>的数量。</p><p>两种方法，直接<strong>排序</strong>和<strong>单调栈</strong>，其核心思想一样，都是：</p><p>根据两个特征按照一定优先级进行排序。</p><p>目的是比大小，那么先排序一定没有错。</p><p>首先可以想到的是按照攻击力从大到小排序，然后从头开始遍历，用一个临时变量存储遍历过的角色的最大防御值 <code class="language-plaintext highlighter-rouge">max_defense</code>。</p><p>当目前遍历的角色的防御力 <code class="language-plaintext highlighter-rouge">defense</code> 小于 历史最大防御力 <code class="language-plaintext highlighter-rouge">max_defense</code> 的时候，则 <code class="language-plaintext highlighter-rouge">count</code> 加一。</p><p>这样的判定存在的问题就是历史防御力最高的角色可能和当前角色攻击力相同，于是就追加排序条件：当攻击力相同的时候，防御力升序排列，这样就可以避免前面所述的情况了。</p><p>参考代码如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numberOfWeakCharacters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">properties</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 首先按照攻击力降序排列，然后按照防御力升序排列
</span>        <span class="n">properties_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># 维护历史最大防御力
</span>        <span class="n">max_defence</span> <span class="o">=</span> <span class="n">properties_sorted</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># 计算弱角色数量
</span>        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># 从攻击力最高者开始遍历
</span>        <span class="k">for</span> <span class="n">attack</span><span class="p">,</span> <span class="n">defense</span> <span class="ow">in</span> <span class="n">properties_sorted</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">defense</span> <span class="o">&lt;</span> <span class="n">max_defence</span><span class="p">:</span>
                <span class="c1"># 当防御力低于历史最大防御力时，弱角色数量加一
</span>                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">defense</span> <span class="o">&gt;</span> <span class="n">max_defence</span><span class="p">:</span>
                <span class="c1"># 当防御力大于历史最大防御力时，更新历史最大防御力
</span>                <span class="n">max_defence</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">defense</span><span class="p">,</span> <span class="n">max_defence</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">count</span>
</pre></table></code></div></div><h1 id="20220130---884-两句话中的不常见单词">2022.01.30 - 884. 两句话中的不常见单词</h1><p>题目可以理解成：<strong>在两个字符串拼接的合成字符串中搜索返回只出现一次的单词</strong></p><p>方法一：</p><p>比较 Pythonic 的方法，将字符串连接再 <code class="language-plaintext highlighter-rouge">split</code> 之后，直接使用数组的 <code class="language-plaintext highlighter-rouge">count</code> 方法筛选出只出现一次的单词。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">uncommonFromSentences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">words_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">words</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="s">' '</span> <span class="o">+</span> <span class="n">s2</span><span class="p">).</span><span class="n">split</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span> <span class="k">if</span> <span class="n">words</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
</pre></table></code></div></div><p>方法二：</p><p>同样将字符串连接再 <code class="language-plaintext highlighter-rouge">split</code> ，但是这次是自己实现快速的单词频率计算。</p><p>用一个 <code class="language-plaintext highlighter-rouge">appeared_words</code> 的 <code class="language-plaintext highlighter-rouge">list</code> 结构来存储出现过的单词，利用 <code class="language-plaintext highlighter-rouge">dict</code> 结构来对单词在 <code class="language-plaintext highlighter-rouge">appeared_words</code> 内的索引进行记录。</p><p>当单词重复出现时，就从 <code class="language-plaintext highlighter-rouge">appeared_words</code> 里将对应的单词改为 <code class="language-plaintext highlighter-rouge">None</code>，最后遍历一遍 <code class="language-plaintext highlighter-rouge">appeared_words</code> 将剩余的单词输出即可。</p><p>时间复杂度为 $O(N)$。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">uncommonFromSentences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">words_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">words</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="s">' '</span> <span class="o">+</span> <span class="n">s2</span><span class="p">).</span><span class="n">split</span><span class="p">()</span>
        <span class="n">appeared_words</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">word</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">words_dict</span><span class="p">:</span> 
                <span class="n">appeared_words</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
                <span class="n">words_dict</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">appeared_words</span><span class="p">[</span><span class="n">words_dict</span><span class="p">[</span><span class="n">word</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">appeared_words</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">word</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></table></code></div></div><h1 id="20220131---1342-将数字变成-0-的操作次数">2022.01.31 - 1342. 将数字变成 0 的操作次数</h1><p>利用移位操作，在模拟过程中可以不需要在奇数情况下减一。</p><p>每一次判断当前数字是奇数还是偶数，奇数就操作数加二（除 2 和减 1），偶数就只加一（除 2）。</p><p>只是这个计算只能算到 1，所以循环直到数字为 1 ，最后结果再加一即可。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numberOfSteps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 特殊情况
</span>        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># 计算直到 1 时的操作数
</span>        <span class="k">while</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># 如果当前为奇数：则操作两次
</span>                <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 非奇数操作一次
</span>                <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># 每次向右移位一位，无视奇偶性，结果一样
</span>            <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
        <span class="c1"># 最后操作数 +1
</span>        <span class="k">return</span> <span class="n">res</span> <span class="o">+</span> <span class="mi">1</span>
</pre></table></code></div></div><h1 id="20220201---1763-最长的美好子字符串">2022.02.01 - 1763. 最长的美好子字符串</h1><p>一个比较难的简单题，可以动态规划，也可以用分治思想递归，分治比较快一些，代码如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestNiceSubstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># 递归
</span>        <span class="k">def</span> <span class="nf">rec</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                <span class="c1"># 遍历 s[i:j], 把第一个不满足大小写均在 s[i:j] 内的位置作为分割点
</span>                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]:</span>
                    <span class="c1"># 在左侧的字符串切片上调用递归
</span>                    <span class="c1"># 返回左边的最大美好子字符串位置
</span>                    <span class="n">l_i</span><span class="p">,</span> <span class="n">l_j</span> <span class="o">=</span> <span class="n">rec</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                    <span class="c1"># 在右侧的字符串切片上调用递归
</span>                    <span class="c1"># 返回右边的最大美好子字符串位置
</span>                    <span class="n">r_i</span><span class="p">,</span> <span class="n">r_j</span> <span class="o">=</span> <span class="n">rec</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                    <span class="c1"># 比较左右子字符串的长度，选择较长者返回
</span>                    <span class="k">if</span> <span class="p">(</span><span class="n">r_j</span> <span class="o">-</span> <span class="n">r_i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">l_j</span> <span class="o">-</span> <span class="n">l_i</span><span class="p">):</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">r_i</span><span class="p">,</span> <span class="n">r_j</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">l_i</span><span class="p">,</span> <span class="n">l_j</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">rec</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]</span>
</pre></table></code></div></div><h1 id="20220202---2000-反转单词前缀">2022.02.02 - 2000. 反转单词前缀</h1><p>关键就是如何将未找到 <code class="language-plaintext highlighter-rouge">ch</code> 的情况和找到的情况结合在一步代码里。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reversePrefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ch</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># 找到反转点
</span>        <span class="n">pos</span> <span class="o">=</span> <span class="n">word</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># 将 word 分两部分，处理后再拼接
</span>        <span class="k">return</span> <span class="n">word</span><span class="p">[:</span><span class="n">pos</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span><span class="p">:]</span>
</pre></table></code></div></div><h1 id="20220203---1414-和为-k-的最少斐波那契数字数目">2022.02.03 - 1414. 和为 K 的最少斐波那契数字数目</h1><p>首先基于动态规划生成小于 <code class="language-plaintext highlighter-rouge">k</code> 的所有斐波那契数字的列表 <code class="language-plaintext highlighter-rouge">num_list</code>。</p><p>然后根据斐波那契数字的性质，可以基于<strong>贪心</strong>的原则来从大到小寻找构成 <code class="language-plaintext highlighter-rouge">k</code> 的每个数字：</p><p>使用一个临时变量 <code class="language-plaintext highlighter-rouge">rest_sum</code> 来存储目标，每次寻找 <code class="language-plaintext highlighter-rouge">num_list[:r]</code> 中小于 <code class="language-plaintext highlighter-rouge">rest_sum</code> 的最大的数。</p><p><code class="language-plaintext highlighter-rouge">rest_sum</code> 初始化为 <code class="language-plaintext highlighter-rouge">k</code>，<code class="language-plaintext highlighter-rouge">r</code> 初始化为 <code class="language-plaintext highlighter-rouge">len(num_list) - 1</code>。</p><p>假设每次寻找到的数字下标为 <code class="language-plaintext highlighter-rouge">i</code>，更新 <code class="language-plaintext highlighter-rouge">rest_sum = rest_sum - num_list[i]</code>,</p><p>则根据斐波那契数列的性质，下次寻找的目标必定存在于 <code class="language-plaintext highlighter-rouge">num_list[:i-1]</code>，因此更新 <code class="language-plaintext highlighter-rouge">r = i - 1</code> 即可。</p><p>如果使用线性搜索，时间复杂度为 $O(N)$，参考代码如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findMinFibonacciNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 先生成所有小于 k 的斐波那契数列
</span>        <span class="n">num_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">new_num</span> <span class="o">=</span> <span class="n">num_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">num_list</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">new_num</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">num_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_num</span><span class="p">)</span>
            <span class="n">new_num</span> <span class="o">=</span> <span class="n">num_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">num_list</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="c1"># 初始化
</span>        <span class="n">max_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">rest_sum</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># 从大到小线性搜索
</span>        <span class="k">while</span> <span class="n">rest_sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rest_sum</span> <span class="o">&gt;=</span> <span class="n">num_list</span><span class="p">[</span><span class="n">max_index</span><span class="p">]:</span>
                <span class="n">rest_sum</span> <span class="o">-=</span> <span class="n">num_list</span><span class="p">[</span><span class="n">max_index</span><span class="p">]</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">max_index</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">res</span> 
</pre></table></code></div></div><p>可以使用二分搜索，但是时间并没有减少太多，因为线性搜索搜索到了之后会缩小搜索空间，而二分搜索是从中间开始，反而会产生一些重复的搜索步骤。</p><p>参考代码如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findMinFibonacciNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 先生成所有小于 k 的斐波那契数列
</span>        <span class="n">num_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">new_num</span> <span class="o">=</span> <span class="n">num_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">num_list</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">new_num</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">num_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_num</span><span class="p">)</span>
            <span class="n">new_num</span> <span class="o">=</span> <span class="n">num_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">num_list</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="c1"># 初始化
</span>        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">rest_sum</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">rest_sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># 重置左端点
</span>            <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># 使用二分法确定小于 rest_num 的最大元素的位置
</span>            <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">num_list</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rest_sum</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span>

            <span class="c1"># 减去找到的元素
</span>            <span class="n">rest_sum</span> <span class="o">-=</span> <span class="n">num_list</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="c1"># 更新右端点和结果
</span>            <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">res</span> 
</pre></table></code></div></div><h1 id="20220204---1725-可以形成最大正方形的矩形数目">2022.02.04 - 1725. 可以形成最大正方形的矩形数目</h1><p>思路简单。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countGoodRectangles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rectangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 生成所有切好的矩形边长的数组
</span>        <span class="n">lens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span> <span class="k">for</span> <span class="n">rect</span> <span class="ow">in</span> <span class="n">rectangles</span><span class="p">]</span>
        <span class="c1"># 返回最长边长的数量
</span>        <span class="k">return</span> <span class="n">lens</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">lens</span><span class="p">))</span>
</pre></table></code></div></div><h1 id="20220205---1219-黄金矿工">2022.02.05 - 1219. 黄金矿工</h1><p>这道题应该用<strong>回溯算法</strong>，开始的时候用错了，用了 BFS，在此阐述一下个人认为的 BFS 和回溯算法在目标上的不同点：</p><ol><li>BFS 的目标在于遍历所有的点，只关心每一个点，不关心路径，搜索空间是<strong>所有的点构成的空间</strong>；<li>回溯算法是遍历所有的路径，相比起 BFS，既关心点，也关心路径，搜索空间是<strong>所有的可能路径构成的空间</strong>。 这道题显然跟路径有关，不同路径返回的最大采矿量也不同，因此应该会<strong>回溯算法</strong>。</ol><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getMaximumGold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 初始化 visited 网格
</span>        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">max_gold</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>

        <span class="c1"># 定义回溯函数
</span>        <span class="c1"># 使用 visited 作为路径辅助
</span>        <span class="k">def</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">gold</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">max_gold</span>
            <span class="c1"># 将该点标记在路径上
</span>            <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c1"># 更新当前最大采矿量
</span>            <span class="n">new_gold</span> <span class="o">=</span> <span class="n">gold</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
            <span class="n">max_gold</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_gold</span><span class="p">,</span> <span class="n">new_gold</span><span class="p">)</span>
            <span class="c1"># 对非路径上的邻点调用回溯算法
</span>            <span class="k">for</span> <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)]:</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">new_x</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">new_y</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">new_x</span><span class="p">][</span><span class="n">new_y</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">new_x</span><span class="p">][</span><span class="n">new_y</span><span class="p">]:</span>
                    <span class="n">backtracking</span><span class="p">(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">,</span> <span class="n">new_gold</span><span class="p">)</span>
            <span class="c1"># 回退，从路径上消除该点
</span>            <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        
        <span class="c1"># 对每一个有矿的格子调用回溯算法
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">backtracking</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    
        <span class="k">return</span> <span class="n">max_gold</span>
</pre></table></code></div></div><h1 id="20220206---1748-唯一元素的和">2022.02.06 - 1748. 唯一元素的和</h1><p>可以直接用 <code class="language-plaintext highlighter-rouge">list</code> 类的内置 <code class="language-plaintext highlighter-rouge">count</code> 函数判断一个元素是否是唯一元素：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sumOfUnique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">nums</span> <span class="k">if</span> <span class="n">nums</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
</pre></table></code></div></div><p>或者自己构造映射来计算元素出现的次数：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sumOfUnique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 初始化计算出现次数的 dict
</span>        <span class="n">count_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># 遍历元素，计算出现次数
</span>        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">count_dict</span><span class="p">:</span>
                <span class="n">count_dict</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count_dict</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># 将唯一的元素累加
</span>        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">count_dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">count_dict</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">elem</span>
        <span class="k">return</span> <span class="n">res</span>
</pre></table></code></div></div><h1 id="20220207---1405-最长快乐字符串">2022.02.07 - 1405. 最长快乐字符串</h1><p>这一题主要基于<strong>贪心算法</strong>，每一步都选择剩余最多的字母加入答案的字符串中，因为最小的字母要承担作为分隔符的任务。</p><p>如果目标字母已经连续出现两次，那么选择第二多的字母。</p><p>通过连续局部最优得到全局最优。</p><p>参考代码如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestDiverseString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="s">'a'</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="s">'b'</span><span class="p">],</span> <span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="s">'c'</span><span class="p">]]</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">cnt</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># 判断是否符合快乐字符串条件
</span>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">ans</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ans</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># 判断是否已达到最长
</span>            <span class="k">if</span> <span class="n">cnt</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
            <span class="c1"># 将符合条件的最多的字母加入 list
</span>            <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># 对应剩余数量-1
</span>            <span class="n">cnt</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
</pre></table></code></div></div><h1 id="20220208---1001-网格照明">2022.02.08 - 1001. 网格照明</h1><p>难点在于如何储存记录每个位置灯的亮灭情况已经每个格子的点亮情况。</p><p>测试范例中有一个很大的矩阵，所以存储的时候如果需要初始化一个大矩阵就会直接超时。</p><p>因此用集合、词典或者哈希表来存储是最好的选择。</p><p>代码参考如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">gridIllumination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">lamps</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">queries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># 初始化灯状态集合
</span>        <span class="n">lamps_on</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># 初始化亮度字典，表示被点亮的行，列，对角线，反对角线
</span>        <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">antidiag</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># 遍历 lamps，得到在查询前的矩阵和字典的状态
</span>        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">lamps</span><span class="p">:</span>
            <span class="c1"># 如果对应位置灯未点亮则将其点亮并更新亮度词典
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lamps_on</span><span class="p">:</span>
                <span class="c1"># 将该位置加入点亮的灯的词典
</span>                <span class="n">lamps_on</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
                <span class="c1"># 灯辐射到的位置亮度 +1
</span>                <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">col</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">diag</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">antidiag</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># 遍历 queries，获取结果
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
            <span class="c1"># 查询亮度词典判断是否为照亮状态
</span>            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">col</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="n">diag</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="n">antidiag</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">continue</span>
            
            <span class="c1"># 熄灭范围内的灯并更新亮度词典
</span>            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">),(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">),(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)]:</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lamps_on</span><span class="p">:</span>
                    <span class="c1"># 将该位置从点亮的灯集合移除
</span>                    <span class="n">lamps_on</span><span class="p">.</span><span class="n">remove</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                    <span class="c1"># 灯辐射到的位置亮度 -1
</span>                    <span class="n">row</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">col</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">diag</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">antidiag</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ans</span>                          
</pre></table></code></div></div><h1 id="20220209---2006-差的绝对值为-k-的数对数目">2022.02.09 - 2006. 差的绝对值为 K 的数对数目</h1><p>先排序后计算，比较简单。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countKDifference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">nums</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                    <span class="n">ans</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ans</span>
</pre></table></code></div></div><h1 id="20220210---1447-最简分数">2022.02.10 - 1447. 最简分数</h1><p>比较简单的一道题：关键就是判断两个数互质。</p><p>这里调用了 Python 中的 <code class="language-plaintext highlighter-rouge">gcd</code> 函数。</p><p>实际上只需要用<strong>递归调用</strong>来实现<strong>辗转相除法</strong>即可。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c1"># # 判断两数最大公约数的辗转相除算法
# def gcd(i, j):
#     # 调整数字的大小顺序
#     if i &gt; j:
#         num_1, num_2 = i, j
#     else:
#         num_1, num_2 = j, i
#     # 当余数为 0 ，找到最大公约数
#     if num_1 % num_2 == 0:
#         return num_2
#     # 当余数不为 0，再用余数除除数
#     else:
#         return gcd(num_2, num_1 % num_2)
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">simplifiedFractions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s">"1/2"</span><span class="p">]</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="s">"1/2"</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># 只需要遍历前一半的分子即可
</span>            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
                <span class="c1"># 判断两数是否互质
</span>                <span class="c1"># 等价于最大公约数是否为 1
</span>                <span class="k">if</span> <span class="n">gcd</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># 将该分数加入答案
</span>                    <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                    <span class="c1"># 将 1 与该分数的差加入答案
</span>                    <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ans</span>
</pre></table></code></div></div><h1 id="20220211---1984-学生分数的最小差值">2022.02.11 - 1984. 学生分数的最小差值</h1><p>排序 + 滑动窗口</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minimumDifference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>
        <span class="n">nums</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">ans</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">diff</span>
        <span class="k">return</span> <span class="n">ans</span>
</pre></table></code></div></div><h1 id="20220212---1020-飞地的数量">2022.02.12 - 1020. 飞地的数量</h1><p>BFS 或者 DFS 中“过河拆桥”思想的运用。</p><p>由于需要统计不连接边界的白色格子的数量，那么先以所有边界为 <code class="language-plaintext highlighter-rouge">1</code> 的格子为起点，遍历所有连接的值为 <code class="language-plaintext highlighter-rouge">1</code> 格子，并将其置为 <code class="language-plaintext highlighter-rouge">0</code>。</p><p>这么一番操作过后，剩下的所有为 <code class="language-plaintext highlighter-rouge">1</code> 的格子，就都是满足条件需要计算的格子了。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numEnclaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># 定义 BFS 递归函数
</span>        <span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
            <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
            <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># “过河拆桥”
</span>                    <span class="c1"># 将遍历后的格子置为零
</span>                    <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)]:</span>
                        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">new_x</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">new_y</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">new_x</span><span class="p">][</span><span class="n">new_y</span><span class="p">]:</span>
                            <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">))</span>
        
        <span class="c1"># 对所有边界的格子调用 BFS 函数
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">bfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">bfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">bfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">bfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="c1"># 计算剩下的格子中为 1 的数量
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ans</span> <span class="o">+=</span> <span class="mi">1</span>
        
    <span class="k">return</span> <span class="n">ans</span>
</pre></table></code></div></div><h1 id="20220214---540-有序数组中的单一元素">2022.02.14 - 540. 有序数组中的单一元素</h1><p>题目要求 $O(logN)$ 的时间复杂度，直接提示我们使用二分法来解决这个问题。</p><p>因为题目给定的数组是有序数组，在所有出现两次的元素中寻找一个只出现一次的元素。</p><p>传统的二分法是根据二分点的数值大小和目标数的大小来决定后续锁定处理的分块。</p><p>而这道题则有一点不同，是根据二分位置的值的左右两部分的元素数量来决定的。</p><p>根据二分点的值我们总能按照元素将当前区块分成两份，而目标元素总是在元素数量为奇数的那一个区块中。</p><p>根据这个性质，我们就可以设计二分法的方案了：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">singleNonDuplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># 二分值等于其左边的值的情况
</span>                <span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># l 和 mid 之前（包含 mid）有偶数个数
</span>                    <span class="c1"># 说明目标数字在 mid 右侧
</span>                    <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span>
            <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># 二分值等于其右边的值的情况
</span>                <span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># l 和 mid 之前（包含 mid）有奇数个数
</span>                    <span class="c1"># 说明目标数字在 mid 右侧
</span>                    <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 两边都不相等，说明是只出现一遍的数
</span>                <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
</pre></table></code></div></div><h1 id="20220216---1719-重构一棵树的方案数">2022.02.16 - 1719. 重构一棵树的方案数</h1><p>号称 LeetCode 史上周赛最难题，几千人里只有十几个人做出来，思维难度非常之变态。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UF</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__count</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">connected</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">node2</span><span class="p">]:</span>
                <span class="n">node_light</span><span class="p">,</span> <span class="n">node_heavy</span> <span class="o">=</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_light</span><span class="p">,</span> <span class="n">node_heavy</span> <span class="o">=</span> <span class="n">node2</span><span class="p">,</span> <span class="n">node1</span>
            <span class="n">parent_light</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">node_light</span><span class="p">)</span>
            <span class="n">parent_heavy</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">node_heavy</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">parent_light</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent_heavy</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">parent_heavy</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">parent_light</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">roots</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">parent_light</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">__count</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">node</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">node</span>
    
    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">get_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">root_2_idx</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">__count</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">)):</span>
            <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">root_2_idx</span><span class="p">:</span>
                <span class="n">root_2_idx</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">groups</span><span class="p">[</span><span class="n">root_2_idx</span><span class="p">[</span><span class="n">root</span><span class="p">]].</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">groups</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">checkWays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pairs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        
        <span class="k">def</span> <span class="nf">rec</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">num_2_idx</span><span class="p">,</span> <span class="n">idx_2_num</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">num_2_idx</span><span class="p">:</span>
                    <span class="n">idx_2_num</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">cnt</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">num_2_idx</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
                    <span class="n">cnt</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cnt</span><span class="p">[</span><span class="n">num_2_idx</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">num_2_idx</span><span class="p">:</span>
                    <span class="n">idx_2_num</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">cnt</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">num_2_idx</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
                    <span class="n">cnt</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cnt</span><span class="p">[</span><span class="n">num_2_idx</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx_2_num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cnt</span><span class="p">))</span> <span class="k">if</span> <span class="n">cnt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">root_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root_num</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                
                <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">roots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># 对每一个可能的 root 都做一次选择
</span>                <span class="c1"># 把包含 root 的 pair 都去除
</span>                <span class="n">idx_2_num</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">num_2_idx</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">new_pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="n">root</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">new_pairs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">num_2_idx</span><span class="p">:</span>
                        <span class="n">num_2_idx</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">count</span>
                        <span class="n">idx_2_num</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">num_2_idx</span><span class="p">:</span>
                        <span class="n">num_2_idx</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">count</span>
                        <span class="n">idx_2_num</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                
                <span class="n">uf</span> <span class="o">=</span> <span class="n">UF</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">new_pairs</span><span class="p">:</span>
                    <span class="n">uf</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">num_2_idx</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">num_2_idx</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                
                <span class="c1"># print("new_pairs: ", new_pairs, count)
</span>
                <span class="n">root_res</span> <span class="o">=</span> <span class="mi">1</span>
                
                <span class="c1"># print("uf.group: ", uf.get_group())
</span>
                <span class="k">for</span> <span class="n">idx_group</span> <span class="ow">in</span> <span class="n">uf</span><span class="p">.</span><span class="n">get_group</span><span class="p">():</span>
                    <span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx_2_num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx_group</span><span class="p">]</span>
                    <span class="n">pairs_group</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">new_pairs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">group</span> <span class="ow">or</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                            <span class="n">pairs_group</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                    <span class="n">sub_res</span> <span class="o">=</span> <span class="n">rec</span><span class="p">(</span><span class="n">pairs_group</span><span class="p">)</span>

                    <span class="c1"># print("pairs_group: ", pairs_group, sub_res)
</span>
                    <span class="k">if</span> <span class="n">sub_res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">root_res</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">root_res</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">root_res</span> <span class="o">*</span> <span class="n">sub_res</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">root_res</span> <span class="o">*</span> <span class="n">root_num</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">rec</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
</pre></table></code></div></div><h1 id="20220216---1719-重构一棵树的方案数-1">2022.02.16 - 1719. 重构一棵树的方案数</h1><p>LeetCode 史上最难周赛题目</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>
</pre></table></code></div></div><h1 id="20220217---688-骑士在棋盘上的概率">2022.02.17 - 688. 骑士在棋盘上的概率</h1><p>仔细鉴别什么时候用回溯什么时候用动态规划。</p><p>这道题用回溯和动态规划都能做，但是显然，回溯会浪费大量的时间。</p><p>找到一定的判据来判断究竟什么时候用回溯，什么时候用动态规划。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>
</pre></table></code></div></div><h1 id="20220221---838-推多米诺">2022.02.21 - 838. 推多米诺</h1><h2 id="方法一广度优先搜索">方法一：广度优先搜索</h2><p>以所有初始时刻被推倒的骨牌为起点，按时间发展顺序模拟骨牌的推倒，搜索出所有被推倒的骨牌。</p><p>使用数组 <code class="language-plaintext highlighter-rouge">times</code> 来记录所有骨牌被推倒的时间，这个时间最大为 <code class="language-plaintext highlighter-rouge">len(dominoes)</code>。</p><p>当遍历到一个骨牌 <code class="language-plaintext highlighter-rouge">i</code> 时，根据其下一个被推倒方向的骨牌 <code class="language-plaintext highlighter-rouge">ni</code> 的被推倒时间 <code class="language-plaintext highlighter-rouge">times[ni]</code> 来决定是否继续搜索：</p><ol><li><p>如果 <code class="language-plaintext highlighter-rouge">times[ni] == -1</code> 说明是没有被推倒的竖直骨牌，那么将其记为推倒，更新 <code class="language-plaintext highlighter-rouge">times[ni]</code>，并且加入队列继续搜索。</p><li><p>如果 <code class="language-plaintext highlighter-rouge">times[ni] == times[i] + 1</code> 说明该骨牌在同一时刻受到另一个方向的推倒，那么根据规则它将保持竖直，<code class="language-plaintext highlighter-rouge">ans[ni] = '.'</code>，并且中止搜索。</p></ol><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="c1"># 方法一： 模拟
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pushDominoes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dominoes</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dominoes</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="s">'.'</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">directions</span> <span class="o">=</span> <span class="p">{</span><span class="s">'L'</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">'R'</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="c1"># 把初始起点加入队列
</span>        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dominoes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="s">'.'</span><span class="p">:</span>
                <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
                <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># DFS
</span>        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">ni</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">directions</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ni</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">times</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ans</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'.'</span><span class="p">:</span>
                    <span class="n">ans</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="s">'.'</span>
                <span class="k">elif</span> <span class="n">times</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">ans</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="n">times</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">ni</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="方法二-双指针">方法二： 双指针</h2><p>双指针搜索，任何连续竖立的多米诺骨牌构成的子串在最后的状态仅取决于该字串两端的多米诺骨牌：</p><ol><li>如果两端的骨牌倒向相同方向，则这一串骨牌均倒向该方向；<li>如果两端的骨牌相向而倒，则这一串骨牌也相向而倒；<li>如果两端的骨牌方向相反，则这一串骨牌保持竖立。 根据这一规则，使用双指针，寻找所有连续的竖立骨牌的区间，对区间两端点加以分类讨论，然后对区间内部竖立的骨牌处理即可。</ol><p>为了方便，可以在骨牌 list 两端分别加上向外倒的两个骨牌，不影响结果，但是方便代码计算过程。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="c1"># 方法二： 双指针
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pushDominoes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dominoes</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># 两端分别加上一张向外倒的骨牌降低程序复杂性
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="s">'L'</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">dominoes</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s">'R'</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># 寻找左端点的骨牌 i
</span>            <span class="k">if</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">'.'</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="c1"># 寻找右端点的骨牌 j
</span>            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">ans</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">'.'</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="c1"># 如果中间存在区间，则开始分类讨论
</span>            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ans</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="c1"># 两个端点骨牌都倒向一个方向
</span>                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                        <span class="n">ans</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">'R'</span><span class="p">:</span>
                    <span class="c1"># 两个端点骨牌相向而倒
</span>                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
                        <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">'R'</span>
                        <span class="n">ans</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">'L'</span>
            <span class="c1"># 终点变成下一个区间的起点
</span>            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
        
        <span class="c1"># 返回答案时去掉初始加上的两端的骨牌
</span>        <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></table></code></div></div><h1 id="20220222---1994-好子集的数目">2022.02.22 - 1994. 好子集的数目</h1></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/leetcode/'>LeetCode</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/leetcode/" class="post-tag no-text-decoration" >LeetCode</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=LeetCode 刷题记录 - 每日一题 - Stone SHI&url=/posts/LeetCode_daily_challenge/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=LeetCode 刷题记录 - 每日一题 - Stone SHI&u=/posts/LeetCode_daily_challenge/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=LeetCode 刷题记录 - 每日一题 - Stone SHI&url=/posts/LeetCode_daily_challenge/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', '')" data-toggle="tooltip" data-placement="top" title=""> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/LeetCode_daily_challenge/">LeetCode 刷题记录 - 每日一题</a><li><a href="/posts/LeetCode_backtrack/">LeetCode 刷题记录 - 回溯算法</a><li><a href="/posts/LeetCode_dynamic_programming/">LeetCode 刷题记录 - Dynamic Programming</a><li><a href="/posts/Machine-Learning/">Machine Learning - ESMI_MES-08 - Apprentissage artificiel</a><li><a href="/posts/LeetCode_graph/">LeetCode 刷题记录 - 数据结构之图（Graph）</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/tags/block-chain/">Block chain</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/parser/">Parser</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/backend/">Backend</a> <a class="post-tag" href="/tags/blog/">Blog</a> <a class="post-tag" href="/tags/compilation/">Compilation</a> <a class="post-tag" href="/tags/functional-programming/">Functional Programming</a> <a class="post-tag" href="/tags/java/">Java</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/LeetCode_linked_list/"><div class="card-body"> <span class="timeago small" >Dec 28, 2021<i class="unloaded">2021-12-28T04:26:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>LeetCode 刷题记录 - 数据结构之链表（Linked List）</h3><div class="text-muted small"><p> 参考链接： 一文搞懂单链表的六大解题套路 21. Merge Two Sorted Lists 方法：双指针 小技巧：代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 dummy 节点。你可以试试，如果不使用 dummy 虚拟节点，代码会复杂很多，而有了 dummy 节点这个占位节点，可以避免处理空指针的情况，降低代码的复杂性。 # De...</p></div></div></a></div><div class="card"> <a href="/posts/LeetCode_graph/"><div class="card-body"> <span class="timeago small" >Dec 31, 2021<i class="unloaded">2021-12-31T14:57:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>LeetCode 刷题记录 - 数据结构之图（Graph）</h3><div class="text-muted small"><p> 图论基础 主要组成：节点和边 主要存储方式： 邻接表：占用空间少，但无法快速判断两节点是否相邻； 邻接矩阵：占用空间大，但是可以快速判断两节点是否相邻。 重要概念： 有向图与无向图：无向就等于双向； 有环图与无环图：有环图需要visited数组来辅助遍历； 加权图：存储的邻接矩阵内的元素从布尔值变为整数或浮点数即可。 参考链接： ...</p></div></div></a></div><div class="card"> <a href="/posts/LeetCode_data_structure_design/"><div class="card-body"> <span class="timeago small" >Jan 8<i class="unloaded">2022-01-08T21:28:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>LeetCode 刷题记录 - 数据结构设计</h3><div class="text-muted small"><p> 146. LRU Cache 这道题的主要目标是构造一个数据结构来实现 LRU 缓存机制。 当内存的空间满了之后，我们总是需要按照一定的原则来删除内存中的数据，为新数据腾出空间。 LRU 就是这样一种机制，LRU 的全称是 Least Recently Used，也就是根据内容的最后一次使用时间来选择数据删除的优先级。 相比起最近使用过的数据，我们会优先选择...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Block_chain_TP2/" class="btn btn-outline-primary" prompt="Older"><p>区块链 Lab - Smart Contracts</p></a> <a href="/posts/LeetCode_bit_operation/" class="btn btn-outline-primary" prompt="Newer"><p>LeetCode 刷题记录 - 每日一题</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/Shuxin_SHI">SHI Shuxin</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/tags/block-chain/">Block chain</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/parser/">Parser</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/backend/">Backend</a> <a class="post-tag" href="/tags/blog/">Blog</a> <a class="post-tag" href="/tags/compilation/">Compilation</a> <a class="post-tag" href="/tags/functional-programming/">Functional Programming</a> <a class="post-tag" href="/tags/java/">Java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
