<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="LeetCode 刷题记录 - 数据结构之图（Graph）" /><meta name="author" content="Stone SHI" /><meta property="og:locale" content="en" /><meta name="description" content="A sportive, outcoming, positive boy who always likes to challenge himself and never stops moving forward." /><meta property="og:description" content="A sportive, outcoming, positive boy who always likes to challenge himself and never stops moving forward." /><link rel="canonical" href="/posts/LeetCode_graph/" /><meta property="og:url" content="/posts/LeetCode_graph/" /><meta property="og:site_name" content="Stone SHI" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-12-31T14:57:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="LeetCode 刷题记录 - 数据结构之图（Graph）" /><meta name="twitter:site" content="@Shuxin_Shi" /><meta name="twitter:creator" content="@Stone SHI" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Stone SHI"},"dateModified":"2022-01-29T04:07:52+08:00","datePublished":"2021-12-31T14:57:00+08:00","description":"A sportive, outcoming, positive boy who always likes to challenge himself and never stops moving forward.","headline":"LeetCode 刷题记录 - 数据结构之图（Graph）","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/LeetCode_graph/"},"url":"/posts/LeetCode_graph/"}</script><title>LeetCode 刷题记录 - 数据结构之图（Graph） | Stone SHI</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Stone SHI"><meta name="application-name" content="Stone SHI"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://i.loli.net/2021/10/18/ZQlvsDd2akF9c1C.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Stone SHI</a></div><div class="site-subtitle font-italic">Personal blog used to record my learning, progress, and life.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/PPPPierre" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/Shuxin_Shi" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['ssxhcxr4691059','163.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>LeetCode 刷题记录 - 数据结构之图（Graph）</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>LeetCode 刷题记录 - 数据结构之图（Graph）</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Stone SHI </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Dec 31, 2021, 2:57 PM +0800" >Dec 31, 2021<i class="unloaded">2021-12-31T14:57:00+08:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Jan 28, 2022, 9:07 PM +0100" >Jan 28<i class="unloaded">2022-01-29T04:07:52+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="13314 words">73 min read</span></div></div><div class="post-content"><head> <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); </script><h1 id="图论基础">图论基础</h1><p>主要组成：<strong>节点</strong>和<strong>边</strong></p><p>主要存储方式：</p><ol><li><strong>邻接表</strong>：占用空间少，但无法快速判断两节点是否相邻；<li><strong>邻接矩阵</strong>：占用空间大，但是可以快速判断两节点是否相邻。</ol><p>重要概念：</p><ol><li><strong>有向图</strong>与<strong>无向图</strong>：<strong>无向</strong>就等于<strong>双向</strong>；<li><strong>有环图</strong>与<strong>无环图</strong>：有环图需要<code class="language-plaintext highlighter-rouge">visited</code>数组来辅助遍历；<li><strong>加权图</strong>：存储的<strong>邻接矩阵</strong>内的元素从<strong>布尔值</strong>变为<strong>整数</strong>或<strong>浮点数</strong>即可。</ol><p>参考链接：</p><p><a href="https://labuladong.gitee.io/algo/2/19/34/">图论基础</a></p><h1 id="797-all-paths-from-source-to-target">797. All Paths From Source to Target</h1><p>这道题输入一幅<strong>有向无环图</strong>，这个图包含<code class="language-plaintext highlighter-rouge">n</code>个节点，标号从<code class="language-plaintext highlighter-rouge">0</code>到<code class="language-plaintext highlighter-rouge">n-1</code>，要求计算出所有从节点<code class="language-plaintext highlighter-rouge">0</code>到节点<code class="language-plaintext highlighter-rouge">n-1</code>的路径。</p><p>题目输入的<code class="language-plaintext highlighter-rouge">graph</code>是用「邻接表」表示的一幅图，其中<code class="language-plaintext highlighter-rouge">graph[i]</code>存储着节点<code class="language-plaintext highlighter-rouge">i</code>的所有邻居节点。</p><p>思路比较简单：以<code class="language-plaintext highlighter-rouge">0</code>为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可。</p><p>因为输入的图是无环且需要重复访问节点，所以不需要<code class="language-plaintext highlighter-rouge">visited</code>数组辅助，每条路径都是一定有终点的。</p><p>参考代码如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">allPathsSourceTarget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="c1"># 获得节点总数
</span>        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="c1"># 把当前节点加入列表
</span>            <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># 如果是终点，则把路径加入结果列表
</span>            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 遍历所有邻居节点
</span>                <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">traverse</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="c1"># 离开时将当前节点从路径中删除
</span>            <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            
        <span class="n">traverse</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</pre></table></code></div></div><h1 id="207-course-schedule">207. Course Schedule</h1><p>经典的判断有向图是否有环的问题。</p><p>问题设定在一个选课的背景下。给出<code class="language-plaintext highlighter-rouge">numCourses</code>为课程的数量，以及<code class="language-plaintext highlighter-rouge">prerequisites: List[List[int]]</code>存储了课程与课程之间的先决条件，给出这些课程是否可以学完，也就是确定由课程构成的图中是否有环。</p><p>思路比较简单，首先生成对应的邻接表，之后写好递归遍历的函数，结合<code class="language-plaintext highlighter-rouge">visited</code>减少重复遍历，最后靠<code class="language-plaintext highlighter-rouge">onPath</code>数组表示路径来判断是否有环。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">canFinish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numCourses</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># 用邻接表生成graph
</span>        <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">prereq</span> <span class="ow">in</span> <span class="n">prerequisites</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">prereq</span><span class="p">[</span><span class="mi">1</span><span class="p">]].</span><span class="n">append</span><span class="p">(</span><span class="n">prereq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># 初始化辅助用数组
</span>        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">)]</span>
        <span class="n">onPath</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">)]</span>
        <span class="n">hasCycle</span> <span class="o">=</span> <span class="bp">False</span>
        
        <span class="c1"># 定义遍历函数
</span>        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">hasCycle</span>
            <span class="c1"># 如果节点在路径上，则有环
</span>            <span class="k">if</span> <span class="n">onPath</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span> 
                <span class="n">hasCycle</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span>
            <span class="c1"># 如果访问过或者有环，停止遍历
</span>            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="ow">or</span> <span class="n">hasCycle</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="c1"># 前序遍历操作
</span>            <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">onPath</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">traverse</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="c1"># 后序遍历操作
</span>            <span class="n">onPath</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">):</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="ow">not</span> <span class="n">hasCycle</span>
</pre></table></code></div></div><h1 id="210-course-schedule-ii">210. Course Schedule II</h1><p>经典图论的拓扑排序问题，问题依旧是选课问题。给出<code class="language-plaintext highlighter-rouge">numCourses</code>为课程的数量，以及<code class="language-plaintext highlighter-rouge">prerequisites: List[List[int]]</code>存储了课程与课程之间的先决条件，给出为了学完所有课程所安排的学习顺序。</p><p>而直观地说，拓扑排序（Topological Sorting）的定义就是：<strong>把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的。</strong></p><p>相当于一个以节点优先级作为标准的排序问题。</p><p>对于这个问题，<strong>如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么这幅图的拓扑排序结果就是上课顺序。</strong></p><p>首先实现上一题的代码判断是否有环，<strong>而拓扑排序的结果，其实就是后序遍历结果的反转。</strong></p><p>为什么？有一个非常直观的解释：</p><p>在后序遍历中，只有遍历完所有邻居节点（在这道题里是前置课程）之后才会执行后序遍历位置的代码。换句话说，当邻居节点都被装到结果列表里面了，当前节点才会被装进去。</p><p>后序遍历的这一特点很重要，<strong>之所以拓扑排序的基础是后序遍历，是因为一个任务必须在等到所有的依赖任务都完成之后才能开始开始执行。</strong></p><p>至于为什么是后续遍历结果的反转，这取决与实际问题对应的图中<strong>边的方向的意义</strong>，如果是低优先级指向高优先级（一门课程的先修课程指向该课程，也就是学习顺序），那么就需要反转。如果是高优先级指向低优先级（一门课程指向其先修课程），那么实际上就并不需要反转，主要还是要结合实际情况分析。</p><p>参考代码如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numCourses</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        
        <span class="c1"># 遍历函数
</span>        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="c1"># 如果节点在路径里，判断有环
</span>            <span class="k">nonlocal</span> <span class="n">hasCycle</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">hasCycle</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="c1"># 如果存在环或者访问过就跳过
</span>            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="ow">or</span> <span class="n">hasCycle</span><span class="p">:</span>
                <span class="k">return</span>
            
            <span class="c1"># 前序遍历操作
</span>            <span class="n">path</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span> 

            <span class="c1"># 遍历
</span>            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">traverse</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            
            <span class="c1"># 后序遍历操作
</span>            <span class="n">path</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="c1"># 生成图的邻接表
</span>        <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">prec</span> <span class="ow">in</span> <span class="n">prerequisites</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">prec</span><span class="p">[</span><span class="mi">1</span><span class="p">]].</span><span class="n">append</span><span class="p">(</span><span class="n">prec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># 初始化变量
</span>        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">)]</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">)]</span>
        <span class="n">hasCycle</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">):</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">hasCycle</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># 翻转后序遍历结果
</span>        <span class="n">res</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">res</span>
</pre></table></code></div></div><p>还有一个很厉害的思路，不用到递归方法，也快很多，就是直接从课程的前置条件信息中，将课程的优先级计算出来，然后逐渐遍历零优先级的课程（也就是不需要前置条件的课程），去降低对应后续课程的优先级，逐渐扩充结果列表。</p><p>具体代码如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">findOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numCourses</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">):</span>
        <span class="s">"""
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: List[int]
        """</span>
        <span class="c1"># 生成邻接表和优先级表
</span>        <span class="n">adjacency_list</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">)]</span>
        <span class="n">in_degrees</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">numCourses</span>
        <span class="k">for</span> <span class="n">courses</span> <span class="ow">in</span> <span class="n">prerequisites</span><span class="p">:</span>
            <span class="n">course</span><span class="p">,</span> <span class="n">prereq</span> <span class="o">=</span> <span class="n">courses</span>
            <span class="c1"># 前置课程指向后续课程
</span>            <span class="n">adjacency_list</span><span class="p">[</span><span class="n">prereq</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">course</span><span class="p">)</span>
            <span class="c1"># 后续课程的优先级更高
</span>            <span class="n">in_degrees</span><span class="p">[</span><span class="n">course</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># 过滤出所有不需要前置条件的课程，也就是零优先级课程
</span>        <span class="n">zero_indegree_courses</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">)</span> <span class="k">if</span> <span class="n">in_degrees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># 遍历所有零优先级课程
</span>        <span class="k">for</span> <span class="n">course</span> <span class="ow">in</span> <span class="n">zero_indegree_courses</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">adjacent_course</span> <span class="ow">in</span> <span class="n">adjacency_list</span><span class="p">[</span><span class="n">course</span><span class="p">]:</span>
                <span class="c1"># 将该课程对应的后续课程的优先级减一
</span>                <span class="n">in_degrees</span><span class="p">[</span><span class="n">adjacent_course</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="c1"># 当该后续课程优先级为零时将其加入结果列表
</span>                <span class="k">if</span> <span class="n">in_degrees</span><span class="p">[</span><span class="n">adjacent_course</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">zero_indegree_courses</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">adjacent_course</span><span class="p">)</span>
        <span class="c1"># 最后返回零优先级课程列表
</span>        <span class="c1"># 如果存在环，则零优先级列表的元素数量一定低于课程数量
</span>        <span class="c1"># 因为环上的所有课程优先级至少为一，无法减为零
</span>        <span class="k">return</span> <span class="n">zero_indegree_courses</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zero_indegree_courses</span><span class="p">)</span> <span class="o">==</span> <span class="n">numCourses</span> <span class="k">else</span> <span class="p">[]</span>
</pre></table></code></div></div><p>参考：</p><p><a href="https://labuladong.gitee.io/algo/2/19/35/">拓扑排序，YYDS！</a></p><h1 id="785-is-graph-bipartite">785. Is Graph Bipartite?</h1><p>这道题涉及的知识是图论里的<strong>二分图</strong>定义。</p><p>什么是二分图？百度百科定义如下：</p><blockquote><p>二分图的顶点集可分割为两个互不相交的子集，图中每条边依附的两个顶点都分属于这两个子集，且两个子集内的顶点不相邻。</p></blockquote><p>其实该定义等价于「双色问题」：</p><blockquote><p>如果一个图是二分图，当且仅当可以只用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同。</p></blockquote><p>所以这道题的思路就比较简单，我们可以一边遍历图一遍进行染色，碰到遍历过的节点就比较其颜色和当前节点是否相同。</p><p>这里提供 DFS 和 BFS 两种方法：</p><p>DFS:</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isBipartite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="c1"># visited 数据： -1 未访问，0 和 1 分别代表两种颜色
</span>        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="c1"># 是否染色失败
</span>        <span class="n">fail</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c1"># DFS 递归函数
</span>        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">fail</span>
            <span class="k">if</span> <span class="n">fail</span><span class="p">:</span> <span class="k">return</span>
            <span class="c1"># 染色
</span>            <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
            <span class="c1"># 访问该节点每一个邻居节点
</span>            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="n">color</span><span class="p">:</span>
                    <span class="c1"># 如果邻居节点访问过且颜色和当前节点相同，则判定失败
</span>                    <span class="n">fail</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># 如果未访问则调用递归
</span>                    <span class="n">traverse</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span> <span class="n">color</span><span class="p">)</span>

        <span class="c1"># 对每一个节点都调用一次递归
</span>        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="ow">not</span> <span class="n">fail</span>
</pre></table></code></div></div><p>BFS:</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isBipartite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="c1"># 这里存储访问状态和颜色的数组要分开
</span>        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="c1"># 辅助 BFS 的队列
</span>        <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># 对未访问的节点进行遍历
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># 从队列取出节点
</span>                    <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="c1"># 标记访问
</span>                    <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                            <span class="c1"># 如果邻居节点访问过，则进行颜色判定
</span>                            <span class="k">if</span> <span class="n">colors</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">colors</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                                <span class="k">return</span> <span class="bp">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># 未访问则染色，且把邻居节点加入队列
</span>                            <span class="n">colors</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">colors</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
                            <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">True</span>
</pre></table></code></div></div><p>参考：</p><p><a href="https://labuladong.gitee.io/algo/2/19/36/">二分图判定</a></p><h1 id="886-possible-bipartition">886. Possible Bipartition</h1><p>和上一题一样的思路，就是多一步构建<code class="language-plaintext highlighter-rouge">graph</code>的过程。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">possibleBipartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dislikes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># 创建图
</span>        <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">dislike</span> <span class="ow">in</span> <span class="n">dislikes</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">dislike</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">dislike</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">dislike</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">dislike</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># 直接返回上一题的二分图解法
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">isBipartite</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">isBipartite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># ... 参考上一题
</span></pre></table></code></div></div><h1 id="323-number-of-connected-components-in-an-undirected-graph">323. Number of Connected Components in an Undirected Graph</h1><p>这一题考察的是 Union-Find 算法，也就是「并查集算法」的使用，主要用于解决图论中的「动态连通性」问题的。</p><h2 id="动态连通性">动态连通性</h2><p>在图论中，动态连通性主要指的是实现一种数据结构，能够满足以下需求：</p><blockquote><p>Given a set of N objects. Union command: connect two objects. Find/connected query: is there a path connecting the two objects?</p></blockquote><p>即能够实现检查两个节点是否连通，同时可以在任意两个不连通的节点之间添加连接。</p><p>所以 Union-Find 算法主要需要实现这两个 API：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UF</span><span class="p">:</span>
    <span class="c1"># ...
</span>
    <span class="c1"># 将 p 和 q 连接
</span>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        
    <span class="c1"># 判断 p 和 q 是否连通# 判断 p 和 q 是否连通
</span>    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        
    <span class="c1"># 返回图中有多少个连通分量
</span>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</pre></table></code></div></div><p>这里所说的「连通」是一种等价关系，具有如下三个性质：</p><p>1、自反性：节点<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">p</code>是连通的。</p><p>2、对称性：如果节点<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>连通，那么<code class="language-plaintext highlighter-rouge">q</code>和<code class="language-plaintext highlighter-rouge">p</code>也连通。</p><p>3、传递性：如果节点<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>连通<code class="language-plaintext highlighter-rouge">q</code>和<code class="language-plaintext highlighter-rouge">r</code>连通，那么<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">r</code>也连通。</p><p>从「连通」的概念我们可以推出「连通分量」的概念，即所有<strong>连通的节点构成的集合称为一个连通分量</strong>。</p><p>动态连通性问题的实际应用很多，比如：检查通信网络中计算机之间是否连通、电子电路中的触点是否连接或者社交网络中的人是否相识等等。</p><p>至此我们也搞清楚了，「并查集」中的「并」的意思，就是连接、合并两个连通分量；「查」就是查找判断两个节点是否属于一个连通分量。</p><p>Union-Find 算法的关键就在于 union 和 connected 函数的效率。</p><h2 id="数据结构">数据结构</h2><p>我们使用<strong>树</strong>结构来表示每一个连通分量，其中数的节点就是图的节点，实现的具体数据结构是<strong>数组</strong>。</p><p>我们规定每一个节点有一个指针指向其父节点，表示该节点和父节点连通，如果没有父节点，则指向自己。</p><p>那么一个连通分量内的所有节点都共享一个根节点，该根节点也就代表了整个连通分量。</p><p>现在假设有<code class="language-plaintext highlighter-rouge">N</code>个节点，数组的第<code class="language-plaintext highlighter-rouge">i</code>个元素则代表节点<code class="language-plaintext highlighter-rouge">i</code>所指向的父节点的索引，于是我们就可以用一个数组来表示整个随机分量的森林了：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UF</span><span class="p">:</span>
    <span class="c1"># 构造函数
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        
        <span class="c1"># 一开始互不连通
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">__count</span> <span class="o">=</span> <span class="n">n</span>
        <span class="c1"># 父节点指针初始指向自己
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># 将 p 和 q 连接
</span>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        
    <span class="c1"># 判断 p 和 q 是否连通# 判断 p 和 q 是否连通
</span>    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        
    <span class="c1"># 返回图中有多少个连通分量
</span>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">__count</span>
</pre></table></code></div></div><p><strong>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上：</strong></p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>    <span class="c1"># 将 p 和 q 连接
</span>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">rootP</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">rootQ</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rootP</span> <span class="o">!=</span> <span class="n">rootQ</span><span class="p">):</span>
            <span class="c1"># 合并两棵树
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">rootP</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootQ</span>
            <span class="c1"># 分量数减一
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">__count</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># 返回某个节点的根节点
</span>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 根节点的parent等于它自己
</span>        <span class="k">while</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></table></code></div></div><p><strong>判断节点 p 和 q 是否连通，只要检查它们是否拥有相同的根节点即可：</strong></p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="c1"># 判断 p 和 q 是否连通# 判断 p 和 q 是否连通
</span>    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">rootP</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">rootQ</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span>
</pre></table></code></div></div><p>至此， Union-Find 算法基本完成。其复杂度主要取决于<code class="language-plaintext highlighter-rouge">connected</code>和<code class="language-plaintext highlighter-rouge">union</code>两个 API 的复杂度，而这两个 API 的复杂度主要取决于 <code class="language-plaintext highlighter-rouge">find</code> 函数的复杂度，而 <code class="language-plaintext highlighter-rouge">find</code> 函数的复杂度则取决于树的大小和平衡情况。在最坏情况下一棵树会退化成一个链表，而此时<code class="language-plaintext highlighter-rouge">find</code>函数需要寻找到根节点就需要遍历整棵树， 时间复杂度为$O(N)$。对于社交网络等一些数据规模庞大的对象，这样的复杂度是十分不理想的。因此我们需要在生成树的过程做一些优化改进，使得生成的树结构更加平衡。</p><h2 id="算法改进-1-加权">算法改进 1. 加权</h2><p>添加一个<code class="language-plaintext highlighter-rouge">weight</code>数组，记录每一课树的“重量”，其实也就是节点数量，代表树的权重。在<code class="language-plaintext highlighter-rouge">union</code>函数中，总是让权重小的树的根节点指向权重大的树的根节点，这样可以一定程度上保证树结构的平衡性。</p><p>这一优化可以使得时间复杂度降低到$O(logN)$左右。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UF</span><span class="p">:</span>
    <span class="c1"># 构造函数
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        
        <span class="c1"># 一开始互不连通
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">__count</span> <span class="o">=</span> <span class="n">n</span>
        <span class="c1"># 父节点指针初始指向自己
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="c1"># 初始权重都是 1
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># 将 p 和 q 连接
</span>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">rootP</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">rootQ</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="p">:</span> <span class="k">return</span>
        <span class="c1"># 合并两棵树
</span>        <span class="c1"># 小树接到大树下面，更平衡
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">rootP</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">rootQ</span><span class="p">]:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">rootP</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootQ</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">rootQ</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">rootP</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">rootQ</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootP</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">rootP</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">rootQ</span><span class="p">]</span>
        <span class="c1"># 分量数减一
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">__count</span> <span class="o">-=</span> <span class="mi">1</span>
</pre></table></code></div></div><h2 id="算法改进-2-路径压缩">算法改进 2. 路径压缩</h2><p>在<code class="language-plaintext highlighter-rouge">find</code>函数中加上一行代码：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>    <span class="c1"># 返回某个节点的根节点
</span>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 根节点的parent等于它自己
</span>        <span class="k">while</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">):</span>
            <span class="c1"># 路径压缩
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></table></code></div></div><p>每一次<code class="language-plaintext highlighter-rouge">find</code>函数执行过程中，都可以压缩树结构，<strong>使得同一个连通分量里的每一个节点都直接指向其根节点</strong>。</p><p>在这样一个平的树的结构下，时间复杂度可以降低到$O(1)$。</p><h2 id="最终代码">最终代码</h2><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UF</span><span class="p">:</span>
    <span class="c1"># 构造函数
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        
        <span class="c1"># 一开始互不连通
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">__count</span> <span class="o">=</span> <span class="n">n</span>
        <span class="c1"># 父节点指针初始指向自己
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="c1"># 初始权重都是 1
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># 将 p 和 q 连接
</span>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">rootP</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">rootQ</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="p">:</span> <span class="k">return</span>
        <span class="c1"># 合并两棵树
</span>        <span class="c1"># 小树接到大树下面，更平衡
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">rootP</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">rootQ</span><span class="p">]:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">rootP</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootQ</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">rootQ</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">rootP</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">rootQ</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootP</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">rootP</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">rootQ</span><span class="p">]</span>
        <span class="c1"># 分量数减一
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">__count</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># 判断 p 和 q 是否连通# 判断 p 和 q 是否连通
</span>    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">rootP</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">rootQ</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span>
        
    <span class="c1"># 返回图中有多少个连通分量
</span>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">__count</span>
    
    <span class="c1"># 返回某个节点的根节点
</span>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 根节点的parent等于它自己
</span>        <span class="k">while</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">):</span>
            <span class="c1"># 路径压缩
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countComponents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">uf</span> <span class="o">=</span> <span class="n">UF</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">uf</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">uf</span><span class="p">.</span><span class="n">count</span><span class="p">()</span>
</pre></table></code></div></div><h2 id="参考资料">参考资料:</h2><p><a href="https://labuladong.gitee.io/algo/2/19/37/">UNION-FIND算法详解</a></p><p><a href="https://www.jianshu.com/p/44541a3fe8b3">算法4（Algorithms4）- Part 1 动态连通性（Dynamic Connectivity）1</a></p><h1 id="200-岛屿数量">200. 岛屿数量</h1><p>这道题可以有两种思路，</p><ol><li>简单的 DFS 或者 BFS，思路是遍历整个 <code class="language-plaintext highlighter-rouge">grid</code>，碰到一个 <code class="language-plaintext highlighter-rouge">"1"</code> 之后就调用 DFS 或者 BFS 遍历相邻的所有其他 <code class="language-plaintext highlighter-rouge">"1"</code>。访问过的 <code class="language-plaintext highlighter-rouge">"1"</code> 需要做上标记，可以使用 <code class="language-plaintext highlighter-rouge">visited</code> 数组或者直接在原矩阵中将其改为 <code class="language-plaintext highlighter-rouge">"0"</code>。这样最终岛屿的数量就是调用 DFS / BFS 的次数。<li>使用并查集，但是在生成并查集类的时候，要首先根据 <code class="language-plaintext highlighter-rouge">grid</code> 初始化 <code class="language-plaintext highlighter-rouge">parent</code> 数组，将所有 <code class="language-plaintext highlighter-rouge">"0"</code> 的 <code class="language-plaintext highlighter-rouge">parent</code> 初始化为统一的 <code class="language-plaintext highlighter-rouge">-1</code>， 然后根据 <code class="language-plaintext highlighter-rouge">"1"</code> 的数量来决定初始的树的数量，也就说是一个只针对一个元素的并查集。</ol><p>BFS / DFS 代码：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numIslands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 高度和宽度
</span>        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
        <span class="n">num_islands</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># 遍历网格
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">"1"</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                    <span class="c1"># 如果该块为陆地且未访问则发现新大陆
</span>                    <span class="c1"># 调用 bfs 且岛屿数量 +1
</span>                    <span class="bp">self</span><span class="p">.</span><span class="n">bfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
                    <span class="n">num_islands</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">num_islands</span>

    <span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="c1"># 只要踩上了一块土地，整块大陆就会被标记访问过
</span>        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">for</span> <span class="n">i_next</span><span class="p">,</span> <span class="n">j_next</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)]:</span>
                <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i_next</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j_next</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">i_next</span><span class="p">][</span><span class="n">j_next</span><span class="p">]</span> <span class="o">==</span> <span class="s">"1"</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i_next</span><span class="p">][</span><span class="n">j_next</span><span class="p">]:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">i_next</span><span class="p">,</span> <span class="n">j_next</span><span class="p">))</span>
</pre></table></code></div></div><p>并查集实现方法的代码：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UF</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="c1"># 根据 grid 生成 parent 数组
</span>        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">"1"</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">j</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_1</span><span class="p">,</span> <span class="n">node_2</span><span class="p">):</span>
        <span class="n">root_1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">node_1</span><span class="p">)</span>
        <span class="n">root_2</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">node_2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root_1</span> <span class="o">==</span> <span class="n">root_2</span>
    
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_1</span><span class="p">,</span> <span class="n">node_2</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">connected</span><span class="p">(</span><span class="n">node_1</span><span class="p">,</span> <span class="n">node_2</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="n">root_1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">node_1</span><span class="p">)</span>
        <span class="n">root_2</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">node_2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">root_1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">root_2</span><span class="p">]:</span>
            <span class="n">root_1</span><span class="p">,</span> <span class="n">root_2</span> <span class="o">=</span> <span class="n">root_2</span><span class="p">,</span> <span class="n">root_1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">root_1</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">weight</span><span class="p">[</span><span class="n">root_2</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">while</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">node</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numIslands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 高度和宽度
</span>        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># 初始化 Union-Find 类，多一个留给水源
</span>        <span class="n">uf</span> <span class="o">=</span> <span class="n">UF</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="c1"># 遍历岛屿
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">"1"</span><span class="p">:</span>
                    <span class="c1"># 当判断为陆地时，检查附近的格子
</span>                    <span class="c1"># 只需要判断右边和下边的格子是因为这样足够可以检查到所有的边了
</span>                    <span class="k">for</span> <span class="n">i_next</span><span class="p">,</span> <span class="n">j_next</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">i_next</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">j_next</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">i_next</span><span class="p">][</span><span class="n">j_next</span><span class="p">]</span> <span class="o">==</span> <span class="s">"1"</span><span class="p">:</span>
                            <span class="n">node_1</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">j</span> 
                            <span class="n">node_2</span> <span class="o">=</span> <span class="n">i_next</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">j_next</span>
                            <span class="c1"># 连接
</span>                            <span class="n">uf</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">node_1</span><span class="p">,</span> <span class="n">node_2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">uf</span><span class="p">.</span><span class="n">count</span>
</pre></table></code></div></div><h1 id="130-surrounded-regions">130. Surrounded Regions</h1><p>第 130 题，被围绕的区域：给你一个 M × N 的二维矩阵，其中包含字符 <code class="language-plaintext highlighter-rouge">X</code> 和 <code class="language-plaintext highlighter-rouge">O</code>，让你找到矩阵中<strong>四面</strong>被 <code class="language-plaintext highlighter-rouge">X</code> 围住的 <code class="language-plaintext highlighter-rouge">O</code>，并且把它们替换成 <code class="language-plaintext highlighter-rouge">X</code>。</p><p>根据题意，四面，不包括斜角，因此边和角上的<code class="language-plaintext highlighter-rouge">O</code>一定不会被围住。所以这道题的基本思路是从边角上的<code class="language-plaintext highlighter-rouge">O</code>出发，找到跟这些<code class="language-plaintext highlighter-rouge">O</code>连通的其他<code class="language-plaintext highlighter-rouge">O</code>，替换剩下的<code class="language-plaintext highlighter-rouge">O</code>即可。</p><p>具体有两种方法，第一种是正常的 DFS 的方案，先用 for 循环遍历棋盘的<strong>四边</strong>，用 DFS 算法把那些与边界相连的<code class="language-plaintext highlighter-rouge">O</code>换成一个特殊字符，比如<code class="language-plaintext highlighter-rouge">#</code>；然后再遍历整个棋盘，把剩下的<code class="language-plaintext highlighter-rouge">O</code>换成<code class="language-plaintext highlighter-rouge">X</code>，把<code class="language-plaintext highlighter-rouge">#</code>恢复成<code class="language-plaintext highlighter-rouge">O</code>。这样就能完成题目的要求，时间复杂度$O(MN)$:</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">board</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""
        Do not return anything, modify board in-place instead.
        """</span>
        <span class="c1"># 获取棋盘的宽高
</span>        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>

        <span class="c1"># 深度优先遍历
</span>        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
            <span class="c1"># 不符合范围的索引或者访问过的节点直接返回
</span>            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span> <span class="k">return</span>

            <span class="c1"># 前序遍历操作
</span>            <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            
            <span class="c1"># 仅当目前为止为'O'时继续递归
</span>            <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">'O'</span><span class="p">:</span>
                <span class="c1"># 将'O'替换成'#'
</span>                <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">'#'</span>
                <span class="c1"># 遍历与其直接相邻的其他节点
</span>                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>
        
        <span class="c1"># 对所有边角的'O'调用dfs
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="c1"># 将'#'替换回'O'，将剩下的'O'换成'X'
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">'O'</span><span class="p">:</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">'X'</span>
                <span class="k">elif</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">'#'</span><span class="p">:</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">'O'</span>
</pre></table></code></div></div><p>第二种方法，就是使用上一题提到的 Union-Find 算法解决，虽然实现复杂一些，甚至效率也略低，但这是使用 Union-Find 算法的通用思想，值得一学。</p><p>在这道题中，这些<code class="language-plaintext highlighter-rouge">O</code>就是单独的节点，「连通性」就是指节点与节点之间是否是直接相邻。</p><p>那么我们就可以直接使用上一题的代码来解决这个问题，只要首先创建一个虚拟头节点<code class="language-plaintext highlighter-rouge">dummy</code>，然后将所有的边角上的<code class="language-plaintext highlighter-rouge">O</code>都指向该节点，那么这些节点都归属于同一个连通分量了。再将所有的<code class="language-plaintext highlighter-rouge">O</code>和其邻接的<code class="language-plaintext highlighter-rouge">O</code>连通，所有的<code class="language-plaintext highlighter-rouge">O</code>就会分属于不同的连通分量，而和<code class="language-plaintext highlighter-rouge">dummy</code>处在同一个连通分量里的<code class="language-plaintext highlighter-rouge">O</code>都不需要替换；替换其他<code class="language-plaintext highlighter-rouge">O</code>即可。</p><p>最后剩下的问题就是，怎么把二维的数据投射到一维的数组上，最简单常用的方法就是<code class="language-plaintext highlighter-rouge">parent[i × n + j] = board[i][j]</code>其中<code class="language-plaintext highlighter-rouge">n</code>是<code class="language-plaintext highlighter-rouge">board</code>的宽度，也就是索引<code class="language-plaintext highlighter-rouge">j</code>对应的上限。然后让我们的虚拟头指针占用索引<code class="language-plaintext highlighter-rouge">m × n</code>，我们刚好需要构建一个大小为<code class="language-plaintext highlighter-rouge">m × n + 1</code>的数组。</p><p>参考代码：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UF</span><span class="p">:</span>
    <span class="c1"># Union-Find 的实现
</span>    <span class="c1"># 参考上题
</span>    <span class="c1"># ...
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">board</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""
        Do not return anything, modify board in-place instead.
        """</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># 给dummy留一个位置
</span>        <span class="n">uf</span> <span class="o">=</span> <span class="n">UF</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 定义虚拟头节点
</span>        <span class="n">dummy</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span>
        <span class="c1"># 将首行和末行的'O'和dummy连通
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">uf</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">dummy</span><span class="p">)</span>
            <span class="n">uf</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dummy</span><span class="p">)</span>
        <span class="c1"># 将首列和末列的`O`和dummy连通
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">uf</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">dummy</span><span class="p">)</span>
            <span class="n">uf</span><span class="p">.</span><span class="n">union</span><span class="p">((</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">dummy</span><span class="p">)</span>

        <span class="c1"># 定义方向数组
</span>        <span class="n">directions</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># 遍历连通所有的'O'
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">'O'</span><span class="p">:</span>
                    <span class="n">curr_node</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">j</span>
                    <span class="c1"># 将该'O'和上下左右的'O'连通
</span>                    <span class="k">for</span> <span class="n">dir_i</span><span class="p">,</span> <span class="n">dir_j</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">dir_i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">dir_j</span><span class="p">]</span> <span class="o">==</span> <span class="s">'O'</span><span class="p">:</span>
                            <span class="n">neighbor</span> <span class="o">=</span> <span class="n">curr_node</span> <span class="o">+</span> <span class="n">dir_i</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">dir_j</span>
                            <span class="n">uf</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">curr_node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>
        
        <span class="c1"># 将所有不和dummy连通的'O'改为'X'
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">'O'</span><span class="p">:</span>
                    <span class="n">curr_node</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">j</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">uf</span><span class="p">.</span><span class="n">connected</span><span class="p">(</span><span class="n">curr_node</span><span class="p">,</span> <span class="n">dummy</span><span class="p">):</span>
                        <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">'X'</span>
</pre></table></code></div></div><p>参考文章：</p><p><a href="https://labuladong.gitee.io/algo/2/19/38/">UNION-FIND算法应用</a></p><h1 id="990-satisfiability-of-equality-equations">990. Satisfiability of Equality Equations</h1><p>这一题使用 Union-Find 算法解就比较优雅了。</p><p>题目给定一个数组<code class="language-plaintext highlighter-rouge">equations</code>，装着若干字符串表示的算式。每个算式<code class="language-plaintext highlighter-rouge">equations[i]</code>长度都是 4，而且只有等式或不等式两种情况：<code class="language-plaintext highlighter-rouge">a==b</code>或者<code class="language-plaintext highlighter-rouge">a!=b</code>，其中 a,b 可以是任意小写字母。算法要求是，如果<code class="language-plaintext highlighter-rouge">equations</code>中所有算式都不会互相冲突，返回<code class="language-plaintext highlighter-rouge">true</code>，否则返回<code class="language-plaintext highlighter-rouge">false</code>。</p><p>思路很明显，等式即是一种最简单的等价关系，满足自反性、对称性和传递性三种性质，<code class="language-plaintext highlighter-rouge">a==b</code>就等价于<code class="language-plaintext highlighter-rouge">a</code>和<code class="language-plaintext highlighter-rouge">b</code>连通。因此把 26 个字母作为节点，相等关系作为连通性，首先处理所有的等式划分好连通分量，然后使用不等式去验证关系即可：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UF</span><span class="p">:</span>
    <span class="c1"># Union-Find 的实现
</span>    <span class="c1"># 参考上上题
</span>    <span class="c1"># ...
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">equationsPossible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">equations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># 一共有26个字母
</span>        <span class="n">uf</span> <span class="o">=</span> <span class="n">UF</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>
        <span class="c1"># 暂存'a'的 ASCII 码
</span>        <span class="n">id_a</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
        <span class="c1"># 首先根据等式构建连通分量
</span>        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'='</span><span class="p">:</span>
                <span class="c1"># 连通等式两端两个字母对应的节点
</span>                <span class="n">uf</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">eq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">id_a</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="n">eq</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">-</span><span class="n">id_a</span><span class="p">)</span>
        
        <span class="c1"># 遍历不等式进行验证
</span>        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">:</span>
            <span class="c1"># 如果不等式两端字母连通则说明矛盾
</span>            <span class="k">if</span> <span class="n">eq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'!'</span> <span class="ow">and</span> <span class="n">uf</span><span class="p">.</span><span class="n">connected</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">eq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">id_a</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="n">eq</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">-</span><span class="n">id_a</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
         
        <span class="k">return</span> <span class="bp">True</span>
</pre></table></code></div></div><p>参考文章：</p><p><a href="https://labuladong.gitee.io/algo/2/19/38/">UNION-FIND算法应用</a></p><h1 id="kruskal-最小生成树算法">KRUSKAL 最小生成树算法</h1><p>最小生成树算法主要有 Prim 算法和 Kruskal 算法两种，这两种算法都运用了贪心思想，但从实现上来说存在挺大差异，本部分主要使用的 Kruskal 算法</p><p>Kruskal 算法其实很容易理解和记忆，其关键是要熟悉并查集算法，如果不熟悉，建议先看下前几道题的 Union-Find 并查集算法。</p><h2 id="最小生成树定义">最小生成树定义</h2><p>「树」和「图」的根本区别：<strong>树不会包含环，图可以包含环。</strong></p><p>如果一幅图没有环，完全可以用一棵树的形式来表示。专业点说，树就是「无环连通图」。</p><p>图的「生成树」就是在图中找一棵包含图中的所有节点的树。专业点说，生成树是含有图中所有顶点的「无环连通子图」。</p><p>对于加权图，每条边都有权重，所以每棵生成树都有一个权重和。</p><p>那么「最小生成树」就很好理解了，<strong>在所有可能的生成树中，权重和最小的那棵生成树就叫「最小生成树」</strong>。</p><blockquote><p>一般来说，我们都是在<strong>无向加权图</strong>的情境下计算最小生成树的，所以现实场景中，图的边权重一般代表成本、距离这样的标量。</p></blockquote><h2 id="union-find-并查集算法">Union-Find 并查集算法</h2><p>图的生成树是含有其所有顶点的「无环连通子图」，最小生成树是权重和最小的生成树。</p><p>Union-Find 并查集算法，是用来用来高效处理图中连通分量的问题。</p><p>Union-Find 并查集算法的实现可以参考前几道题，主要运用<code class="language-plaintext highlighter-rouge">size</code>数组和路径压缩技巧提高算法效率。</p><h2 id="kruskal-算法">Kruskal 算法</h2><p>所谓最小生成树，就是图中若干边的集合（后文称为<code class="language-plaintext highlighter-rouge">mst</code>，最小生成树的英文缩写），算法要保证这些边：</p><ol><li><p>包含图中的所有节点。</p><li><p>形成的结构是树结构（即不存在环）。</p><li><p>权重和最小。</p></ol><p>Union-Find 算法主要负责做到前两条，关键在于第 3 点，如何保证得到的这棵生成树权重和最小。</p><p>这里主要用到的是贪心思路：</p><p>将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和<code class="language-plaintext highlighter-rouge">mst</code>中的其他边不会形成环，则这条边是最小生成树的一部分，将它加入<code class="language-plaintext highlighter-rouge">mst</code>集合；否则，这条边不是最小生成树的一部分，不加入<code class="language-plaintext highlighter-rouge">mst</code>集合。</p><p>按照这个思路，最后<code class="language-plaintext highlighter-rouge">mst</code>集合中的边就形成了最小生成树。</p><p>下面用三个例题来应用 Kruskal 算法。</p><h2 id="261-graph-valid-tree">261. Graph Valid Tree</h2><p>这道题其实就是判断一张无向图中是否有环。</p><p>遍历所有的边，首先判断边的两个节点是否在同一个连通分量中，如果是，则这条边的建立会形成环，返回<code class="language-plaintext highlighter-rouge">False</code>。</p><p>遍历完成之后连通分量的数量就是树的数量，所以最后需要检查连通分量的数量是否为 1。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UF</span><span class="p">:</span>
    <span class="c1"># 参考 Union-Find 算法部分
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">validTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">uf</span> <span class="o">=</span> <span class="n">UF</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># 遍历所有边
</span>        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">uf</span><span class="p">.</span><span class="n">connected</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># 如果两个节点已经连通，则会产生环
</span>                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 否则，连通两个节点
</span>                <span class="n">uf</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># 保证最后只剩一个连通分量，所有节点都在一棵树里
</span>        <span class="k">return</span> <span class="n">uf</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
</pre></table></code></div></div><h2 id="1135-connecting-cities-with-minimum-cost">1135. Connecting Cities With Minimum Cost</h2><p>这道题就可以转换为无向加权图中的最小生成树计算问题了，城市就是节点，而成本就是边的权重。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UF</span><span class="p">:</span>
    <span class="c1"># 参考 Union-Find 算法部分
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minimumCost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">connections</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">connections</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">uf</span> <span class="o">=</span> <span class="n">UF</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">min_cost</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">city1</span><span class="p">,</span> <span class="n">city2</span><span class="p">,</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">uf</span><span class="p">.</span><span class="n">connected</span><span class="p">(</span><span class="n">city1</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">city2</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># 如果两个城市未连通，则连通这条边
</span>                <span class="n">uf</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">city1</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">city2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">min_cost</span> <span class="o">+=</span> <span class="n">cost</span>
        
        <span class="c1"># 最后检查所有城市是否是连通的
</span>        <span class="k">if</span> <span class="n">uf</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">min_cost</span>
</pre></table></code></div></div><h2 id="1584-min-cost-to-connect-all-points">1584. Min Cost to Connect All Points</h2><p>这道题和上一题的区别就在于边需要自己生成，但是也并不难。</p><p>遍历生成所有的边，然后直接应用 Kruskal 算法即可。</p><p>唯一的问题就是在这里点的坐标只是用来计算成本的，在数据结构中还是用输入列表里的索引来表示。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UF</span><span class="p">:</span>
    <span class="c1"># 参考 Union-Find 算法部分
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minCostConnectPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 计算点的数量
</span>        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">uf</span> <span class="o">=</span> <span class="n">UF</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># 遍历生成带权重的边
</span>        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">xj</span><span class="p">,</span> <span class="n">yj</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xj</span> <span class="o">-</span> <span class="n">xi</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">yj</span> <span class="o">-</span> <span class="n">yi</span><span class="p">)</span>
                <span class="n">edges</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">distance</span><span class="p">))</span>

        <span class="c1"># 对边按照权重进行排序
</span>        <span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># 贪心算法
</span>        <span class="n">min_cost</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">,</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">uf</span><span class="p">.</span><span class="n">connected</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">):</span>
                <span class="c1"># 如果两个点没有连通，则将连通该条边
</span>                <span class="n">uf</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">)</span>
                <span class="n">min_cost</span> <span class="o">+=</span> <span class="n">cost</span>

        <span class="k">return</span> <span class="n">min_cost</span>
</pre></table></code></div></div><h1 id="277-find-the-celebrity">277. Find the Celebrity</h1><p>题目提供<code class="language-plaintext highlighter-rouge">n</code>个人之间的社交关系（两个人之间是否认识），设计算法找出这些人中的「名人」。</p><p>所谓「名人」有两个条件：</p><ol><li><p>所有其他人都认识「名人」；</p><li><p>「名人」不认识其他任何人。</p></ol><p>这是一个比较贴近实际的图相关的算法问题，社交关系，本质上可以抽象成一幅图。</p><p>我们可以把每个人看做图中的节点，「认识」就可以看做是节点之间的有向边，相当于社交软件上的「关注」，那么名人就是该图中一个特殊的节点。</p><p>题目提供了一个<code class="language-plaintext highlighter-rouge">knows(i, j)</code> API 来返回<code class="language-plaintext highlighter-rouge">i</code>是否认识<code class="language-plaintext highlighter-rouge">j</code>，本质上是在访问「邻接矩阵」。</p><p>最终题目要求返回名人的索引，或者<code class="language-plaintext highlighter-rouge">-1</code>来表示没有名人的情况。</p><h2 id="暴力解法">暴力解法</h2><p>简单的思路就是进行暴力穷举，把每个人遍历一遍，判断他和其他人的关系，最后筛选出名人。</p><h2 id="时间优化">时间优化</h2><p>可以简单根据两个人之间的认识关系来对名人的候选名单进行筛选。</p><p>两个人之间的认识情况无非四种，以两个人<code class="language-plaintext highlighter-rouge">i</code>和<code class="language-plaintext highlighter-rouge">j</code>来举例：</p><ol><li><p>如果<code class="language-plaintext highlighter-rouge">i</code>认识<code class="language-plaintext highlighter-rouge">j</code>，<code class="language-plaintext highlighter-rouge">j</code>不认识<code class="language-plaintext highlighter-rouge">i</code>，那么<code class="language-plaintext highlighter-rouge">i</code>一定不是名人；</p><li><p>如果<code class="language-plaintext highlighter-rouge">i</code>不认识<code class="language-plaintext highlighter-rouge">j</code>，<code class="language-plaintext highlighter-rouge">j</code>认识<code class="language-plaintext highlighter-rouge">i</code>，那么<code class="language-plaintext highlighter-rouge">j</code>一定不是名人；</p><li><p>如果两个互相认识，那么两个人都不是名人；</p><li><p>如果两个人互相不认识，那么两个人都不是名人。</p></ol><p>根据如上四条逻辑，可以先任意比较<code class="language-plaintext highlighter-rouge">n-1</code>对人之间的关系，每次比较都能筛掉至少一个人，如果图里有名人，那么<code class="language-plaintext highlighter-rouge">n-1</code>次比较之后剩下的人一定是名人，然后我们验证一下最后这个人和其他所有人的关系即可。</p><p>优化后时间复杂度为$O(N)$。</p><h2 id="空间优化">空间优化</h2><p>根据上一条时间优化的结果，我们可以只设定两个变量<code class="language-plaintext highlighter-rouge">cand</code>和<code class="language-plaintext highlighter-rouge">other</code>，两者之间淘汰之后交替赋值即可。优化后空间复杂度为$O(1)$。</p><h2 id="参考代码">参考代码</h2><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="c1"># The knows API is already defined for you.
# return a bool, whether a knows b
# def knows(a: int, b: int) -&gt; bool:
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findCelebrity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 初始化候选人 cand
</span>        <span class="n">cand</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># 遍历所有人
</span>        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">knows</span><span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                <span class="c1"># 只需要验证 cand 是否认识 other
</span>                <span class="c1"># 如果认识，直接淘汰 cand
</span>                <span class="c1"># 否则，淘汰 other
</span>                <span class="n">cand</span> <span class="o">=</span> <span class="n">other</span>
        
        <span class="c1"># 验证最后的 cand 是否是真正的名人
</span>        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cand</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
                <span class="c1"># 跳过自己的情况
</span>                <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">knows</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">cand</span><span class="p">))</span> <span class="ow">or</span> <span class="n">knows</span><span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                <span class="c1"># 如果存在 cand 认识其他人或者有人不认识 cand 的情况
</span>                <span class="c1"># 返回 -1
</span>                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">cand</span> 
</pre></table></code></div></div><p>参考链接：</p><p><a href="https://labuladong.gitee.io/algo/2/19/41/">众里寻他千百度：名流问题</a></p><h1 id="dijkstra-算法">DIJKSTRA 算法</h1><p>DIJKSTRA 算法 的输入是一幅图<code class="language-plaintext highlighter-rouge">graph</code>和一个起点<code class="language-plaintext highlighter-rouge">start</code>，目的是返回一个记录从 start 起点到所有节点的最短路径权重的数组。</p><p>这种问题一般称作 <strong>单源最短路径</strong> 问题。</p><p>函数签名如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">];</span>
</pre></table></code></div></div><p>其中<code class="language-plaintext highlighter-rouge">graph</code>的两种实现方式，邻接表和邻接矩阵均可，这里使用的是「带权重的邻接表」数据结构。只要能正确提供邻居节点和权重的信息即可。</p><p>其实现代码如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">''' 输入一个起点 start，计算从 start 到其他节点的最短距离
    Args:
        start: 输入的起点
        graph: 包含权重的邻接表
    Returns:
        包含从 start 到其他节点的最短距离的列表
    '''</span>
    <span class="c1"># 定义：distTo[i] 的值就是起点 start 到达节点 i 的最短路径权重
</span>    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">dist_to</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># base case，start 到自己的距离为 0
</span>    <span class="n">dist_to</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># 使用优先级队列决定节点遍历优先级，distFromStart 较小的排在前面
</span>    <span class="c1"># 从起点开始 BFS
</span>    <span class="n">pqueue</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>
    <span class="n">heapify</span><span class="p">(</span><span class="n">pqueue</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">pqueue</span><span class="p">:</span>
        <span class="n">curr_state</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pqueue</span><span class="p">)</span>
        <span class="n">curr_node_id</span> <span class="o">=</span> <span class="n">curr_state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">curr_dist_from_start</span> <span class="o">=</span> <span class="n">curr_state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">curr_dist_from_start</span> <span class="o">&gt;</span> <span class="n">dist_to</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]:</span>
            <span class="k">continue</span>
        
        <span class="c1"># 将 curNode 的相邻节点装入队列
</span>        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]:</span>
            <span class="n">neighbor_id</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dist_to_next_node</span> <span class="o">=</span> <span class="n">dist_to</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]</span> <span class="o">+</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># 更新 dist_to 列表
</span>            <span class="k">if</span> <span class="n">dist_to</span><span class="p">[</span><span class="n">neighbor_id</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist_to_next_node</span><span class="p">:</span>
                <span class="n">dist_to</span><span class="p">[</span><span class="n">neighbor_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_to_next_node</span>
                <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pqueue</span><span class="p">,</span> <span class="p">(</span><span class="n">dist_to_next_node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">dist_to</span>
</pre></table></code></div></div><h2 id="保存路径权重">保存路径权重</h2><p>该算法可以看作是一个 BFS 算法的加权图特化版。比起无权图中会使用<code class="language-plaintext highlighter-rouge">visited</code>数组记录节点的访问情况，加权图中因为不同路径走到同一个点的权重和会不同（即便运用了贪心思想），我们无法保证第一次访问某一节点时对应的路径就是最小权重的路径，所以没有必要再使用<code class="language-plaintext highlighter-rouge">visited</code>数组，取而代之的是需要保存每条路径的权重和，用于计算后续路径的权重，以及比较和更新从起点到某一节点的最小权重和。</p><p>这里保存权重有很多种方法，参考链接提供了一种构造<code class="language-plaintext highlighter-rouge">Stage</code>类来存储节点<code class="language-plaintext highlighter-rouge">node_id</code>和到该节点的距离<code class="language-plaintext highlighter-rouge">dist_from_start</code>的方法。但是在 Python 里可以不构造类<code class="language-plaintext highlighter-rouge">Stage</code>，比如上面提供的代码，直接将元组<code class="language-plaintext highlighter-rouge">(node_id, dist_from_start)</code>加入队列就行了。</p><h2 id="优先级队列">优先级队列</h2><p>比起用在无权图上的 BFS，Dijkstra 算法使用<strong>优先级队列</strong>取代了普通队列，其好处是<strong>每次出队列的都是待选节点中距离起点最近的节点</strong>。也就是说，该算法每一步迈出的都是最小步子，延伸至最近的节点，事实上就是 BFS 的概念。如果不用优先级队列，Dijkstra 算法就不具备 BFS 的「广度优先」属性。</p><p>这一特性保证了算法平等地开拓各条路径，这样就能更早找到权重最小路径，而越早发现权重最小路径，根据算法，就会有越多路径不需要遍历，就能节省更多时间。</p><p>在上述代码中，优先级队列是用最小堆的数据结构实现的，使用的 Python 包是<code class="language-plaintext highlighter-rouge">heapq</code>包。</p><h2 id="只计算起点-start-到某一个终点-end-的最短路径">只计算起点 start 到某一个终点 end 的最短路径</h2><p>脑子里过一遍 Dijkstra 算法，我们可以发现，在某一个节点<code class="language-plaintext highlighter-rouge">i</code>第一次入队列的时候，所对应的那条路径并不一定是最短路径。因为在节点<code class="language-plaintext highlighter-rouge">i</code>入队列的时候，遍历的是节点<code class="language-plaintext highlighter-rouge">i</code>当前路径上的前一个节点。我们设这个节点为<code class="language-plaintext highlighter-rouge">i0</code>，节点<code class="language-plaintext highlighter-rouge">i0</code>与起点的距离才是所有当前路径中的最小距离路径。因此从节点<code class="language-plaintext highlighter-rouge">i0</code>到节点<code class="language-plaintext highlighter-rouge">i</code>时，两者间的权重<code class="language-plaintext highlighter-rouge">weight(i0, i)</code>可能导致该条路径的总权重高于其他路径，也就是说，此时其他路径有可能能以更小的代价能到达节点<code class="language-plaintext highlighter-rouge">i</code>。而根据算法，接下来出队列的就会是那些距离起点更近的节点。</p><p>总结就是，<strong>某节点第一次入队列的时候找到的不一定是最短路径，但是当该节点第一次出队列时，对应的<code class="language-plaintext highlighter-rouge">dist_to_next_node</code>就一定是最短路径了</strong>。因为是「第一次」出队列，所以目前路径中没有经过该节点的存在，而因为队列是优先级队列，所以该节点是目前路径中距离起点最近的路径，因此一定是最短路径。</p><p>所以如果只计算起点 start 到某一个终点 end 的最短路径，代码只需要加一行：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1"># 输入起点 start 和终点 end, 返回起点到终点的最短距离
</span><span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    
    <span class="c1"># ...
</span>
    <span class="k">while</span> <span class="n">pqueue</span><span class="p">:</span>

        <span class="n">curr_dist_from_start</span><span class="p">,</span> <span class="n">curr_node_id</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pqueue</span><span class="p">)</span>

        <span class="c1"># 在这里加一个判断即可
</span>        <span class="k">if</span> <span class="n">curr_node_id</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">curr_dist_from_start</span>

        <span class="k">if</span> <span class="n">curr_dist_from_start</span> <span class="o">&gt;</span> <span class="n">dist_to</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]:</span>
            <span class="k">continue</span>
        
        <span class="c1"># ...
</span>
    <span class="c1"># 如果运行到这里，说明 start 无法走到 end
</span>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></table></code></div></div><h2 id="是否需要-visited-数组">是否需要 Visited 数组？</h2><p>在网上看到有的 Dijkstra 算法里会加上<code class="language-plaintext highlighter-rouge">visited</code>数组，然后在节点出队列时记录访问，在入队的时候检查节点的访问情况，像下面这样：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>

    <span class="c1"># ...
</span>
    <span class="c1"># 初始化 visited 集合
</span>    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">pqueue</span><span class="p">:</span>
        
        <span class="c1"># ...
</span>       
        <span class="c1"># 如果访问过该节点则跳过
</span>        <span class="k">if</span> <span class="n">curr_node_id</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># 出队的时候记录节点访问
</span>        <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr_node_id</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">curr_dist_from_start</span> <span class="o">&gt;</span> <span class="n">dist_to</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]:</span>
            <span class="k">continue</span>
        
        <span class="c1"># 将 curNode 的相邻节点装入队列
</span>        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]:</span>
            <span class="n">neighbor_id</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># 如果访问过则不入队
</span>            <span class="k">if</span> <span class="n">neighbor_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">dist_to_next_node</span> <span class="o">=</span> <span class="n">dist_to</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]</span> <span class="o">+</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># 更新 dist_to 列表
</span>                <span class="k">if</span> <span class="n">dist_to</span><span class="p">[</span><span class="n">neighbor_id</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist_to_next_node</span><span class="p">:</span>
                    <span class="n">dist_to</span><span class="p">[</span><span class="n">neighbor_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_to_next_node</span>
                    <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pqueue</span><span class="p">,</span> <span class="p">(</span><span class="n">dist_to_next_node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">dist_to</span>
</pre></table></code></div></div><p>事实上并没有必要，因为这和<code class="language-plaintext highlighter-rouge">dist_to</code>数组的应用是等价的。上个部分说到当某一节点第一次出队的时候，就说明得到了从起点到该节点的权重最小路径。而在每一个节点出队的时候，我们都有一个条件判断</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>        <span class="k">if</span> <span class="n">curr_dist_from_start</span> <span class="o">&gt;</span> <span class="n">dist_to</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]:</span>
            <span class="k">continue</span>
</pre></table></code></div></div><p>来判断当前路径是否大于最小路径，事实上等价于判断该节点是否访问过了。</p><p>在之后邻居节点入队的条件判断</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>        <span class="k">if</span> <span class="n">dist_to</span><span class="p">[</span><span class="n">neighbor_id</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist_to_next_node</span><span class="p">:</span>
                <span class="n">dist_to</span><span class="p">[</span><span class="n">neighbor_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_to_next_node</span>
                <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pqueue</span><span class="p">,</span> <span class="p">(</span><span class="n">dist_to_next_node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></table></code></div></div><p>也是同样的道理，一旦访问过该节点，那么其对应的最小权重路径已经找到，其在<code class="language-plaintext highlighter-rouge">dist_to</code>里的值一定是最小值，因此该判断一定为否，相当于存在于<code class="language-plaintext highlighter-rouge">visited</code>数组里了。</p><p>即便使用了<code class="language-plaintext highlighter-rouge">visited</code>数组，节点还是有可能会被多次访问的，这取决于图的具体情况。所以用<code class="language-plaintext highlighter-rouge">visited</code>数组稍微有点误导性。而这里我们可以看到<code class="language-plaintext highlighter-rouge">dist</code>数组的更新是在节点入队的时候就完成了。结合入队的判断条件可以在该节点入队后出队前减少一些该节点重复入队的情况，故而避免不必要的堆排序，比起使用<code class="language-plaintext highlighter-rouge">visited</code>数组的方法时间消耗更少。</p><h2 id="时间复杂度分析">时间复杂度分析</h2><p>Dijkstra 算法的复杂度随着其内部数据结构的实现的不同而不同。假设图中的节点数量为<code class="language-plaintext highlighter-rouge">V</code>，边的数量为<code class="language-plaintext highlighter-rouge">E</code>，代码中的优先队列是用二叉堆实现的。那么由于在最差情况下，节点可能会重复进队，而这个队列内元素数量则和边的数量成正比，因此构造二叉堆的时间复杂度就是$O(Elog(E))$。同时邻接表中所有的边的信息都会被遍历一遍，因此总的时间复杂度就是：</p><p>$O(E+Elog(E))=O(Elog(E))$</p><h2 id="参考链接">参考链接</h2><p><a href="https://labuladong.gitee.io/algo/2/19/42/">我写了一个模板，把 DIJKSTRA 算法变成了默写题</a></p><h2 id="743-network-delay-time">743. Network Delay Time</h2><p>这道题就是很简单的 Dijkstra 算法的应用，其中的优先级队列的实现是用 Python 中的 heapq 库，速度更快一些。</p><p>根据题目输入构造完图的邻接表之后，找到所有节点距离起点最远的那一个，就是所有节点连通的时间了。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">''' 输入一个起点 start，计算从 start 到其他节点的最短距离
    Args:
        start: 输入的起点
        graph: 包含权重的邻接表
    Returns:
        包含从 start 到其他节点的最短距离的列表
    '''</span>
    <span class="c1"># 定义：distTo[i] 的值就是起点 start 到达节点 i 的最短路径权重
</span>    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">dist_to</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># base case，start 到自己的距离为 0
</span>    <span class="n">dist_to</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># 使用优先级队列决定节点遍历优先级，distFromStart 较小的排在前面
</span>    <span class="c1"># 从起点开始 BFS
</span>    <span class="n">pqueue</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>
    <span class="n">heapify</span><span class="p">(</span><span class="n">pqueue</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">pqueue</span><span class="p">:</span>
        <span class="n">curr_dist_from_start</span><span class="p">,</span> <span class="n">curr_node_id</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pqueue</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr_dist_from_start</span> <span class="o">&gt;</span> <span class="n">dist_to</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]:</span>
            <span class="k">continue</span>
        
        <span class="c1"># 将 curNode 的相邻节点装入队列
</span>        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]:</span>
            <span class="n">neighbor_id</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dist_to_next_node</span> <span class="o">=</span> <span class="n">dist_to</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]</span> <span class="o">+</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># 更新 dist_to 列表
</span>            <span class="k">if</span> <span class="n">dist_to</span><span class="p">[</span><span class="n">neighbor_id</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist_to_next_node</span><span class="p">:</span>
                <span class="n">dist_to</span><span class="p">[</span><span class="n">neighbor_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_to_next_node</span>
                <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pqueue</span><span class="p">,</span> <span class="p">(</span><span class="n">dist_to_next_node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">dist_to</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">networkDelayTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 构造邻接表
</span>        <span class="c1"># 因为节点编号从 1 开始，表大小为 n + 1
</span>        <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">append</span><span class="p">((</span><span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">time</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        
        <span class="c1"># 调用 dijkstra 算法计算以节点 k 为起点到其他节点的最短路径
</span>        <span class="n">dist_to</span> <span class="o">=</span> <span class="n">dijkstra</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>

        <span class="c1"># 找到最长的路径
</span>        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="n">dist_to</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">):</span>
                <span class="c1"># 如果有节点不可到达，返回 -1
</span>                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">res</span>
</pre></table></code></div></div><h2 id="1514-path-with-maximum-probability">1514. Path with Maximum Probability</h2><p>这道题对比于常规的 Dijkstra 算法来说，只是把权重相加变成了概率相乘。</p><p>同时由于概率要取最大，而数据结构有时只能限制使用最小堆，所以需要把从起点到各个节点的概率取反即可。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxProbability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">succProb</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        
        <span class="c1"># 构造邻接表
</span>        <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="n">proba</span> <span class="o">=</span> <span class="n">succProb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">append</span><span class="p">((</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">proba</span><span class="p">))</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]].</span><span class="n">append</span><span class="p">((</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">proba</span><span class="p">))</span>
        
        <span class="c1"># 定义：proba_to[i] 的值就是起点 start 到达节点 i 的中最大概率
</span>        <span class="n">proba_to</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

        <span class="c1"># base case，start 到自己的概率为 -1
</span>        <span class="c1"># 因为 Python 不提供最大堆的实现
</span>        <span class="c1"># 所以所有概率用对应的负数表示
</span>        <span class="c1"># 最终输出最小值
</span>        <span class="n">proba_to</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># 使用优先级队列决定节点遍历优先级，proba_from_start 较小的排在前面
</span>        <span class="n">pqueue</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">pqueue</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">pqueue</span><span class="p">:</span>
            <span class="n">curr_proba_from_start</span><span class="p">,</span> <span class="n">curr_node_id</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pqueue</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">curr_node_id</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span> <span class="n">curr_proba_from_start</span>
            
            <span class="k">if</span> <span class="n">curr_proba_from_start</span> <span class="o">&gt;</span> <span class="n">proba_to</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># 将 curNode 的相邻节点装入队列
</span>            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]:</span>
                <span class="n">neighbor_id</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">proba_to_next_node</span> <span class="o">=</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">proba_to</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]</span> <span class="o">*</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># 更新 proba_to 列表
</span>                <span class="k">if</span> <span class="n">proba_to</span><span class="p">[</span><span class="n">neighbor_id</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">proba_to_next_node</span><span class="p">:</span>
                    <span class="n">proba_to</span><span class="p">[</span><span class="n">neighbor_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">proba_to_next_node</span>
                    <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pqueue</span><span class="p">,</span> <span class="p">(</span><span class="n">proba_to_next_node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">return</span> <span class="mi">0</span>
</pre></table></code></div></div><h2 id="1631-path-with-minimum-effort">1631. Path With Minimum Effort</h2><p>这道题也是使用 Dijkstra 算法做，稍微对代码进行更改即可。</p><p>首先，问题变成二维，对于节点的描述变成二元坐标<code class="language-plaintext highlighter-rouge">(i, j)</code>。</p><p>在路径前进的过程中，需要记录的是路径上的体力消耗，Effort，也就是最大高度差。</p><p>更改结果数组<code class="language-plaintext highlighter-rouge">min_effort</code>的定义：<strong><code class="language-plaintext highlighter-rouge">min_effort[i][j]</code>保存的是从起点到点<code class="language-plaintext highlighter-rouge">(i,j)</code>的最小体力消耗</strong>，也就是需要从所有路径中挑出体力消耗最少的那一条。颇有动态规划的味道。</p><p>而实际上这就是动态规划。</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minimumEffortPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        
        <span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># min_effort[i][j] 的值就是起点 (0,0) 到达位置 (i,j) 的最小体力消耗
</span>        <span class="n">min_effort</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)]</span><span class="o">*</span><span class="n">cols</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">)]</span>

        <span class="c1"># base case，到达起点的最小 effort 是 0
</span>        <span class="n">min_effort</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># 使用优先级队列决定节点遍历优先级，effort 较小的排在前面
</span>        <span class="c1"># 从起点开始 BFS
</span>        <span class="n">pqueue</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">pqueue</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">pqueue</span><span class="p">:</span>
            <span class="c1"># 取出队列中最小 effort 的坐标
</span>            <span class="n">curr_effort</span><span class="p">,</span> <span class="n">curr_row</span><span class="p">,</span> <span class="n">curr_col</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">pqueue</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">curr_row</span> <span class="o">==</span> <span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">curr_col</span> <span class="o">==</span> <span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">curr_effort</span>

            <span class="c1"># 如果已经存在消耗更小的路径，则跳过
</span>            <span class="k">if</span> <span class="n">curr_effort</span> <span class="o">&gt;</span> <span class="n">min_effort</span><span class="p">[</span><span class="n">curr_row</span><span class="p">][</span><span class="n">curr_col</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># 将相邻上下左右四个位置装入队列
</span>            <span class="k">for</span> <span class="n">dist_row</span><span class="p">,</span> <span class="n">dist_col</span> <span class="ow">in</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]:</span>
                <span class="c1"># 计算下个位置的坐标
</span>                <span class="n">next_row</span><span class="p">,</span> <span class="n">next_col</span> <span class="o">=</span> <span class="n">curr_row</span> <span class="o">+</span> <span class="n">dist_row</span><span class="p">,</span> <span class="n">curr_col</span> <span class="o">+</span> <span class="n">dist_col</span>
                <span class="k">if</span> <span class="n">next_row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">next_row</span> <span class="o">&gt;=</span> <span class="n">rows</span> <span class="ow">or</span> <span class="n">next_col</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">next_col</span> <span class="o">&gt;=</span> <span class="n">cols</span><span class="p">:</span>
                    <span class="c1"># 如果坐标不合法则跳过
</span>                    <span class="k">continue</span>
                
                <span class="c1"># 计算当前位置和下个位置的高度差
</span>                <span class="n">new_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">heights</span><span class="p">[</span><span class="n">next_row</span><span class="p">][</span><span class="n">next_col</span><span class="p">]</span> <span class="o">-</span> <span class="n">heights</span><span class="p">[</span><span class="n">curr_row</span><span class="p">][</span><span class="n">curr_col</span><span class="p">])</span>
                <span class="c1"># 计算到下一个位置的 effort
</span>                <span class="n">effor_next_step</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">new_diff</span><span class="p">,</span> <span class="n">curr_effort</span><span class="p">)</span>

                <span class="c1"># 更新 min_effort 列表， 如果已存在 effort 更小的路径则不入队
</span>                <span class="k">if</span> <span class="n">min_effort</span><span class="p">[</span><span class="n">next_row</span><span class="p">][</span><span class="n">next_col</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">effor_next_step</span><span class="p">:</span>
                    <span class="n">min_effort</span><span class="p">[</span><span class="n">next_row</span><span class="p">][</span><span class="n">next_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">effor_next_step</span>
                    <span class="n">heappush</span><span class="p">(</span><span class="n">pqueue</span><span class="p">,</span> <span class="p">(</span><span class="n">effor_next_step</span><span class="p">,</span> <span class="n">next_row</span><span class="p">,</span> <span class="n">next_col</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">min_effort</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></table></code></div></div><h2 id="1345-跳跃游戏-iv">1345. 跳跃游戏 IV</h2><p>虽然这道题题干中输入数据是以数组的形式存储，但实际上下标与下标之间的 <code class="language-plaintext highlighter-rouge">jump</code> 实际上就可以等价于节点相连。</p><p>所以这道题的数据可以转换为一张<strong>无向无权图</strong>，目标就是找到起点到终点的最短路径。</p><p>所以思路就变得很清晰了：DFS + 剪枝。</p><p>我们使用 <code class="language-plaintext highlighter-rouge">difaultdict</code> 来存储相同值的索引，作为类似于邻接表一样的结构。</p><p>在这里需要注意，在 DFS 遍历到一个索引时就将所有和该索引具有相同值的索引推到队列中，然后要<strong>删除该索引</strong>，这样才不会重复遍历这些索引判断是否需要将其推入栈。</p><p>虽然会有 <code class="language-plaintext highlighter-rouge">visitedIndex</code> 集合来保证这些重复索引不会被推入栈，但是在相同值的索引数量太多的时候，还是需要$O(n^2)$的时间复杂度去判断，所以需要<strong>过河拆桥</strong>。</p><p>然后实现 DFS，这里我掉进了一个大坑：</p><p>DFS 需要一个队列，而 Python 中队列的实现有好多种：</p><ol><li><p>双端队列 <code class="language-plaintext highlighter-rouge">q = collections.deque()</code>，使用 <code class="language-plaintext highlighter-rouge">q.addpend()</code> 和 <code class="language-plaintext highlighter-rouge">q.popleft()</code> 方法来进出队列；</p><li><p>列表 <code class="language-plaintext highlighter-rouge">q = []</code>，使用 <code class="language-plaintext highlighter-rouge">q.addpend()</code> 和 <code class="language-plaintext highlighter-rouge">q.pop(0)</code> 方法来进出队列；</p><li><p>同上，使用列表，但是出队列使用读取索引加 <code class="language-plaintext highlighter-rouge">q = q[1:]</code> 的方法来更新队列。</p></ol><p>第一个方法的时间复杂度是 $O(1)$，第二个和第三个的方法是 $O(n)$。</p><p>原因在于列表在使用 <code class="language-plaintext highlighter-rouge">pop(i)</code> 方法之后，只要 <code class="language-plaintext highlighter-rouge">i</code> 不是最后一个元素的索引，列表就需要将删除元素往后的所有元素前向移位一格，所以时间复杂度为 $O(n)$。</p><p>第三个方法一样，需要逐个元素复制，一样消耗时间。</p><p>所以队列一定要用 <code class="language-plaintext highlighter-rouge">collections.deque</code> 来实现。</p><p>参考代码如下：</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minJumps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        
        <span class="c1"># 用来记录相同值的索引的 dict
</span>        <span class="n">indexSameValue</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="c1"># 补充记录下跳跃点的信息
</span>        <span class="c1"># 并且删除无用的索引（和前后索引值相同的索引）
</span>        <span class="n">arrReduced</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexSameValue</span><span class="p">[</span><span class="n">value</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
                <span class="n">arrReduced</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arrReduced</span>

        <span class="c1"># 创建辅助用数据结构
</span>        <span class="n">visitedIndex</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">count</span>
        <span class="n">visitedIndex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c1"># 双端队列更快！！
</span>        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># DFS
</span>        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="c1"># DFS 的当前位置
</span>            <span class="n">idx</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="c1"># 如果到达终点，则输出当前步数
</span>            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">step</span>
            
            <span class="n">value</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="c1"># 遍历所有相同值的索引，也就是跳跃
</span>            <span class="k">for</span> <span class="n">next_idx</span> <span class="ow">in</span> <span class="n">indexSameValue</span><span class="p">[</span><span class="n">value</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">visitedIndex</span><span class="p">[</span><span class="n">next_idx</span><span class="p">]:</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">next_idx</span><span class="p">,</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">visitedIndex</span><span class="p">[</span><span class="n">next_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c1"># 过河拆桥，避免重复判断
</span>            <span class="k">del</span> <span class="n">indexSameValue</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="c1"># 把后一个索引加入队列
</span>            <span class="k">if</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visitedIndex</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">visitedIndex</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c1"># 把前一个索引加入队列
</span>            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visitedIndex</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">visitedIndex</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/leetcode/'>LeetCode</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/leetcode/" class="post-tag no-text-decoration" >LeetCode</a> <a href="/tags/graph/" class="post-tag no-text-decoration" >Graph</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=LeetCode 刷题记录 - 数据结构之图（Graph） - Stone SHI&url=/posts/LeetCode_graph/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=LeetCode 刷题记录 - 数据结构之图（Graph） - Stone SHI&u=/posts/LeetCode_graph/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=LeetCode 刷题记录 - 数据结构之图（Graph） - Stone SHI&url=/posts/LeetCode_graph/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', '')" data-toggle="tooltip" data-placement="top" title=""> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/LeetCode_daily_challenge/">LeetCode 刷题记录 - 每日一题</a><li><a href="/posts/LeetCode_backtrack/">LeetCode 刷题记录 - 回溯算法</a><li><a href="/posts/LeetCode_dynamic_programming/">LeetCode 刷题记录 - Dynamic Programming</a><li><a href="/posts/Machine-Learning/">Machine Learning - ESMI_MES-08 - Apprentissage artificiel</a><li><a href="/posts/LeetCode_graph/">LeetCode 刷题记录 - 数据结构之图（Graph）</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/tags/block-chain/">Block chain</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/parser/">Parser</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/backend/">Backend</a> <a class="post-tag" href="/tags/blog/">Blog</a> <a class="post-tag" href="/tags/compilation/">Compilation</a> <a class="post-tag" href="/tags/functional-programming/">Functional Programming</a> <a class="post-tag" href="/tags/java/">Java</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/LeetCode_linked_list/"><div class="card-body"> <span class="timeago small" >Dec 28, 2021<i class="unloaded">2021-12-28T04:26:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>LeetCode 刷题记录 - 数据结构之链表（Linked List）</h3><div class="text-muted small"><p> 参考链接： 一文搞懂单链表的六大解题套路 21. Merge Two Sorted Lists 方法：双指针 小技巧：代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 dummy 节点。你可以试试，如果不使用 dummy 虚拟节点，代码会复杂很多，而有了 dummy 节点这个占位节点，可以避免处理空指针的情况，降低代码的复杂性。 # De...</p></div></div></a></div><div class="card"> <a href="/posts/LeetCode_data_structure_design/"><div class="card-body"> <span class="timeago small" >Jan 8<i class="unloaded">2022-01-08T21:28:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>LeetCode 刷题记录 - 数据结构设计</h3><div class="text-muted small"><p> 146. LRU Cache 这道题的主要目标是构造一个数据结构来实现 LRU 缓存机制。 当内存的空间满了之后，我们总是需要按照一定的原则来删除内存中的数据，为新数据腾出空间。 LRU 就是这样一种机制，LRU 的全称是 Least Recently Used，也就是根据内容的最后一次使用时间来选择数据删除的优先级。 相比起最近使用过的数据，我们会优先选择...</p></div></div></a></div><div class="card"> <a href="/posts/LeetCode_daily_challenge/"><div class="card-body"> <span class="timeago small" >Jan 11<i class="unloaded">2022-01-11T21:01:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>LeetCode 刷题记录 - 每日一题</h3><div class="text-muted small"><p> 2022.01.11 - 1036. 逃离大迷宫 题干 在一个 $10^6 × 10^6$ 的网格中，每个网格上方格的坐标为(x, y)。 现在从源方格source = [sx, sy]开始出发，意图赶往目标方格target = [tx, ty]。数组blocked是封锁的方格列表，其中每个blocked[i] = [xi, yi]表示坐标为(xi, yi)的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/LeetCode_linked_list/" class="btn btn-outline-primary" prompt="Older"><p>LeetCode 刷题记录 - 数据结构之链表（Linked List）</p></a> <a href="/posts/LeetCode_data_structure_design/" class="btn btn-outline-primary" prompt="Newer"><p>LeetCode 刷题记录 - 数据结构设计</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/Shuxin_SHI">SHI Shuxin</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/tags/block-chain/">Block chain</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/parser/">Parser</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/backend/">Backend</a> <a class="post-tag" href="/tags/blog/">Blog</a> <a class="post-tag" href="/tags/compilation/">Compilation</a> <a class="post-tag" href="/tags/functional-programming/">Functional Programming</a> <a class="post-tag" href="/tags/java/">Java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
