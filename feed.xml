<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Stone SHI</title><subtitle>A sportive, outcoming, positive boy who always likes to challenge himself and never stops moving forward. </subtitle> <updated>2022-08-18T09:24:11+08:00</updated> <author> <name>SHI Shuxin</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 SHI Shuxin </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>LeetCode 刷题记录 - 回溯算法</title><link href="/posts/LeetCode_backtrack/" rel="alternate" type="text/html" title="LeetCode 刷题记录 - 回溯算法" /><published>2022-02-13T17:37:00+08:00</published> <updated>2022-08-18T09:19:47+08:00</updated> <id>/posts/LeetCode_backtrack/</id> <content src="/posts/LeetCode_backtrack/" /> <author> <name>Stone SHI</name> </author> <category term="Blogging" /> <category term="LeetCode" /> <summary> 回溯算法 46. 全排列 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: # 当前路径 path = [] # 合法路径集合 ans = [] # 记录访问过的节点 visited = set() def trackback(nums, i): # 将当前节点加入路径 path.append(nums[i]) # 标记当前节点不可用 visited.add(i) if len(path) == ... </summary> </entry> <entry><title>LeetCode 刷题记录 - 每日一题</title><link href="/posts/LeetCode_bit_operation/" rel="alternate" type="text/html" title="LeetCode 刷题记录 - 每日一题" /><published>2022-01-11T21:01:00+08:00</published> <updated>2022-01-11T21:01:00+08:00</updated> <id>/posts/LeetCode_bit_operation/</id> <content src="/posts/LeetCode_bit_operation/" /> <author> <name>Stone SHI</name> </author> <category term="Blogging" /> <category term="LeetCode" /> <summary> 2022.08.18 - 剑指 Offer II 004. 只出现一次的数字 题干 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。 思路 最简单的字典思路就不说了，直接上位运算的方法。 因为题目中给的所有的数字都是用 int32 来存储的，因此可以把每一个数字按照二进制位拆开来看。 当我们对所有数字按照二进制位进行求和的时候，唯一数字二进制位为 0 的位数的和必定为 3 或者为 为0. 那么就可以通过这个方法，筛选出唯一数字为 1 的所有二进制位，再还原。 唯一的问题就是编码问题，因为最后一位（31位）在有的语言中是补码意义上的反码，所以要另外判断（比如在 Python 中）。 代码 class Solution: def singleNumber(s... </summary> </entry> <entry><title>LeetCode 刷题记录 - 每日一题</title><link href="/posts/LeetCode_daily_challenge/" rel="alternate" type="text/html" title="LeetCode 刷题记录 - 每日一题" /><published>2022-01-11T21:01:00+08:00</published> <updated>2022-08-18T09:19:47+08:00</updated> <id>/posts/LeetCode_daily_challenge/</id> <content src="/posts/LeetCode_daily_challenge/" /> <author> <name>Stone SHI</name> </author> <category term="Blogging" /> <category term="LeetCode" /> <summary> 2022.01.11 - 1036. 逃离大迷宫 题干 在一个 $10^6 × 10^6$ 的网格中，每个网格上方格的坐标为(x, y)。 现在从源方格source = [sx, sy]开始出发，意图赶往目标方格target = [tx, ty]。数组blocked是封锁的方格列表，其中每个blocked[i] = [xi, yi]表示坐标为(xi, yi)的方格是禁止通行的。 每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格不在给出的封锁列表blocked上。同时，不允许走出网格。 只有在可以通过一系列的移动从源方格source到达目标方格target时才返回true。否则，返回false。 思路 这道题目的矩阵很大，直接搜索时间肯定会超时，但是有一个突破口，就是0 &amp;lt;= len(blocked) &amp;lt;= 200，blo... </summary> </entry> <entry><title>区块链 Lab - Smart Contracts</title><link href="/posts/Block_chain_TP2/" rel="alternate" type="text/html" title="区块链 Lab - Smart Contracts" /><published>2022-01-09T21:53:00+08:00</published> <updated>2022-01-09T21:53:00+08:00</updated> <id>/posts/Block_chain_TP2/</id> <content src="/posts/Block_chain_TP2/" /> <author> <name>Stone SHI</name> </author> <category term="Blogging" /> <category term="Block chain" /> <category term="Smart contracts" /> <summary> 1 Guidelines SmartPy is a high level language (implemented in a Python library) that lets you write smart contracts for Tezos in Python. Furthermore, the website of the project, https://smartpy.io contains handy tools to write, test, deploy smart contracts and interact with them. In this lab, we will use SmartPy and its online platform. 1.1 Do not lose your data! SmartPy uses cookies t... </summary> </entry> <entry><title>LeetCode 刷题记录 - 数据结构设计</title><link href="/posts/LeetCode_data_structure_design/" rel="alternate" type="text/html" title="LeetCode 刷题记录 - 数据结构设计" /><published>2022-01-08T21:28:00+08:00</published> <updated>2022-01-08T21:28:00+08:00</updated> <id>/posts/LeetCode_data_structure_design/</id> <content src="/posts/LeetCode_data_structure_design/" /> <author> <name>Stone SHI</name> </author> <category term="Blogging" /> <category term="LeetCode" /> <summary> 146. LRU Cache 这道题的主要目标是构造一个数据结构来实现 LRU 缓存机制。 当内存的空间满了之后，我们总是需要按照一定的原则来删除内存中的数据，为新数据腾出空间。 LRU 就是这样一种机制，LRU 的全称是 Least Recently Used，也就是根据内容的最后一次使用时间来选择数据删除的优先级。 相比起最近使用过的数据，我们会优先选择删除好久没用过的数据。 所以这道题的数据结构设计思路就是：双链表加上字典的组合。 使用链表是为了实现优先级的结构，即将最近访问的数据提到链表最前端，自然未使用的数据就会向链表末端下沉的。同时链表也能实现时间复杂度为$O(1)$的插入。双头的原因是为了方便删除节点。节点内需要同时存储上数据的key和value。存储key的原因在于删除节点时需要同时删除字典内的key，如果在节点中... </summary> </entry> </feed>
